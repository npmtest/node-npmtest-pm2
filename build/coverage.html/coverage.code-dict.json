{"/home/travis/build/npmtest/node-npmtest-pm2/test.js":"/* istanbul instrument in package npmtest_pm2 */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-pm2/lib.npmtest_pm2.js":"/* istanbul instrument in package npmtest_pm2 */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_pm2 = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_pm2 = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-pm2/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-pm2 && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_pm2 */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_pm2\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_pm2.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_pm2.rollup.js'] =\n            local.assetsDict['/assets.npmtest_pm2.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_pm2.__dirname + '/lib.npmtest_pm2.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/index.js":"/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\n\nprocess.env.PM2_PROGRAMMATIC = 'true';\n\nvar API = require('./lib/API.js');\n\nmodule.exports = new API;\nmodule.exports.custom = API;\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/API.js":"/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\n\nvar commander   = require('commander');\nvar fs          = require('fs');\nvar path        = require('path');\nvar async       = require('async');\nvar debug       = require('debug')('pm2:cli');\nvar util        = require('util');\nvar chalk       = require('chalk');\nvar exec        = require('child_process').exec;\nvar fclone      = require('fclone');\n\nvar conf         = require('../constants.js');\nvar Client      = require('./Client');\nvar Common      = require('./Common');\nvar KMDaemon    = require('./Interactor/InteractorDaemonizer');\nvar Config      = require('./tools/Config');\nvar Modularizer = require('./API/Modules/Modularizer.js');\nvar path_structure = require('../paths.js');\nvar UX          = require('./API/CliUx');\n\nvar IMMUTABLE_MSG = chalk.bold.blue('Use --update-env to update environment variables');\n\n/**\n * Main Function to be imported\n * can be aliased to PM2\n *\n * To use it when PM2 is installed as a module:\n *\n * var PM2 = require('pm2');\n *\n * var pm2 = PM2(<opts>);\n *\n *\n * @param {Object}  opts\n * @param {String}  [opts.cwd=<current>]         override pm2 cwd for starting scripts\n * @param {String}  [opts.pm2_home=[<paths.js>]] pm2 directory for log, pids, socket files\n * @param {Boolean} [opts.independent=false]     unique PM2 instance (random pm2_home)\n * @param {Boolean} [opts.daemon_mode=true]      should be called in the same process or not\n * @param {String}  [opts.public_key=null]       keymetrics bucket public key\n * @param {String}  [opts.secret_key=null]       keymetrics bucket secret key\n * @param {String}  [opts.machine_name=null]     keymetrics instance name\n */\nvar API = module.exports = function(opts) {\n  if (!opts) opts = {};\n  var that = this;\n\n  this.daemon_mode = typeof(opts.daemon_mode) == 'undefined' ? true : opts.daemon_mode;\n  this.pm2_home    = conf.PM2_ROOT_PATH;\n  this.public_key   = process.env.KEYMETRICS_SECRET || opts.public_key || null;\n  this.secret_key   = process.env.KEYMETRICS_PUBLIC || opts.secret_key || null;\n  this.machine_name = process.env.INSTANCE_NAME || opts.machine_name || null\n\n  /**\n   * CWD resolution\n   */\n  this.cwd         = process.cwd();\n  if (opts.cwd) {\n    this.cwd = path.resolve(opts.cwd);\n  }\n\n  /**\n   * PM2 HOME resolution\n   */\n  if (opts.pm2_home && opts.independent == true)\n    throw new Error('You cannot set a pm2_home and independent instance in same time');\n\n  if (opts.pm2_home) {\n    // Override default conf file\n    this.pm2_home        = opts.pm2_home;\n    conf = util._extend(conf, path_structure(this.pm2_home));\n  }\n  else if (opts.independent == true && conf.IS_WINDOWS === false) {\n    // Create an unique pm2 instance\n    var crypto = require('crypto');\n    var random_file = crypto.randomBytes(8).toString('hex');\n    this.pm2_home = path.join('/tmp', random_file);\n\n    // If we dont explicitly tell to have a daemon\n    // It will go as in proc\n    if (typeof(opts.daemon_mode) == 'undefined')\n      this.daemon_mode = false;\n    conf = util._extend(conf, path_structure(this.pm2_home));\n  }\n\n  this._conf = conf;\n\n  if (conf.IS_WINDOWS) {\n    // Weird fix, may need to be dropped\n    // @todo windows connoisseur double check\n    if (process.stdout._handle && process.stdout._handle.setBlocking)\n      process.stdout._handle.setBlocking(true);\n  }\n\n  this.Client = new Client({\n    pm2_home : that.pm2_home,\n    conf     : this._conf,\n    secret_key : this.secret_key,\n    public_key : this.public_key,\n    daemon_mode : this.daemon_mode,\n    machine_name : this.machine_name\n  });\n\n  this.gl_interact_infos = null;\n  this.gl_is_km_linked = false;\n\n  try {\n    var pid = fs.readFileSync(conf.INTERACTOR_PID_PATH);\n    pid = parseInt(pid.toString().trim());\n    process.kill(pid, 0);\n    that.gl_is_km_linked = true;\n  } catch(e) {\n    that.gl_is_km_linked = false;\n  }\n\n  // For testing purposes\n  if (this.secret_key && process.env.NODE_ENV == 'local_test')\n    that.gl_is_km_linked = true;\n\n  KMDaemon.getInteractInfo(this._conf, function(i_err, interact) {\n    that.gl_interact_infos = interact;\n  });\n};\n\n/**\n * Connect to PM2\n * Calling this command is now optional\n *\n * @param {Function} cb callback once pm2 is ready for commands\n */\nAPI.prototype.connect = function(noDaemon, cb) {\n  var that = this;\n  this.start_timer = new Date();\n\n  if (typeof(cb) == 'undefined') {\n    cb = noDaemon;\n    noDaemon = false;\n  } else if (noDaemon === true) {\n    // Backward compatibility with PM2 1.x\n    this.Client.daemon_mode = false;\n    this.daemon_mode = false;\n  }\n\n  this.Client.start(function(err, meta) {\n    if (err)\n      return cb(err);\n\n    if (meta.new_pm2_instance == false && that.daemon_mode === true)\n      return cb(err, meta);\n\n    // If new pm2 instance has been popped\n    // Lauch all modules\n    Modularizer.launchAll(that, function(err_mod) {\n      return cb(err, meta);\n    });\n  });\n}\n\n/**\n * Usefull when custom PM2 created with independent flag set to true\n * This will cleanup the newly created instance\n * by removing folder, killing PM2 and so on\n *\n * @param {Function} cb callback once cleanup is successfull\n */\nAPI.prototype.destroy = function(cb) {\n  var exec = require('shelljs').exec;\n  var that = this;\n\n  debug('Killing and deleting current deamon');\n\n  this.killDaemon(function() {\n    var cmd = 'rm -rf ' + that.pm2_home;\n    var test_path = path.join(that.pm2_home, 'module_conf.json');\n    var test_path_2 = path.join(that.pm2_home, 'pm2.pid');\n\n    if (that.pm2_home.indexOf('.pm2') > -1)\n      return cb(new Error('Destroy is not a allowed method on .pm2'));\n\n    if (fs.accessSync) {\n      fs.access(test_path, fs.R_OK, function(err) {\n        if (err) return cb(err);\n        debug('Deleting temporary folder %s', that.pm2_home);\n        exec(cmd, cb);\n      });\n      return false;\n    }\n\n    // Support for Node 0.10\n    fs.exists(test_path, function(exist) {\n      if (exist) {\n        debug('Deleting temporary folder %s', that.pm2_home);\n        exec(cmd, cb);\n      }\n      return cb(null);\n    });\n  });\n};\n\n/**\n * Disconnect from PM2 instance\n * This will allow your software to exit by itself\n *\n * @param {Function} [cb] optional callback once connection closed\n */\nAPI.prototype.disconnect = API.prototype.close = function(cb) {\n  var that = this;\n\n  if (!cb) cb = function() {};\n\n  this.Client.close(function(err, data) {\n    debug('The session lasted %ds', (new Date() - that.start_timer) / 1000);\n    return cb(err, data);\n  });\n};\n\n/**\n * Launch modules\n *\n * @param {Function} cb callback once pm2 has launched modules\n */\nAPI.prototype.launchModules = function(cb) {\n  Modularizer.launchAll(this, cb);\n};\n\n/**\n * Enable bus allowing to retrieve various process event\n * like logs, restarts, reloads\n *\n * @param {Function} cb callback called with 1st param err and 2nb param the bus\n */\nAPI.prototype.launchBus = function(cb) {\n  this.Client.launchBus(cb);\n};\n\n/**\n * Exit methods for API\n * @param {Integer} code exit code for terminal\n */\nAPI.prototype.exitCli = function(code) {\n  var that = this;\n\n  // Do nothing if PM2 called programmatically (also in speedlist)\n  if (conf.PM2_PROGRAMMATIC && process.env.PM2_USAGE != 'CLI') return false;\n\n  KMDaemon.disconnectRPC(function() {\n    that.Client.close(function() {\n      code = code || 0;\n      // Safe exits process after all streams are drained.\n      // file descriptor flag.\n      var fds = 0;\n      // exits process when stdout (1) and sdterr(2) are both drained.\n      function tryToExit() {\n        if ((fds & 1) && (fds & 2)) {\n          debug('This command took %ds to execute', (new Date() - that.start_timer) / 1000);\n          process.exit(code);\n        }\n      }\n\n      [process.stdout, process.stderr].forEach(function(std) {\n        var fd = std.fd;\n        if (!std.bufferSize) {\n          // bufferSize equals 0 means current stream is drained.\n          fds = fds | fd;\n        } else {\n          // Appends nothing to the std queue, but will trigger `tryToExit` event on `drain`.\n          std.write && std.write('', function() {\n            fds = fds | fd;\n            tryToExit();\n          });\n        }\n        // Does not write anything more.\n        delete std.write;\n      });\n      tryToExit();\n    });\n  });\n};\n\n//////////////////////////\n// Load all API methods //\n//////////////////////////\n\nrequire('./API/Deploy.js')(API);\nrequire('./API/Modules/Modules.js')(API);\nrequire('./API/Configuration.js')(API);\nrequire('./API/Extra.js')(API);\nrequire('./API/Version.js')(API);\nrequire('./API/Startup.js')(API);\nrequire('./API/LogManagement.js')(API);\nrequire('./API/Interaction.js')(API);\nrequire('./API/Containerizer.js')(API);\n\n////////////////////////////\n// Application management //\n////////////////////////////\n\n/**\n * Start a file or json with configuration\n * @param {Object||String} cmd script to start or json\n * @param {Function} cb called when application has been started\n */\nAPI.prototype.start = function(cmd, opts, cb) {\n  if (typeof(opts) == \"function\") {\n    cb = opts;\n    opts = {};\n  }\n  if (!opts)\n    opts = {};\n\n  var that = this;\n\n  if (util.isArray(opts.watch) && opts.watch.length === 0)\n    opts.watch = (opts.rawArgs ? !!~opts.rawArgs.indexOf('--watch') : !!~process.argv.indexOf('--watch')) || false;\n\n  if (Common.isConfigFile(cmd) || (typeof(cmd) === 'object'))\n    that._startJson(cmd, opts, 'restartProcessId', cb);\n  else\n    that._startScript(cmd, opts, cb);\n};\n\n/**\n * Reset process counters\n *\n * @method resetMetaProcess\n */\nAPI.prototype.reset = function(process_name, cb) {\n  var that = this;\n\n  function processIds(ids, cb) {\n    async.eachLimit(ids, conf.CONCURRENT_ACTIONS, function(id, next) {\n      that.Client.executeRemote('resetMetaProcessId', id, function(err, res) {\n        if (err) console.error(err);\n        Common.printOut(conf.PREFIX_MSG + 'Resetting meta for process id %d', id);\n        return next();\n      });\n    }, function(err) {\n      if (err) return cb(Common.retErr(err));\n      return cb ? cb(null, {success:true}) : that.speedList();\n    });\n  }\n\n  if (process_name == 'all') {\n    that.Client.getAllProcessId(function(err, ids) {\n      if (err) {\n        Common.printError(err);\n        return cb ? cb(Common.retErr(err)) : that.exitCli(conf.ERROR_EXIT);\n      }\n      return processIds(ids, cb);\n    });\n  }\n  else if (isNaN(process_name)) {\n    that.Client.getProcessIdByName(process_name, function(err, ids) {\n      if (err) {\n        Common.printError(err);\n        return cb ? cb(Common.retErr(err)) : that.exitCli(conf.ERROR_EXIT);\n      }\n      if (ids.length === 0) {\n        Common.printError('Unknown process name');\n        return cb ? cb(new Error('Unknown process name')) : that.exitCli(conf.ERROR_EXIT);\n      }\n      return processIds(ids, cb);\n    });\n  } else {\n    processIds([process_name], cb);\n  }\n};\n\n/**\n * Update daemonized PM2 Daemon\n *\n * @param {Function} cb callback when pm2 has been upgraded\n */\nAPI.prototype.update = function(cb) {\n  var that = this;\n\n  Common.printOut('Be sure to have the latest version by doing `npm install pm2@latest -g` before doing this procedure.');\n\n  // Dump PM2 processes\n  that.Client.executeRemote('notifyKillPM2', {}, function() {});\n\n  that.dump(function(err) {\n    debug('Dumping successfull', err);\n    that.killDaemon(function() {\n      debug('------------------ Everything killed', arguments);\n      that.Client.launchDaemon({interactor:false}, function(err, child) {\n        that.Client.launchRPC(function() {\n          that.resurrect(function() {\n            Common.printOut(chalk.blue.bold('>>>>>>>>>> PM2 updated'));\n            Modularizer.launchAll(that, function() {\n              KMDaemon.launchAndInteract(that._conf, null, function(err, data, interactor_proc) {\n                // Interactor error can be skipped here\n                return cb ? cb(null, {success:true}) : that.speedList();\n              });\n            });\n          });\n        });\n      });\n    });\n  });\n\n  return false;\n};\n\n/**\n * Graceful Reload an application\n *\n * @param {String} process_name Application Name or All\n * @param {Object} opts         Options\n * @param {Function} cb         Callback\n */\nAPI.prototype.gracefulReload = function(process_name, opts, cb) {\n  var that = this;\n\n  if (typeof(opts) == \"function\") {\n    cb = opts;\n    opts = {};\n  }\n\n  //Common.printOut(conf.PREFIX_MSG_WARNING + chalk.bold.yellow('Warning gracefulReload will be soon deprecated'));\n  //Common.printOut(conf.PREFIX_MSG_WARNING + chalk.bold.yellow('Use http://pm2.keymetrics.io/docs/usage/signals-clean-restart/ instead'));\n\n  if (Common.isConfigFile(process_name))\n    that._startJson(process_name, commander, 'softReloadProcessId');\n  else {\n    if (opts && !opts.updateEnv)\n      Common.printOut(IMMUTABLE_MSG);\n    that._operate('softReloadProcessId', process_name, opts, cb);\n  }\n};\n\n/**\n * Reload an application\n *\n * @param {String} process_name Application Name or All\n * @param {Object} opts         Options\n * @param {Function} cb         Callback\n */\nAPI.prototype.reload = function(process_name, opts, cb) {\n  var that = this;\n\n  if (typeof(opts) == \"function\") {\n    cb = opts;\n    opts = {};\n  }\n\n  if (Common.isConfigFile(process_name))\n    that._startJson(process_name, opts, 'reloadProcessId');\n  else {\n    if (opts && !opts.updateEnv)\n      Common.printOut(IMMUTABLE_MSG);\n    that._operate('reloadProcessId', process_name, opts, cb);\n  }\n};\n\n/**\n * Restart process\n *\n * @param {String} cmd   Application Name / Process id / JSON application file / 'all'\n * @param {Object} opts  Extra options to be updated\n * @param {Function} cb  Callback\n */\nAPI.prototype.restart = function(cmd, opts, cb) {\n  if (typeof(opts) == \"function\") {\n    cb = opts;\n    opts = {};\n  }\n  var that = this;\n\n  if (typeof(cmd) === 'number')\n    cmd = cmd.toString();\n\n  if (cmd == \"-\") {\n    // Restart from PIPED JSON\n    process.stdin.resume();\n    process.stdin.setEncoding('utf8');\n    process.stdin.on('data', function (param) {\n      process.stdin.pause();\n      that.actionFromJson('restartProcessId', param, opts, 'pipe', cb);\n    });\n  }\n  else if (Common.isConfigFile(cmd) || typeof(cmd) === 'object')\n    that._startJson(cmd, opts, 'restartProcessId', cb);\n  else {\n    if (opts && !opts.updateEnv)\n      Common.printOut(IMMUTABLE_MSG);\n    that._operate('restartProcessId', cmd, opts, cb);\n  }\n};\n\n/**\n * Delete process\n *\n * @param {String} process_name Application Name / Process id / Application file / 'all'\n * @param {Function} cb Callback\n */\nAPI.prototype.delete = function(process_name, jsonVia, cb) {\n  var that = this;\n\n  if (typeof(jsonVia) === \"function\") {\n    cb = jsonVia;\n    jsonVia = null;\n  }\n  if (typeof(process_name) === \"number\") {\n    process_name = process_name.toString();\n  }\n\n  if (jsonVia == 'pipe')\n    return that.actionFromJson('deleteProcessId', process_name, commander, 'pipe', cb);\n  if (Common.isConfigFile(process_name))\n    return that.actionFromJson('deleteProcessId', process_name, commander, 'file', cb);\n  else\n    that._operate('deleteProcessId', process_name, cb);\n};\n\n/**\n * Stop process\n *\n * @param {String} process_name Application Name / Process id / Application file / 'all'\n * @param {Function} cb Callback\n */\nAPI.prototype.stop = function(process_name, cb) {\n  var that = this;\n\n  if (typeof(process_name) === 'number')\n    process_name = process_name.toString();\n\n  if (process_name == \"-\") {\n    process.stdin.resume();\n    process.stdin.setEncoding('utf8');\n    process.stdin.on('data', function (param) {\n      process.stdin.pause();\n      that.actionFromJson('stopProcessId', param, commander, 'pipe', cb);\n    });\n  }\n  else if (Common.isConfigFile(process_name))\n    that.actionFromJson('stopProcessId', process_name, commander, 'file', cb);\n  else\n    that._operate('stopProcessId', process_name, cb);\n};\n\n/**\n * Get list of all processes managed\n *\n * @param {Function} cb Callback\n */\nAPI.prototype.list = function(opts, cb) {\n  var that = this;\n\n  if (typeof(opts) == 'function') {\n    cb = opts;\n    opts = null;\n  }\n\n  that.Client.executeRemote('getMonitorData', {}, function(err, list) {\n    if (err) {\n      Common.printError(err);\n      return cb ? cb(Common.retErr(err)) : that.exitCli(conf.ERROR_EXIT);\n    }\n\n    if (opts && opts.rawArgs && opts.rawArgs.indexOf('--watch') > -1) {\n      var moment = require('moment');\n      function show() {\n        process.stdout.write('\\033[2J');\n        process.stdout.write('\\033[0f');\n        console.log('Last refresh: ', moment().format('LTS'));\n        that.Client.executeRemote('getMonitorData', {}, function(err, list) {\n          UX.dispAsTable(list, null);\n        });\n      }\n\n      show();\n      setInterval(show, 900);\n      return false;\n    }\n\n    return cb ? cb(null, list) : that.speedList();\n  });\n};\n\n/**\n * Kill Daemon\n *\n * @param {Function} cb Callback\n */\nAPI.prototype.killDaemon = API.prototype.kill = function(cb) {\n  var that = this;\n\n  var semver = require('semver');\n  Common.printOut(conf.PREFIX_MSG + 'Stopping PM2...');\n\n  that.Client.executeRemote('notifyKillPM2', {}, function() {});\n\n  that.getVersion(function(err, data) {\n    if (!err && semver.lt(data, '1.1.0')) {\n      // Disable action command output if upgrading from < 1.1.0 PM2\n      // This is in order to avoid duplicated output\n      process.env.PM2_SILENT = 'true';\n      console.log(conf.PREFIX_MSG + 'Killing processes...');\n    }\n\n    that.killAllModules(function() {\n      that._operate('deleteProcessId', 'all', function(err, list) {\n        Common.printOut(conf.PREFIX_MSG + 'All processes have been stopped and deleted');\n        process.env.PM2_SILENT = 'false';\n\n        that.killInteract(function(err, data) {\n          that.Client.killDaemon(function(err, res) {\n            if (err) Common.printError(err);\n            Common.printOut(conf.PREFIX_MSG + 'PM2 stopped');\n            return cb ? cb(err, res) : that.exitCli(conf.SUCCESS_EXIT);\n          });\n        });\n      });\n    });\n\n  });\n};\n\n/////////////////////\n// Private methods //\n/////////////////////\n\n/**\n * Method to START / RESTART a script\n *\n * @private\n * @param {string} script script name (will be resolved according to location)\n */\nAPI.prototype._startScript = function(script, opts, cb) {\n  if (typeof opts == \"function\") {\n    cb = opts;\n    opts = {};\n  }\n  var that = this;\n\n  var app_conf = Config.transCMDToConf(opts);\n  var appConf = {};\n\n  if (!!opts.executeCommand)\n    app_conf.exec_mode = 'fork';\n  else if (opts.instances !== undefined)\n    app_conf.exec_mode = 'cluster';\n  else\n    app_conf.exec_mode = 'fork';\n\n  if (typeof app_conf.name == 'function'){\n    delete app_conf.name;\n  }\n\n  delete app_conf.args;\n\n  var argsIndex;\n\n  if (opts.rawArgs && (argsIndex = opts.rawArgs.indexOf('--')) >= 0) {\n    app_conf.args = opts.rawArgs.slice(argsIndex + 1);\n  }\n  else if (opts.scriptArgs) {\n    app_conf.args = opts.scriptArgs;\n  }\n\n  app_conf.script = script;\n\n  if ((appConf = Common.verifyConfs(app_conf)) instanceof Error)\n    return cb ? cb(Common.retErr(appConf)) : that.exitCli(conf.ERROR_EXIT);\n\n  app_conf = appConf[0];\n\n  /**\n   * If -w option, write configuration to configuration.json file\n   */\n  if (appConf.write) {\n    var dst_path = path.join(process.env.PWD || process.cwd(), app_conf.name + '-pm2.json');\n    Common.printOut(conf.PREFIX_MSG + 'Writing configuration to', chalk.blue(dst_path));\n    // pretty JSON\n    try {\n      fs.writeFileSync(dst_path, JSON.stringify(app_conf, null, 2));\n    } catch (e) {\n      console.error(e.stack || e);\n    }\n  }\n\n  /**\n   * If start <app_name> start/restart application\n   */\n  function restartExistingProcessName(cb) {\n    if (!isNaN(script) ||\n        (typeof script === 'string' && script.indexOf('/') != -1) ||\n        (typeof script === 'string' && path.extname(script) !== ''))\n      return cb(null);\n\n    if (script !== 'all') {\n      that.Client.getProcessIdByName(script, function(err, ids) {\n        if (err && cb) return cb(err);\n        if (ids.length > 0) {\n          that._operate('restartProcessId', script, opts, function(err, list) {\n            if (err) return cb(err);\n            Common.printOut(conf.PREFIX_MSG + 'Process successfully started');\n            return cb(true, list);\n          });\n        }\n        else return cb(null);\n      });\n    }\n    else {\n      that._operate('restartProcessId', 'all', function(err, list) {\n        if (err) return cb(err);\n        Common.printOut(conf.PREFIX_MSG + 'Process successfully started');\n        return cb(true, list);\n      });\n    }\n  }\n\n  function restartExistingProcessId(cb) {\n    if (isNaN(script)) return cb(null);\n\n    that._operate('restartProcessId', script, opts, function(err, list) {\n      if (err) return cb(err);\n      Common.printOut(conf.PREFIX_MSG + 'Process successfully started');\n      return cb(true, list);\n    });\n  }\n\n  /**\n   * Restart a process with the same full path\n   * Or start it\n   */\n  function restartExistingProcessPath(cb) {\n    that.Client.executeRemote('getMonitorData', {}, function(err, procs) {\n      if (err) return cb ? cb(new Error(err)) : that.exitCli(conf.ERROR_EXIT);\n\n      var full_path = path.resolve(that.cwd, script);\n      var managed_script = null;\n\n      procs.forEach(function(proc) {\n        if (proc.pm2_env.pm_exec_path == full_path &&\n            proc.pm2_env.name == app_conf.name)\n          managed_script = proc;\n      });\n\n      if (managed_script &&\n          (managed_script.pm2_env.status == conf.STOPPED_STATUS ||\n           managed_script.pm2_env.status == conf.STOPPING_STATUS ||\n           managed_script.pm2_env.status == conf.ERRORED_STATUS)) {\n        // Restart process if stopped\n        var app_name = managed_script.pm2_env.name;\n\n        that._operate('restartProcessId', app_name, opts, function(err, list) {\n          if (err) return cb ? cb(new Error(err)) : that.exitCli(conf.ERROR_EXIT);\n          Common.printOut(conf.PREFIX_MSG + 'Process successfully started');\n          return cb(true, list);\n        });\n        return false;\n      }\n      else if (managed_script && !opts.force) {\n        Common.printError(conf.PREFIX_MSG_ERR + 'Script already launched, add -f option to force re-execution');\n        return cb(new Error('Script already launched'));\n      }\n\n      var resolved_paths = null;\n\n      try {\n        resolved_paths = Common.resolveAppAttributes({\n          cwd      : that.cwd,\n          pm2_home : that.pm2_home\n        }, app_conf);\n      } catch(e) {\n        Common.printError(e);\n        return cb(Common.retErr(e));\n      }\n\n      Common.printOut(conf.PREFIX_MSG + 'Starting %s in %s (%d instance' + (resolved_paths.instances > 1 ? 's' : '') + ')',\n                      resolved_paths.pm_exec_path, resolved_paths.exec_mode, resolved_paths.instances);\n\n      if (!resolved_paths.env) resolved_paths.env = {};\n\n      // Set PM2 HOME in case of child process using PM2 API\n      resolved_paths.env['PM2_HOME'] = that.pm2_home;\n\n      var additional_env = Modularizer.getAdditionalConf(resolved_paths.name);\n      util._extend(resolved_paths.env, additional_env);\n\n      // Is KM linked?\n      resolved_paths.km_link = that.gl_is_km_linked;\n\n      that.Client.executeRemote('prepare', resolved_paths, function(err, data) {\n        if (err) {\n          Common.printError(conf.PREFIX_MSG_ERR + 'Error while launching application', err.stack || err);\n          return cb(Common.retErr(err));\n        }\n\n        Common.printOut(conf.PREFIX_MSG + 'Done.');\n        return cb(true, data);\n      });\n      return false;\n    });\n  }\n\n  async.series([\n    restartExistingProcessName,\n    restartExistingProcessId,\n    restartExistingProcessPath\n  ], function(err, data) {\n\n    if (err instanceof Error)\n      return cb ? cb(err) : that.exitCli(conf.ERROR_EXIT);\n\n    var ret = {};\n    data.forEach(function(_dt) {\n      if (_dt !== undefined)\n        ret = _dt;\n    });\n\n    return cb ? cb(null, ret) : that.speedList();\n  });\n};\n\n/**\n * Method to start/restart/reload processes from a JSON file\n * It will start app not started\n * Can receive only option to skip applications\n *\n * @private\n */\nAPI.prototype._startJson = function(file, opts, action, pipe, cb) {\n  var config     = {};\n  var appConf    = {};\n  var deployConf = {};\n  var apps_info  = [];\n  var that = this;\n\n  if (typeof(cb) === 'undefined' && typeof(pipe) === 'function')\n    cb = pipe;\n\n  if (typeof(file) === 'object')\n    config = file;\n  else if (pipe == 'pipe')\n    config = Common.parseConfig(file, 'pipe');\n  else {\n    var data = null;\n\n    var file_path = path.isAbsolute(file) ? file : path.join(that.cwd, file);\n\n    debug('Resolved filepath %s', file_path);\n\n    try {\n      data = fs.readFileSync(file_path);\n    } catch(e) {\n      Common.printError(conf.PREFIX_MSG_ERR + 'File ' + file +' not found');\n      return cb ? cb(Common.retErr(e)) : that.exitCli(conf.ERROR_EXIT);\n    }\n\n    try {\n      config = Common.parseConfig(data, file);\n    } catch(e) {\n      Common.printError(conf.PREFIX_MSG_ERR + 'File ' + file + ' malformated');\n      console.error(e);\n      return cb ? cb(Common.retErr(e)) : that.exitCli(conf.ERROR_EXIT);\n    }\n  }\n\n  if (config.deploy)\n    deployConf = config.deploy;\n\n  if (config.apps)\n    appConf = config.apps;\n  else\n    appConf = config;\n\n  if (!Array.isArray(appConf))\n    appConf = [appConf]; //convert to array\n\n  if ((appConf = Common.verifyConfs(appConf)) instanceof Error)\n    return cb ? cb(appConf) : that.exitCli(conf.ERROR_EXIT);\n\n  process.env.PM2_JSON_PROCESSING = true;\n\n  // Get App list\n  var apps_name = [];\n  var proc_list = {};\n\n  appConf.forEach(function(app) {\n    if (opts.only && opts.only != app.name)\n      return false;\n    if (!app.watch && opts.watch && opts.watch === true)\n      app.watch = true;\n    if (!app.ignore_watch && opts.ignore_watch)\n      app.ignore_watch = opts.ignore_watch;\n    if (opts.instances && typeof(opts.instances) === 'number')\n      app.instances = opts.instances;\n    if (app.append_env_to_name && opts.env) {\n      app.name += ('-' + opts.env);\n    }\n    apps_name.push(app.name);\n  });\n\n  that.Client.executeRemote('getMonitorData', {}, function(err, raw_proc_list) {\n    if (err) {\n      Common.printError(err);\n      return cb ? cb(Common.retErr(err)) : that.exitCli(conf.ERROR_EXIT);\n    }\n\n    /**\n     * Uniquify in memory process list\n     */\n    raw_proc_list.forEach(function(proc) {\n      proc_list[proc.name] = proc;\n    });\n\n    /**\n     * Auto detect application already started\n     * and act on them depending on action\n     */\n    async.eachLimit(Object.keys(proc_list), conf.CONCURRENT_ACTIONS, function(proc_name, next) {\n      // Skip app name (--only option)\n      if (apps_name.indexOf(proc_name) == -1)\n        return next();\n\n      if (!(action == 'reloadProcessId' ||\n            action == 'softReloadProcessId' ||\n            action == 'restartProcessId'))\n        throw new Error('Wrong action called');\n\n\n      // Get `env` from appConf by name\n      async.filter(appConf, function(app, callback){\n        callback(app.name == proc_name);\n      }, function(apps){\n        var envs = apps.map(function(app){\n          // Binds env_diff to env and returns it.\n          return Common.mergeEnvironmentVariables(app, opts.env, deployConf);\n        });\n\n        // Assigns own enumerable properties of all\n        // Notice: if people use the same name in different apps,\n        //         duplicated envs will be overrode by the last one\n        var env = envs.reduce(function(e1, e2){\n          return util._extend(e1, e2);\n        });\n\n        // When we are processing JSON, allow to keep the new env by default\n        env.updateEnv = true;\n\n        // Pass `env` option\n        that._operate(action, proc_name, env, function(err, ret) {\n          if (err) Common.printError(err);\n\n          // For return\n          apps_info = apps_info.concat(ret);\n\n          that.Client.notifyGod(action, proc_name);\n          // And Remove from array to spy\n          apps_name.splice(apps_name.indexOf(proc_name), 1);\n          return next();\n        });\n      });\n\n    }, function(err) {\n      if (err) return cb ? cb(Common.retErr(err)) : that.exitCli(conf.ERROR_EXIT);\n      if (apps_name.length > 0 && action != 'start')\n        Common.printOut(conf.PREFIX_MSG_WARNING + 'Applications %s not running, starting...', apps_name.join(', '));\n      // Start missing apps\n      return startApps(apps_name, function(err, apps) {\n        apps_info = apps_info.concat(apps);\n        return cb ? cb(err, apps_info) : that.speedList(err ? 1 : 0);\n      });\n    });\n    return false;\n  });\n\n  function startApps(app_name_to_start, cb) {\n    var apps_to_start = [];\n    var apps_started = [];\n\n    appConf.forEach(function(app, i) {\n      if (app_name_to_start.indexOf(app.name) != -1) {\n        apps_to_start.push(appConf[i]);\n      }\n    });\n\n    async.eachLimit(apps_to_start, conf.CONCURRENT_ACTIONS, function(app, next) {\n      if (opts.cwd)\n        app.cwd = opts.cwd;\n      if (opts.force_name)\n        app.name = opts.force_name;\n      if (opts.started_as_module)\n        app.pmx_module = true;\n\n      var resolved_paths = null;\n\n      // hardcode script name to use `serve` feature inside a process file\n      if (app.script === 'serve') {\n        app.script = path.resolve(__dirname, 'API', 'Serve.js')\n      }\n\n      try {\n        resolved_paths = Common.resolveAppAttributes({\n          cwd      : that.cwd,\n          pm2_home : that.pm2_home\n        }, app);\n      } catch (e) {\n        Common.printError(e);\n        return cb ? cb(e) : that.exitCli(conf.ERROR_EXIT);\n      }\n\n      if (!resolved_paths.env) resolved_paths.env = {};\n\n      // Set PM2 HOME in case of child process using PM2 API\n      resolved_paths.env['PM2_HOME'] = that.pm2_home;\n\n      var additional_env = Modularizer.getAdditionalConf(resolved_paths.name);\n      util._extend(resolved_paths.env, additional_env);\n\n      resolved_paths.env = Common.mergeEnvironmentVariables(resolved_paths, opts.env, deployConf);\n\n      delete resolved_paths.env.current_conf;\n\n      // Is KM linked?\n      resolved_paths.km_link = that.gl_is_km_linked;\n\n      that.Client.executeRemote('prepare', resolved_paths, function(err, data) {\n        if (err) {\n          Common.printError(conf.PREFIX_MSG + 'Process failed to launch', err);\n          return next();\n        }\n\n        Common.printOut(conf.PREFIX_MSG + 'App [%s] launched (%d instances)', data[0].pm2_env.name, data.length);\n        apps_started = apps_started.concat(data);\n        next();\n      });\n\n    }, function(err) {\n      return cb ? cb(err || null, apps_started) : that.speedList();\n    });\n    return false;\n  }\n};\n\n/**\n * Apply a RPC method on the json file\n * @private\n * @method actionFromJson\n * @param {string} action RPC Method\n * @param {object} options\n * @param {string|object} file file\n * @param {string} jsonVia action type (=only 'pipe' ?)\n * @param {Function}\n */\nAPI.prototype.actionFromJson = function(action, file, opts, jsonVia, cb) {\n  var appConf = {};\n  var ret_processes = [];\n  var that = this;\n\n  //accept programmatic calls\n  if (typeof file == 'object') {\n    cb = typeof jsonVia == 'function' ? jsonVia : cb;\n    appConf = file;\n  }\n  else if (jsonVia == 'file') {\n    var data = null;\n\n    try {\n      data = fs.readFileSync(file);\n    } catch(e) {\n      Common.printError(conf.PREFIX_MSG_ERR + 'File ' + file +' not found');\n      return cb ? cb(Common.retErr(e)) : that.exitCli(conf.ERROR_EXIT);\n    }\n\n    try {\n      appConf = Common.parseConfig(data, file);\n    } catch(e) {\n      Common.printError(conf.PREFIX_MSG_ERR + 'File ' + file + ' malformated');\n      console.error(e);\n      return cb ? cb(Common.retErr(e)) : that.exitCli(conf.ERROR_EXIT);\n    }\n  } else if (jsonVia == 'pipe') {\n    appConf = Common.parseConfig(file, 'pipe');\n  } else {\n    Common.printError('Bad call to actionFromJson, jsonVia should be one of file, pipe');\n    return that.exitCli(conf.ERROR_EXIT);\n  }\n\n  // Backward compatibility\n  if (appConf.apps)\n    appConf = appConf.apps;\n\n  if (!Array.isArray(appConf))\n    appConf = [appConf];\n\n  if ((appConf = Common.verifyConfs(appConf)) instanceof Error)\n    return cb ? cb(appConf) : that.exitCli(conf.ERROR_EXIT);\n\n  async.eachLimit(appConf, conf.CONCURRENT_ACTIONS, function(proc, next1) {\n    var name = '';\n    var new_env;\n\n    if (!proc.name)\n      name = path.basename(proc.script);\n    else\n      name = proc.name;\n\n    if (opts.only && opts.only != name)\n      return process.nextTick(next1);\n\n    if (opts && opts.env)\n      new_env = Common.mergeEnvironmentVariables(proc, opts.env);\n    else\n      new_env = Common.mergeEnvironmentVariables(proc);\n\n    that.Client.getProcessIdByName(name, function(err, ids) {\n      if (err) {\n        Common.printError(err);\n        return next1();\n      }\n      if (!ids) return next1();\n\n      async.eachLimit(ids, conf.CONCURRENT_ACTIONS, function(id, next2) {\n        var opts = {};\n\n        //stopProcessId could accept options to?\n        if (action == 'restartProcessId') {\n          opts = {id : id, env : new_env};\n        } else {\n          opts = id;\n        }\n\n        that.Client.executeRemote(action, opts, function(err, res) {\n          ret_processes.push(res);\n          if (err) {\n            Common.printError(err);\n            return next2();\n          }\n\n          if (action == 'restartProcessId') {\n            that.Client.notifyGod('restart', id);\n          } else if (action == 'deleteProcessId') {\n            that.Client.notifyGod('delete', id);\n          } else if (action == 'stopProcessId') {\n            that.Client.notifyGod('stop', id);\n          }\n\n          Common.printOut(conf.PREFIX_MSG + '[%s](%d) \\u2713', name, id);\n          return next2();\n        });\n      }, function(err) {\n        return next1(null, ret_processes);\n      });\n    });\n  }, function(err) {\n    if (cb) return cb(null, ret_processes);\n    else return that.speedList();\n  });\n};\n\n\n/**\n * Main function to operate with PM2 daemon\n *\n * @param {String} action_name  Name of action (restartProcessId, deleteProcessId, stopProcessId)\n * @param {String} process_name can be 'all', a id integer or process name\n * @param {Object} envs         object with CLI options / environment\n */\nAPI.prototype._operate = function(action_name, process_name, envs, cb) {\n  var that = this;\n  var update_env = false;\n  var ret = [];\n\n  // Make sure all options exist\n\n  if (!envs)\n    envs = {};\n\n  if (typeof(envs) == 'function'){\n    cb = envs;\n    envs = {};\n  }\n\n  // Set via env.update (JSON processing)\n  if (envs.updateEnv === true)\n    update_env = true;\n\n  if (!process.env.PM2_JSON_PROCESSING || envs.commands) {\n    envs = that._handleAttributeUpdate(envs);\n  }\n\n  /**\n   * Set current updated configuration if not passed\n   */\n  if (!envs.current_conf) {\n    var _conf = fclone(envs);\n    envs = {\n      current_conf : _conf\n    }\n\n    // Is KM linked?\n    envs.current_conf.km_link = that.gl_is_km_linked;\n  }\n\n  /**\n   * Operate action on specific process id\n   */\n  function processIds(ids, cb) {\n    Common.printOut(conf.PREFIX_MSG + 'Applying action %s on app [%s](ids: %s)', action_name, process_name, ids);\n\n    var concurrent_actions = conf.CONCURRENT_ACTIONS;\n    if (action_name == 'deleteProcessId')\n      concurrent_actions = 10;\n\n    async.eachLimit(ids, concurrent_actions, function(id, next) {\n      var opts;\n\n      // These functions need extra param to be passed\n      if (action_name == 'restartProcessId' ||\n          action_name == 'reloadProcessId' ||\n          action_name == 'softReloadProcessId') {\n        var new_env = {};\n\n        if (update_env === true) {\n          if (conf.PM2_PROGRAMMATIC == true)\n            new_env = Common.safeExtend({}, process.env);\n          else\n            new_env = util._extend({}, process.env);\n\n          Object.keys(envs).forEach(function(k) {\n            new_env[k] = envs[k];\n          });\n        }\n        else {\n          new_env = envs;\n        }\n\n        opts = {\n          id  : id,\n          env : new_env\n        };\n      }\n      else {\n        opts = id;\n      }\n\n      that.Client.executeRemote(action_name, opts, function(err, res) {\n        if (err) {\n          Common.printError(conf.PREFIX_MSG_ERR + 'Process %s not found', id);\n          return next('Process not found');\n        }\n\n        if (action_name == 'restartProcessId') {\n          that.Client.notifyGod('restart', id);\n        } else if (action_name == 'deleteProcessId') {\n          that.Client.notifyGod('delete', id);\n        } else if (action_name == 'stopProcessId') {\n          that.Client.notifyGod('stop', id);\n        } else if (action_name == 'reloadProcessId') {\n          that.Client.notifyGod('reload', id);\n        } else if (action_name == 'softReloadProcessId') {\n          that.Client.notifyGod('graceful reload', id);\n        }\n\n        if (!Array.isArray(res))\n          res = [res];\n\n        // Filter return\n        res.forEach(function(proc) {\n          Common.printOut(conf.PREFIX_MSG + '[%s](%d) \\u2713', proc.pm2_env ? proc.pm2_env.name : process_name, id);\n\n          if (!proc.pm2_env) return false;\n\n          ret.push({\n            name         : proc.pm2_env.name,\n            pm_id        : proc.pm2_env.pm_id,\n            status       : proc.pm2_env.status,\n            restart_time : proc.pm2_env.restart_time,\n            pm2_env : {\n              name         : proc.pm2_env.name,\n              pm_id        : proc.pm2_env.pm_id,\n              status       : proc.pm2_env.status,\n              restart_time : proc.pm2_env.restart_time,\n              env          : proc.pm2_env.env\n            }\n          });\n        });\n\n        return next();\n      });\n    }, function(err) {\n      if (err) return cb ? cb(Common.retErr(err)) : that.exitCli(conf.ERROR_EXIT);\n      return cb ? cb(null, ret) : that.speedList();\n    });\n  }\n\n  if (process_name == 'all') {\n    that.Client.getAllProcessId(function(err, ids) {\n      if (err) {\n        Common.printError(err);\n        return cb ? cb(Common.retErr(err)) : that.exitCli(conf.ERROR_EXIT);\n      }\n      if (!ids || ids.length === 0) {\n        Common.printError(conf.PREFIX_MSG_WARNING + 'No process found');\n        return cb ? cb(new Error('process name not found')) : that.exitCli(conf.ERROR_EXIT);\n      }\n\n      return processIds(ids, cb);\n    });\n  }\n  // operate using regex\n  else if (isNaN(process_name) && process_name[0] === '/' && process_name[process_name.length - 1] === '/') {\n    var regex = new RegExp(process_name.replace(/\\//g, ''));\n\n    that.Client.executeRemote('getMonitorData', {}, function(err, list) {\n      if (err) {\n        Common.printError('Error retrieving process list: ' + err);\n        return cb(err);\n      }\n      var found_proc = [];\n      list.forEach(function(proc) {\n        if (regex.test(proc.pm2_env.name)) {\n          found_proc.push(proc.pm_id);\n        }\n      });\n\n      if (found_proc.length === 0) {\n        Common.printError(conf.PREFIX_MSG_WARNING + 'No process found');\n        return cb ? cb(new Error('process name not found')) : that.exitCli(conf.ERROR_EXIT);\n      }\n\n      return processIds(found_proc, cb);\n    });\n  }\n  else if (isNaN(process_name)) {\n    /**\n     * We can not stop or delete a module but we can restart it\n     * to refresh configuration variable\n     */\n    var allow_module_restart = action_name == 'restartProcessId' ? true : false;\n\n    that.Client.getProcessIdByName(process_name, allow_module_restart, function(err, ids) {\n      if (err) {\n        Common.printError(err);\n        return cb ? cb(Common.retErr(err)) : that.exitCli(conf.ERROR_EXIT);\n      }\n      if (!ids || ids.length === 0) {\n        Common.printError(conf.PREFIX_MSG_ERR + 'Process %s not found', process_name);\n        return cb ? cb(new Error('process name not found')) : that.exitCli(conf.ERROR_EXIT);\n      }\n\n      /**\n       * Determine if the process to restart is a module\n       * if yes load configuration variables and merge with the current environment\n       */\n      var additional_env = Modularizer.getAdditionalConf(process_name);\n      util._extend(envs, additional_env);\n\n      return processIds(ids, cb);\n    });\n  } else {\n    // Check if application name as number is an app name\n    that.Client.getProcessIdByName(process_name, function(err, ids) {\n      if (ids.length > 0)\n        return processIds(ids, cb);\n      // Else operate on pm id\n      return processIds([process_name], cb);\n    });\n  }\n};\n\n/**\n * Converts CamelCase Commander.js arguments\n * to Underscore\n * (nodeArgs -> node_args)\n */\nAPI.prototype._handleAttributeUpdate = function(opts) {\n  var conf = Config.transCMDToConf(opts);\n  var that = this;\n\n  if (typeof(conf.name) != 'string')\n    delete conf.name;\n\n  var argsIndex = 0;\n  if (opts.rawArgs && (argsIndex = opts.rawArgs.indexOf('--')) >= 0) {\n    conf.args = opts.rawArgs.slice(argsIndex + 1);\n  }\n\n  var appConf = Common.verifyConfs(conf)[0];\n\n  if (appConf instanceof Error) {\n    Common.printError('Error while transforming CamelCase args to underscore');\n    return appConf;\n  }\n\n  if (argsIndex == -1)\n    delete appConf.args;\n  if (appConf.name == 'undefined')\n    delete appConf.name;\n\n  delete appConf.exec_mode;\n\n  if(util.isArray(appConf.watch) && appConf.watch.length === 0) {\n    if(!~opts.rawArgs.indexOf('--watch'))\n      delete appConf.watch\n  }\n\n  return appConf;\n};\n\nAPI.prototype.getProcessIdByName = function(name, cb) {\n  var that = this;\n\n  this.Client.getProcessIdByName(name, function(err, id) {\n    if (err) {\n      Common.printError(err);\n      return cb ? cb(Common.retErr(err)) : that.exitCli(conf.ERROR_EXIT);\n    }\n    console.log(id);\n    return cb ? cb(null, id) : that.exitCli(conf.SUCCESS_EXIT);\n  });\n};\n\n/**\n * Description\n * @method jlist\n * @param {} debug\n * @return\n */\nAPI.prototype.jlist = function(debug) {\n  var that = this;\n\n  that.Client.executeRemote('getMonitorData', {}, function(err, list) {\n    if (err) {\n      Common.printError(err);\n      that.exitCli(conf.ERROR_EXIT);\n    }\n\n    if (debug) {\n      process.stdout.write(util.inspect(list, false, null, false));\n    }\n    else {\n      process.stdout.write(JSON.stringify(list));\n    }\n\n    that.exitCli(conf.SUCCESS_EXIT);\n\n  });\n};\n\nvar gl_retry = 0;\n\n/**\n * Description\n * @method speedList\n * @return\n */\nAPI.prototype.speedList = function(code) {\n  var that = this;\n\n  // Do nothing if PM2 called programmatically and not called from CLI (also in exitCli)\n  if (conf.PM2_PROGRAMMATIC && process.env.PM2_USAGE != 'CLI') return false;\n\n  that.Client.executeRemote('getMonitorData', {}, function(err, list) {\n    if (err) {\n      if (gl_retry == 0) {\n        gl_retry += 1;\n        return setTimeout(that.speedList.bind(that), 1400);\n      }\n      console.error('Error retrieving process list: %s.\\nA process seems to be on infinite loop, retry in 5 seconds',err);\n      return that.exitCli(conf.ERROR_EXIT);\n    }\n    if (process.stdout.isTTY === false) {\n      UX.miniDisplay(list);\n    }\n    else if (commander.miniList && !commander.silent)\n      UX.miniDisplay(list);\n    else if (!commander.silent) {\n      if (that.gl_interact_infos) {\n        Common.printOut(chalk.green.bold('●') + ' Agent Online | Dashboard Access: ' + chalk.bold('https://app.keymetrics.io/#/r/%s') + ' | Server name: %s', that.gl_interact_infos.public_key, that.gl_interact_infos.machine_name);\n      }\n      UX.dispAsTable(list, that.gl_interact_infos);\n      Common.printOut(chalk.white.italic(' Use `pm2 show <id|name>` to get more details about an app'));\n    }\n\n    if (that.Client.daemon_mode == false) {\n      Common.printOut('[--no-daemon] Continue to stream logs');\n      Common.printOut('[--no-daemon] Exit on target PM2 exit pid=' + fs.readFileSync(conf.PM2_PID_FILE_PATH).toString());\n      global._auto_exit = true;\n      return that.streamLogs('all', 0, false, 'HH:mm:ss', false);\n    }\n    else if (commander.attach === true) {\n      return that.streamLogs('all', 0, false, null, false);\n    }\n    else {\n      return that.exitCli(code ? code : conf.SUCCESS_EXIT);\n    }\n  });\n}\n\n/**\n * Scale up/down a process\n * @method scale\n */\nAPI.prototype.scale = function(app_name, number, cb) {\n  var that = this;\n\n  function addProcs(proc, value, cb) {\n    (function ex(proc, number) {\n      if (number-- === 0) return cb();\n      Common.printOut(conf.PREFIX_MSG + 'Scaling up application');\n      that.Client.executeRemote('duplicateProcessId', proc.pm2_env.pm_id, ex.bind(this, proc, number));\n    })(proc, number);\n  }\n\n  function rmProcs(procs, value, cb) {\n    var i = 0;\n\n    (function ex(procs, number) {\n      if (number++ === 0) return cb();\n      that._operate('deleteProcessId', procs[i++].pm2_env.pm_id, ex.bind(this, procs, number));\n    })(procs, number);\n  }\n\n  function end() {\n    return cb ? cb(null, {success:true}) : that.speedList();\n  }\n\n  this.Client.getProcessByName(app_name, function(err, procs) {\n    if (err) {\n      Common.printError(err);\n      return cb ? cb(Common.retErr(err)) : that.exitCli(conf.ERROR_EXIT);\n    }\n\n    if (!procs || procs.length === 0) {\n      Common.printError(conf.PREFIX_MSG_ERR + 'Application %s not found', app_name);\n      return cb ? cb(new Error('App not found')) : that.exitCli(conf.ERROR_EXIT);\n    }\n\n    if (procs[0].pm2_env.exec_mode !== 'cluster_mode') {\n      Common.printError(conf.PREFIX_MSG_ERR + 'Application %s is not in cluster mode', app_name);\n      return cb ? cb(new Error('App not in cluster mode')) : that.exitCli(conf.ERROR_EXIT);\n    }\n\n    var proc_number = procs.length;\n\n    if (typeof(number) === 'string' && number.indexOf('+') >= 0) {\n      number = parseInt(number, 10);\n      return addProcs(procs[0], number, end);\n    }\n    else if (typeof(number) === 'string' && number.indexOf('-') >= 0) {\n      number = parseInt(number, 10);\n      return rmProcs(procs[0], number, end);\n    }\n    else {\n      number = parseInt(number, 10);\n      number = number - proc_number;\n\n      if (number < 0)\n        return rmProcs(procs, number, end);\n      else if (number > 0)\n        return addProcs(procs[0], number, end);\n      else {\n        Common.printError(conf.PREFIX_MSG_ERR + 'Nothing to do');\n        return cb ? cb(new Error('Same process number')) : that.exitCli(conf.ERROR_EXIT);\n      }\n    }\n  });\n};\n\n/**\n * Description\n * @method describeProcess\n * @param {} pm2_id\n * @return\n */\nAPI.prototype.describe = function(pm2_id, cb) {\n  var that = this;\n\n  var found_proc = [];\n\n  that.Client.executeRemote('getMonitorData', {}, function(err, list) {\n    if (err) {\n      Common.printError('Error retrieving process list: ' + err);\n      that.exitCli(conf.ERROR_EXIT);\n    }\n\n    list.forEach(function(proc) {\n      if ((!isNaN(pm2_id)    && proc.pm_id == pm2_id) ||\n          (typeof(pm2_id) === 'string' && proc.name  == pm2_id)) {\n        found_proc.push(proc);\n      }\n    });\n\n    if (found_proc.length === 0) {\n      Common.printError(conf.PREFIX_MSG_WARNING + '%s doesn\\'t exist', pm2_id);\n      return cb ? cb(null, []) : that.exitCli(conf.ERROR_EXIT);\n    }\n\n    if (!cb) {\n      found_proc.forEach(function(proc) {\n        UX.describeTable(proc);\n      });\n    }\n\n    return cb ? cb(null, found_proc) : that.exitCli(conf.SUCCESS_EXIT);\n  });\n};\n\n/**\n * API method to perform a deep update of PM2\n * @method deepUpdate\n */\nAPI.prototype.deepUpdate = function(cb) {\n  var that = this;\n\n  Common.printOut(conf.PREFIX_MSG + 'Updating PM2...');\n\n  var exec = require('shelljs').exec;\n  var child = exec(\"npm i -g pm2@latest; pm2 update\", {async : true});\n\n  child.stdout.on('end', function() {\n    Common.printOut(conf.PREFIX_MSG + 'PM2 successfully updated');\n    cb ? cb(null, {success:true}) : that.exitCli(conf.SUCCESS_EXIT);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/constants.js":"/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\n\nvar debug  = require('debug')('pm2:conf');\nvar p      = require('path');\nvar util   = require('util');\nvar chalk  = require('chalk');\nvar semver = require('semver');\n\n/**\n * Get PM2 path structure\n */\nvar path_structure = require('./paths.js')(process.env.OVER_HOME);\n\n/**\n * Constants variables used by PM2\n */\nvar csts = {\n  PREFIX_MSG              : chalk.green('[PM2] '),\n  PREFIX_MSG_ERR          : chalk.red('[PM2][ERROR] '),\n  PREFIX_MSG_MOD          : chalk.bold.green('[PM2][Module] '),\n  PREFIX_MSG_MOD_ERR      : chalk.red('[PM2][Module][ERROR] '),\n  PREFIX_MSG_WARNING      : chalk.yellow('[PM2][WARN] '),\n  PREFIX_MSG_SUCCESS      : chalk.cyan('[PM2] '),\n\n  TEMPLATE_FOLDER         : p.join(__dirname, 'lib/templates'),\n\n  APP_CONF_TPL            : 'ecosystem.tpl',\n  APP_CONF_TPL_SIMPLE     : 'ecosystem-simple.tpl',\n  SAMPLE_CONF_FILE        : 'sample-conf.js',\n  LOGROTATE_SCRIPT        : 'logrotate.d/pm2',\n\n  DOCKERFILE_NODEJS       : 'Dockerfiles/Dockerfile-nodejs.tpl',\n  DOCKERFILE_JAVA         : 'Dockerfiles/Dockerfile-java.tpl',\n  DOCKERFILE_RUBY         : 'Dockerfiles/Dockerfile-ruby.tpl',\n\n  SUCCESS_EXIT            : 0,\n  ERROR_EXIT              : 1,\n  CODE_UNCAUGHTEXCEPTION  : 1,\n\n  IS_WINDOWS              : (process.platform === 'win32' || process.platform === 'win64'),\n  ONLINE_STATUS           : 'online',\n  STOPPED_STATUS          : 'stopped',\n  STOPPING_STATUS         : 'stopping',\n  LAUNCHING_STATUS        : 'launching',\n  ERRORED_STATUS          : 'errored',\n  ONE_LAUNCH_STATUS       : 'one-launch-status',\n\n  CLUSTER_MODE_ID         : 'cluster_mode',\n  FORK_MODE_ID            : 'fork_mode',\n\n  KEYMETRICS_ROOT_URL     : process.env.KEYMETRICS_NODE || 'root.keymetrics.io',\n  KEYMETRICS_BANNER       : '../lib/keymetrics',\n  DEFAULT_MODULE_JSON     : 'package.json',\n\n  REMOTE_PORT_TCP         : isNaN(parseInt(process.env.KEYMETRICS_PUSH_PORT)) ? 80 : parseInt(process.env.KEYMETRICS_PUSH_PORT),\n  REMOTE_PORT             : 41624,\n  REMOTE_REVERSE_PORT     : isNaN(parseInt(process.env.KEYMETRICS_REVERSE_PORT)) ? 43554 : parseInt(process.env.KEYMETRICS_REVERSE_PORT),\n  REMOTE_HOST             : 's1.keymetrics.io',\n  SEND_INTERVAL           : 1000,\n  GRACEFUL_TIMEOUT        : parseInt(process.env.PM2_GRACEFUL_TIMEOUT) || 8000,\n  GRACEFUL_LISTEN_TIMEOUT : parseInt(process.env.PM2_GRACEFUL_LISTEN_TIMEOUT) || 3000,\n  LOGS_BUFFER             : 10,\n  CONTEXT_ON_ERROR        : 2,\n  AGGREGATION_DURATION    : process.env.PM2_DEBUG || process.env.NODE_ENV === 'test' || process.env.NODE_ENV === 'development' ? 3000 : 5 * 60000,\n  TRACE_FLUSH_INTERVAL    : process.env.PM2_DEBUG || process.env.NODE_ENV === 'local_test' ? 1000 : 60000,\n\n  // Concurrent actions when doing start/restart/reload\n  CONCURRENT_ACTIONS      : (function() {\n    var concurrent_actions = parseInt(process.env.PM2_CONCURRENT_ACTIONS) || 1;\n    if (semver.satisfies(process.versions.node, '>= 4.0.0'))\n      concurrent_actions = 2;\n    debug('Using %d parallelism (CONCURRENT_ACTIONS)', concurrent_actions);\n    return concurrent_actions;\n  })(),\n\n  DEBUG                   : process.env.PM2_DEBUG || false,\n  WEB_IPADDR              : process.env.PM2_API_IPADDR || '0.0.0.0',\n  WEB_PORT                : parseInt(process.env.PM2_API_PORT)  || 9615,\n  MODIFY_REQUIRE          : process.env.PM2_MODIFY_REQUIRE || false,\n\n  WORKER_INTERVAL         : process.env.PM2_WORKER_INTERVAL || 30000,\n  KILL_TIMEOUT            : process.env.PM2_KILL_TIMEOUT || 1600,\n  PM2_PROGRAMMATIC        : typeof(process.env.pm_id) !== 'undefined' || process.env.PM2_PROGRAMMATIC,\n  PM2_LOG_DATE_FORMAT     : process.env.PM2_LOG_DATE_FORMAT !== undefined ? process.env.PM2_LOG_DATE_FORMAT : 'YYYY-MM-DD HH:mm:ss'\n\n};\n\nmodule.exports = util._extend(csts, path_structure);\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/paths.js":"\n/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\n\nvar debug = require('debug')('pm2:paths');\nvar p     = require('path');\n\nfunction getDefaultPM2Home() {\n  var PM2_ROOT_PATH;\n\n  if (process.env.PM2_HOME)\n    PM2_ROOT_PATH = process.env.PM2_HOME;\n  else if (process.env.HOME && !process.env.HOMEPATH)\n    PM2_ROOT_PATH = p.resolve(process.env.HOME, '.pm2');\n  else if (process.env.HOME || process.env.HOMEPATH)\n    PM2_ROOT_PATH = p.resolve(process.env.HOMEDRIVE, process.env.HOME || process.env.HOMEPATH, '.pm2');\n  else {\n    console.error('[PM2][Initialization] Environment variable HOME (Linux) or HOMEPATH (Windows) are not set!');\n    console.error('[PM2][Initialization] Defaulting to /etc/.pm2');\n    PM2_ROOT_PATH = p.resolve('/etc', '.pm2');\n  }\n\n  debug('pm2 home resolved to %s', PM2_ROOT_PATH, process.env.HOME);\n  return PM2_ROOT_PATH;\n}\n\nmodule.exports = function(PM2_HOME) {\n  if (!PM2_HOME)\n    PM2_HOME = getDefaultPM2Home()\n\n  var pm2_file_stucture = {\n    PM2_HOME                 : PM2_HOME,\n    PM2_ROOT_PATH            : PM2_HOME,\n\n    PM2_CONF_FILE            : p.resolve(PM2_HOME, 'conf.js'),\n    PM2_MODULE_CONF_FILE     : p.resolve(PM2_HOME, 'module_conf.json'),\n\n    PM2_LOG_FILE_PATH        : p.resolve(PM2_HOME, 'pm2.log'),\n    PM2_PID_FILE_PATH        : p.resolve(PM2_HOME, 'pm2.pid'),\n\n    DEFAULT_PID_PATH         : p.resolve(PM2_HOME, 'pids'),\n    DEFAULT_LOG_PATH         : p.resolve(PM2_HOME, 'logs'),\n    DUMP_FILE_PATH           : p.resolve(PM2_HOME, 'dump.pm2'),\n\n    DAEMON_RPC_PORT          : p.resolve(PM2_HOME, 'rpc.sock'),\n    DAEMON_PUB_PORT          : p.resolve(PM2_HOME, 'pub.sock'),\n    INTERACTOR_RPC_PORT      : p.resolve(PM2_HOME, 'interactor.sock'),\n\n    INTERACTOR_LOG_FILE_PATH : p.resolve(PM2_HOME, 'agent.log'),\n    INTERACTOR_PID_PATH      : p.resolve(PM2_HOME, 'agent.pid'),\n    INTERACTION_CONF         : p.resolve(PM2_HOME, 'agent.json5')\n  };\n\n  if (process.platform === 'win32' ||\n      process.platform === 'win64') {\n    //@todo instead of static unique rpc/pub file custom with PM2_HOME or UID\n    pm2_file_stucture.DAEMON_RPC_PORT = '\\\\\\\\.\\\\pipe\\\\rpc.sock';\n    pm2_file_stucture.DAEMON_PUB_PORT = '\\\\\\\\.\\\\pipe\\\\pub.sock';\n    pm2_file_stucture.INTERACTOR_RPC_PORT = '\\\\\\\\.\\\\pipe\\\\interactor.sock';\n  }\n\n  return pm2_file_stucture;\n};\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/Client.js":"/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\n\nvar debug          = require('debug')('pm2:client');\nvar Common         = require('./Common.js');\nvar KMDaemon       = require('./Interactor/InteractorDaemonizer.js');\nvar rpc            = require('pm2-axon-rpc');\nvar async          = require('async');\nvar axon           = require('pm2-axon');\nvar util           = require('util');\nvar fs             = require('fs');\nvar path           = require('path');\nvar mkdirp         = require('mkdirp');\nvar shelljs        = require('shelljs');\n\nfunction noop() {}\n\nvar Client = module.exports = function(opts) {\n  if (!opts) opts = {};\n\n  if (!opts.conf)\n    this.conf = require('../constants.js');\n  else {\n    this.conf     = opts.conf;\n  }\n\n  this.daemon_mode = typeof(opts.daemon_mode) == 'undefined' ? true : opts.daemon_mode;\n  this.pm2_home    = this.conf.PM2_ROOT_PATH;\n  this.secret_key   = opts.secret_key;\n  this.public_key   = opts.public_key;\n  this.machine_name = opts.machine_name;\n\n  // Create all folders and files needed\n  // Client depends to that to interact with PM2 properly\n  this.initFileStructure(this.conf);\n\n  debug('Using RPC file %s', this.conf.DAEMON_RPC_PORT);\n  debug('Using PUB file %s', this.conf.DAEMON_PUB_PORT);\n  this.rpc_socket_file = this.conf.DAEMON_RPC_PORT;\n  this.pub_socket_file = this.conf.DAEMON_PUB_PORT;\n}\n\n// @breaking change (noDaemonMode has been drop)\n// @todo ret err\nClient.prototype.start = function(cb) {\n  var that = this;\n\n  this.pingDaemon(function(daemonAlive) {\n    if (daemonAlive == true)\n      return that.launchRPC(function(err, meta) {\n        return cb(null, {\n          daemon_mode      : that.conf.daemon_mode,\n          new_pm2_instance : false,\n          rpc_socket_file  : that.rpc_socket_file,\n          pub_socket_file  : that.pub_socket_file,\n          pm2_home         : that.pm2_home\n        });\n      });\n\n    /**\n     * No Daemon mode\n     */\n    if (that.daemon_mode == false) {\n      var Daemon         = require('./Daemon.js');\n\n      var daemon = new Daemon({\n        pub_socket_file : that.conf.DAEMON_PUB_PORT,\n        rpc_socket_file : that.conf.DAEMON_RPC_PORT,\n        pid_file        : that.conf.PM2_PID_FILE_PATH\n      });\n\n      console.log('Launching in no daemon mode');\n\n      daemon.innerStart(function() {\n        KMDaemon.launchAndInteract(that.conf, {\n          machine_name : that.machine_name,\n          public_key   : that.public_key,\n          secret_key   : that.secret_key\n        }, function(err, data, interactor_proc) {\n          that.interactor_process = interactor_proc;\n        });\n\n        that.launchRPC(function(err, meta) {\n          return cb(null, {\n            daemon_mode      : that.conf.daemon_mode,\n            new_pm2_instance : false,\n            rpc_socket_file  : that.rpc_socket_file,\n            pub_socket_file  : that.pub_socket_file,\n            pm2_home         : that.pm2_home\n          });\n        });\n      });\n      return false;\n    }\n\n    /**\n     * Daemon mode\n     */\n    that.launchDaemon(function(err, child) {\n      if (err) {\n        Common.printError(err);\n        return cb ? cb(err) : process.exit(that.conf.ERROR_EXIT);\n      }\n      Common.printOut(that.conf.PREFIX_MSG + 'PM2 Successfully daemonized');\n      that.launchRPC(function(err, meta) {\n        return cb(null, {\n          daemon_mode      : that.conf.daemon_mode,\n          new_pm2_instance : true,\n          rpc_socket_file  : that.rpc_socket_file,\n          pub_socket_file  : that.pub_socket_file,\n          pm2_home         : that.pm2_home\n        });\n      });\n    });\n  });\n};\n\n// Init file structure of pm2_home\n// This includes\n// - pm2 pid and log path\n// - rpc and pub socket for command execution\nClient.prototype.initFileStructure = function (opts) {\n\n  if (!fs.existsSync(opts.DEFAULT_LOG_PATH)) {\n    try {\n      mkdirp.sync(opts.DEFAULT_LOG_PATH);\n    } catch (e) {\n      console.error(e.stack || e);\n    }\n  }\n\n  if (!fs.existsSync(opts.DEFAULT_PID_PATH)) {\n    try {\n      mkdirp.sync(opts.DEFAULT_PID_PATH);\n    } catch (e) {\n      console.error(e.stack || e);\n    }\n  }\n\n  // No more (temporary) conf file, mainly via api now\n  // @todo: implement configuration file for override\n  // (before conf was only about path overrides)\n  // if (!fs.existsSync(opts.PM2_CONF_FILE)) {\n  //   fs\n  //     .createReadStream(path.join(opts.TEMPLATE_FOLDER, opts.SAMPLE_CONF_FILE))\n  //     .pipe(fs.createWriteStream(opts.PM2_CONF_FILE));\n  // }\n\n  if (!fs.existsSync(opts.PM2_MODULE_CONF_FILE)) {\n    try {\n      fs.writeFileSync(opts.PM2_MODULE_CONF_FILE, \"{}\");\n    } catch (e) {\n      console.error(e.stack || e);\n    }\n  }\n\n  if (!process.env.PM2_PROGRAMMATIC && !fs.existsSync(path.join(opts.PM2_HOME, 'touch'))) {\n    var dt = fs.readFileSync(path.join(__dirname, opts.KEYMETRICS_BANNER));\n    console.log(dt.toString());\n    try {\n      fs.writeFileSync(path.join(opts.PM2_HOME, 'touch'), Date.now());\n    } catch(e) {\n      debug(e.stack || e);\n    }\n  }\n};\n\nClient.prototype.close = function(cb) {\n  var that = this;\n\n  async.forEach([\n    that.disconnectRPC.bind(that),\n    that.disconnectBus.bind(that)\n  ], function(fn, next) {\n    fn(next)\n  }, cb);\n};\n\n/**\n * Launch the Daemon by forking this same file\n * The method Client.remoteWrapper will be called\n *\n * @method launchDaemon\n * @param {Object} opts\n * @param {Object} [opts.interactor=true] allow to disable interaction on launch\n */\nClient.prototype.launchDaemon = function(opts, cb) {\n  if (typeof(opts) == 'function') {\n    cb = opts;\n    opts = {\n      interactor : true\n    };\n  }\n\n  var that = this\n  var ClientJS = path.resolve(path.dirname(module.filename), 'Daemon.js');\n  var node_args = [];\n  var out, err;\n\n  if (process.env.TRAVIS) {\n    // Redirect PM2 internal err and out to STDERR STDOUT when running with Travis\n    out = 1;\n    err = 2;\n  }\n  else {\n    out = fs.openSync(that.conf.PM2_LOG_FILE_PATH, 'a'),\n    err = fs.openSync(that.conf.PM2_LOG_FILE_PATH, 'a');\n  }\n\n  // Node.js tuning for better performance\n  //node_args.push('--expose-gc'); // Allows manual GC in the code\n  //node_args.push('--gc-global'); // Does full GC (smaller memory footprint)\n  //node_args.push('--max-old-space-size=100');\n\n  /**\n   * Add node [arguments] depending on PM2_NODE_OPTIONS env variable\n   */\n  if (process.env.PM2_NODE_OPTIONS)\n    node_args = node_args.concat(process.env.PM2_NODE_OPTIONS.split(' '));\n  node_args.push(ClientJS);\n\n  Common.printOut(that.conf.PREFIX_MSG + 'Spawning PM2 daemon with pm2_home=' + this.pm2_home);\n\n  var interpreter = 'node';\n\n  if (shelljs.which('node') == null)\n    interpreter = process.execPath;\n\n  var child = require('child_process').spawn(interpreter, node_args, {\n    detached   : true,\n    cwd        : that.conf.cwd || process.cwd(),\n    env        : util._extend({\n      'SILENT'      : that.conf.DEBUG ? !that.conf.DEBUG : true,\n      'PM2_HOME'   : that.pm2_home\n    }, process.env),\n    stdio      : ['ipc', out, err]\n  });\n\n  function onError(e) {\n    console.error(e.message || e);\n    return cb ? cb(e.message || e) : false;\n  }\n\n  child.once('error', onError);\n\n  child.unref();\n\n  child.once('message', function(msg) {\n    debug('PM2 daemon launched with return message: ', msg);\n    child.removeListener('error', onError);\n    child.disconnect();\n\n    if (opts && opts.interactor == false)\n      return cb(null, child);\n\n    /**\n     * Here the Keymetrics agent is launched automaticcaly if\n     * it has been already configured before (via pm2 link)\n     */\n    KMDaemon.launchAndInteract(that.conf, {\n      machine_name : that.machine_name,\n      public_key   : that.public_key,\n      secret_key   : that.secret_key\n    }, function(err, data, interactor_proc) {\n      that.interactor_process = interactor_proc;\n      return cb(null, child);\n    });\n  });\n};\n\n/**\n * Ping the daemon to know if it alive or not\n * @api public\n * @method pingDaemon\n * @param {} cb\n * @return\n */\nClient.prototype.pingDaemon = function pingDaemon(cb) {\n  var req    = axon.socket('req');\n  var client = new rpc.Client(req);\n\n  debug('[PING PM2] Trying to connect to server');\n\n  client.sock.once('reconnect attempt', function() {\n    client.sock.close();\n    debug('Daemon not launched');\n    process.nextTick(function() {\n      return cb(false);\n    });\n  });\n\n  client.sock.once('connect', function() {\n    client.sock.once('close', function() {\n      return cb(true);\n    });\n    client.sock.close();\n    debug('Daemon alive');\n  });\n\n  req.connect(this.rpc_socket_file);\n};\n\n/**\n * Methods to interact with the Daemon via RPC\n * This method wait to be connected to the Daemon\n * Once he's connected it trigger the command parsing (on ./bin/pm2 file, at the end)\n * @method launchRPC\n * @return\n */\nClient.prototype.launchRPC = function launchRPC(cb) {\n  var self = this;\n  debug('Launching RPC client on socket file %s', this.rpc_socket_file);\n  var req      = axon.socket('req');\n  this.client  = new rpc.Client(req);\n\n  this.client.sock.once('connect', function() {\n    // Avoid keeping the event loop busy if no more items running\n    // if (req && req.socks && req.socks[0] && req.socks[0].unref &&\n    //     self.conf.PM2_PROGRAMMATIC)\n    //   req.socks[0].unref();\n    debug('RPC Connected to Daemon');\n    //process.emit('satan:client:ready');\n    setTimeout(function() {\n      return cb ? cb(null) : false;\n    }, 4);\n  });\n\n  this.client.sock.on('error', function(e) {\n    return cb(e);\n  });\n\n  this.client_sock = req.connect(this.rpc_socket_file);\n};\n\n/**\n * Methods to close the RPC connection\n * @callback cb\n */\nClient.prototype.disconnectRPC = function disconnectRPC(cb) {\n  var that = this;\n  if (!cb) cb = noop;\n\n  if (!this.client_sock || !this.client_sock.close) {\n    this.client = null;\n    return process.nextTick(function() {\n      cb(new Error('SUB connection to PM2 is not launched'));\n    });\n  }\n\n  if (this.client_sock.connected == false ||\n      this.client_sock.closing == true) {\n    this.client = null;\n    return process.nextTick(function() {\n      cb(new Error('RPC already being closed'));\n    });\n  }\n\n  try {\n    var timer;\n\n    that.client_sock.once('close', function() {\n      clearTimeout(timer);\n      that.client = null;\n      debug('PM2 RPC cleanly closed');\n      return cb(null, { msg : 'RPC Successfully closed' });\n    });\n\n    timer = setTimeout(function() {\n      if (Client.client_sock.destroy)\n        that.client_sock.destroy();\n      that.client = null;\n      return cb(null, { msg : 'RPC Successfully closed via timeout' });\n    }, 200);\n\n    that.client_sock.close();\n  } catch(e) {\n    debug('Error while disconnecting RPC PM2', e.stack || e);\n    return cb(e);\n  };\n  return false;\n};\n\nClient.prototype.launchBus = function launchEventSystem(cb) {\n  var self = this;\n  this.sub = axon.socket('sub-emitter');\n  this.sub_sock = this.sub.connect(this.pub_socket_file);\n\n  this.sub_sock.once('connect', function() {\n    return cb(null, self.sub, self.sub_sock);\n  });\n};\n\nClient.prototype.disconnectBus = function disconnectBus(cb) {\n  if (!cb) cb = noop;\n\n  var that = this;\n\n  if (!this.sub_sock || !this.sub_sock.close) {\n    that.sub = null;\n    return process.nextTick(function() {\n      cb(null, { msg : 'bus was not connected'});\n    });\n  }\n\n  if (this.sub_sock.connected == false ||\n      this.sub_sock.closing == true) {\n    that.sub = null;\n    return process.nextTick(function() {\n      cb(new Error('SUB connection is already being closed'));\n    });\n  }\n\n  try {\n    var timer;\n\n    that.sub_sock.once('close', function() {\n      that.sub = null;\n      clearTimeout(timer);\n      debug('PM2 PUB cleanly closed');\n      return cb();\n    });\n\n    timer = setTimeout(function() {\n      if (Client.sub_sock.destroy)\n        that.sub_sock.destroy();\n      return cb();\n    }, 200);\n\n    this.sub_sock.close();\n  } catch(e) {\n    return cb(e);\n  }\n};\n\n/**\n * Description\n * @method gestExposedMethods\n * @param {} cb\n * @return\n */\nClient.prototype.getExposedMethods = function getExposedMethods(cb) {\n  this.client.methods(cb);\n};\n\n/**\n * Description\n * @method executeRemote\n * @param {} method\n * @param {} env\n * @param {} fn\n * @return\n */\nClient.prototype.executeRemote = function executeRemote(method, app_conf, fn) {\n  var self = this;\n\n  // stop watch on stop | env is the process id\n  if (method.indexOf('stop') !== -1) {\n    this.stopWatch(method, app_conf);\n  }\n  // stop watching when process is deleted\n  else if (method.indexOf('delete') !== -1) {\n    this.stopWatch(method, app_conf);\n  }\n  // stop everything on kill\n  else if (method.indexOf('kill') !== -1) {\n    this.stopWatch('deleteAll', app_conf);\n  }\n  else if (method.indexOf('restartProcessId') !== -1 && process.argv.indexOf('--watch') > -1) {\n    delete app_conf.env.current_conf.watch;\n    this.toggleWatch(method, app_conf);\n  }\n\n  if (!this.client || !this.client.call) {\n    this.start(function(error) {\n      if (error) {\n        if (fn)\n          return fn(error);\n        console.error(error);\n        return process.exit(0);\n      }\n      return self.client.call(method, app_conf, fn);\n    });\n    return false;\n  }\n\n  debug('Calling daemon method pm2:%s on rpc socket:%s', method, this.rpc_socket_file);\n  return this.client.call(method, app_conf, fn);\n};\n\nClient.prototype.notifyGod = function(action_name, id, cb) {\n  this.executeRemote('notifyByProcessId', {\n    id : id,\n    action_name : action_name,\n    manually : true\n  }, function() {\n    debug('God notified');\n    return cb ? cb() : false;\n  });\n};\n\nClient.prototype.killDaemon = function killDaemon(fn) {\n  var timeout;\n  var that = this;\n\n  function quit() {\n    that.close(function() {\n      return fn ? fn(null, {success:true}) : false;\n    });\n  }\n\n  // under unix, we listen for signal (that is send by daemon to notify us that its shuting down)\n  if (process.platform !== 'win32' && process.platform !== 'win64') {\n    process.once('SIGQUIT', function() {\n      debug('Received SIGQUIT from pm2 daemon');\n      clearTimeout(timeout);\n      quit();\n    });\n  }\n  else {\n    // if under windows, try to ping the daemon to see if it still here\n    setTimeout(function() {\n      that.pingDaemon(function(alive) {\n        if (!alive) {\n          clearTimeout(timeout);\n          return quit();\n        }\n      });\n    }, 250)\n  }\n\n  timeout = setTimeout(function() {\n    quit();\n  }, 3000);\n\n  // Kill daemon\n  this.executeRemote('killMe', {pid : process.pid});\n};\n\n\n/**\n * Description\n * @method toggleWatch\n * @param {String} pm2 method name\n * @param {Object} application environment, should include id\n * @param {Function} callback\n */\nClient.prototype.toggleWatch = function toggleWatch(method, env, fn) {\n  debug('Calling toggleWatch');\n  this.client.call('toggleWatch', method, env, function() {\n    return fn ? fn() : false;\n  });\n};\n\n/**\n * Description\n * @method startWatch\n * @param {String} pm2 method name\n * @param {Object} application environment, should include id\n * @param {Function} callback\n */\nClient.prototype.startWatch = function restartWatch(method, env, fn) {\n  debug('Calling startWatch');\n  this.client.call('startWatch', method, env, function() {\n    return fn ? fn() : false;\n  });\n};\n\n/**\n * Description\n * @method stopWatch\n * @param {String} pm2 method name\n * @param {Object} application environment, should include id\n * @param {Function} callback\n */\nClient.prototype.stopWatch = function stopWatch(method, env, fn) {\n  debug('Calling stopWatch');\n  this.client.call('stopWatch', method, env, function() {\n    return fn ? fn() : false;\n  });\n};\n\nClient.prototype.getAllModulesId = function(cb) {\n  var found_proc = [];\n\n  this.executeRemote('getMonitorData', {}, function(err, list) {\n    if (err) {\n      Common.printError('Error retrieving process list: ' + err);\n      return cb(err);\n    }\n\n    list.forEach(function(proc) {\n      if (proc.pm2_env.pmx_module)\n        found_proc.push(proc.pm_id);\n    });\n\n    return cb(null, found_proc);\n  });\n};\n\nClient.prototype.getAllProcess = function(cb) {\n  var found_proc = [];\n\n  this.executeRemote('getMonitorData', {}, function(err, list) {\n    if (err) {\n      Common.printError('Error retrieving process list: ' + err);\n      return cb(err);\n    }\n\n    list.forEach(function(proc) {\n      found_proc.push(proc);\n    });\n\n    return cb(null, found_proc);\n  });\n};\n\nClient.prototype.getAllProcessId = function(cb) {\n  var found_proc = [];\n\n  this.executeRemote('getMonitorData', {}, function(err, list) {\n    if (err) {\n      Common.printError('Error retrieving process list: ' + err);\n      return cb(err);\n    }\n\n    list.forEach(function(proc) {\n      if (!proc.pm2_env.pmx_module)\n        found_proc.push(proc.pm_id);\n    });\n\n    return cb(null, found_proc);\n  });\n};\n\nClient.prototype.getProcessIdByName = function(name, force_all, cb) {\n  var found_proc   = [];\n  var full_details = {};\n\n  if (typeof(cb) === 'undefined') {\n    cb = force_all;\n    force_all = false;\n  }\n\n  if (typeof(name) == 'number')\n    name = name.toString();\n\n  this.executeRemote('getMonitorData', {}, function(err, list) {\n    if (err) {\n      Common.printError('Error retrieving process list: ' + err);\n      return cb(err);\n    }\n\n    list.forEach(function(proc) {\n      if ((proc.pm2_env.name == name || proc.pm2_env.pm_exec_path == path.resolve(name)) &&\n          !(proc.pm2_env.pmx_module && !force_all)) {\n        found_proc.push(proc.pm_id);\n        full_details[proc.pm_id] = proc;\n      }\n    });\n\n    return cb(null, found_proc, full_details);\n  });\n};\n\nClient.prototype.getProcessByName = function(name, cb) {\n  var found_proc = [];\n\n  this.executeRemote('getMonitorData', {}, function(err, list) {\n    if (err) {\n      Common.printError('Error retrieving process list: ' + err);\n      return cb(err);\n    }\n\n    list.forEach(function(proc) {\n      if (proc.pm2_env.name == name ||\n          proc.pm2_env.pm_exec_path == path.resolve(name)) {\n        found_proc.push(proc);\n      }\n    });\n\n    return cb(null, found_proc);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/Common.js":"/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\n\nvar fs        = require('fs');\nvar path      = require('path');\nvar util      = require('util');\nvar mkdirp    = require('mkdirp');\nvar cronJob   = require('cron').CronJob;\nvar async     = require('async');\nvar shelljs   = require('shelljs');\nvar chalk     = require('chalk');\nvar fclone    = require('fclone');\nvar semver    = require('semver');\n\nvar isBinary  = require('./tools/isbinaryfile.js');\nvar cst       = require('../constants.js');\nvar extItps   = require('./API/interpreter.json');\nvar Config    = require('./tools/Config');\nvar KMDaemon  = require('./Interactor/InteractorDaemonizer.js');\n\n/**\n * Common methods (used by CLI and God)\n */\n\nvar Common = module.exports;\n\nfunction homedir() {\n  var env = process.env;\n  var home = env.HOME;\n  var user = env.LOGNAME || env.USER || env.LNAME || env.USERNAME;\n\n  if (process.platform === 'win32') {\n    return env.USERPROFILE || env.HOMEDRIVE + env.HOMEPATH || home || null;\n  }\n\n  if (process.platform === 'darwin') {\n    return home || (user ? '/Users/' + user : null);\n  }\n\n  if (process.platform === 'linux') {\n    return home || (process.getuid() === 0 ? '/root' : (user ? '/home/' + user : null));\n  }\n\n  return home || null;\n}\n\nfunction resolveHome(filepath) {\n  if (filepath[0] === '~') {\n    return path.join(homedir(), filepath.slice(1));\n  }\n  return filepath;\n}\n\nfunction resolveCWD(custom_path, default_path) {\n  var target_cwd;\n\n  if (custom_path) {\n    if (custom_path[0] == '/')\n      target_cwd = custom_path;\n    else\n      target_cwd = path.join(default_path, custom_path);\n  }\n  else\n    target_cwd = default_path;\n\n  return target_cwd;\n}\n\n/**\n * Resolve app paths and replace missing values with defaults.\n * @method prepareAppConf\n * @param app {Object}\n * @param {} cwd\n * @param {} outputter\n * @return app\n */\nCommon.prepareAppConf = function(opts, app) {\n  /**\n   * Minimum validation\n   */\n  if (!app.script)\n    return new Error('No script path - aborting');\n\n  // Forbidden application name\n  if (app.name == 'push')\n    return new Error('Push application name is not allowed');\n\n  if (app.automation == false)\n    app.pmx = false;\n\n  if (!app.node_args)\n    app.node_args = [];\n\n  if (app.port && app.env)\n    app.env.PORT = app.port;\n\n  // CRON\n  var ret;\n  if ((ret = Common.sink.determineCron(app)) instanceof Error)\n    return ret;\n\n  // Resolve paths\n  // app.pm_exec_path = path.join(resolveCWD(app.cwd, opts.cwd), app.script);\n  // app.pm_cwd = path.dirname(app.pm_exec_path);\n  // console.log(' hads', app.pm_cwd);\n  var cwd = null;\n\n  if (app.cwd) {\n    cwd = path.resolve(app.cwd);\n    process.env.PWD = app.cwd;\n  }\n\n  // CWD option resolving\n  cwd && (cwd[0] != '/') && (cwd = path.resolve(process.cwd(), cwd));\n  cwd = cwd || opts.cwd;\n\n  // Full path script resolution\n  app.pm_exec_path = path.resolve(cwd, app.script);\n\n\n  // If script does not exists after resolution\n  if (!fs.existsSync(app.pm_exec_path)) {\n    var ckd;\n    // Try resolve command available in $PATH\n    if ((ckd = shelljs.which(app.script))) {\n      if (typeof(ckd) !== 'string')\n        ckd = ckd.toString();\n      app.pm_exec_path = ckd;\n    }\n    else\n      // Throw critical error\n      return new Error('script not found : ' + app.pm_exec_path);\n  }\n\n  /**\n   * Auto detect .map file and enable source map support automatically\n   */\n  if (app.disable_source_map_support != true) {\n    try {\n      if (fs.accessSync) {\n        fs.accessSync(app.pm_exec_path + '.map', fs.R_OK);\n        app.source_map_support = true;\n      }\n      else {\n        // Support for Node 0.10.x\n        if (fs.existsSync(app.pm_exec_path + '.map')) {\n          app.source_map_support = true;\n        }\n      }\n    } catch(e) {}\n    delete app.disable_source_map_support;\n  }\n\n  delete app.script;\n\n  // Set current env by first adding the process environment and then extending/replacing it\n  // with env specified on command-line or JSON file.\n\n  var env = {};\n\n  /**\n   * Do not copy internal pm2 environment variables if acting on process\n   * is made from a programmatic script started by PM2\n   */\n  if (cst.PM2_PROGRAMMATIC)\n    Common.safeExtend(env, process.env);\n  else\n    env = process.env;\n\n  // Change to double check  (dropped , {pm_cwd: cwd})\n  app.env = [{}, env, app.env || {}].reduce(function(e1, e2){\n    return util._extend(e1, e2);\n  });\n\n  app.pm_cwd = cwd;\n  // Interpreter\n  Common.sink.resolveInterpreter(app);\n\n  // Exec mode and cluster stuff\n  Common.sink.determineExecMode(app);\n\n  /**\n   * Scary\n   */\n  var formated_app_name = app.name.replace(/[^a-zA-Z0-9\\\\.\\\\-]/g, '-');\n\n  ['log', 'out', 'error', 'pid'].forEach(function(f){\n    var af = app[f + '_file'], ps, ext = (f == 'pid' ? 'pid':'log'), isStd = !~['log', 'pid'].indexOf(f);\n    if (af) af = resolveHome(af);\n\n    if ((f == 'log' && typeof af == 'boolean' && af) || (f != 'log' && !af)) {\n      ps = [cst['DEFAULT_' + ext.toUpperCase() + '_PATH'], formated_app_name + (isStd ? '-' + f : '') + '.' + ext];\n    } else if (f != 'log' || (f == 'log' && af)) {\n      ps = [cwd, af];\n\n      var dir = path.dirname(path.resolve(cwd, af));\n      if (!fs.existsSync(dir)) {\n        Common.printError(cst.PREFIX_MSG_WARNING + 'Folder does not exists: ' + dir);\n        Common.printOut(cst.PREFIX_MSG + 'Creating folder: ' + dir);\n        mkdirp(dir, function(err) {\n          if (!err) return;\n          Common.printError(cst.PREFIX_MSG_ERR + 'Could not create folder: ' + path.dirname(af));\n          throw new Error('Could not create folder');\n        });\n      }\n\n    }\n    // PM2 paths\n    ps && (app['pm_' + (isStd ? f.substr(0, 3) + '_' : '') + ext + '_path'] = path.resolve.apply(null, ps));\n    delete app[f + '_file'];\n  });\n\n  return app;\n};\n\n/**\n * Check if filename is a configuration file\n * @param {string} filename\n * @return {mixed} null if not conf file, json or yaml if conf\n */\nCommon.isConfigFile = function(filename) {\n  if (typeof(filename) != 'string')\n    return null;\n  if (filename.indexOf('.json') != -1)\n    return 'json';\n  if (filename.indexOf('.yml') > -1 || filename.indexOf('.yaml') > -1)\n    return 'yaml';\n  if (filename.indexOf('.config.js') != -1)\n    return 'js';\n  return null;\n};\n\n/**\n * Parses a config file like ecosystem.json. Supported formats: JS, JSON, JSON5, YAML.\n * @param {string} confString  contents of the config file\n * @param {string} filename    path to the config file\n * @return {Object} config object\n */\nCommon.parseConfig = function(confObj, filename) {\n  var yamljs = require('yamljs');\n  var vm     = require('vm');\n\n  if (!filename || filename == 'pipe' || filename == 'none' ||\n      filename.indexOf('.json') > -1) {\n    var code = '(' + confObj + ')';\n    var sandbox = {};\n    if (semver.satisfies(process.version, '>= 0.12.0')) {\n      return vm.runInThisContext(code, sandbox, {\n        filename: path.resolve(filename),\n        displayErrors: false,\n        timeout: 1000\n      });\n    } else {\n      // Use the Node 0.10 API\n      return vm.runInNewContext(code, sandbox, filename);\n    }\n  }\n  else if (filename.indexOf('.yml') > -1 ||\n           filename.indexOf('.yaml') > -1) {\n    return yamljs.parse(confObj.toString());\n  }\n  else if (filename.indexOf('.config.js') > -1) {\n    var confPath = require.resolve(path.resolve(filename));\n    delete require.cache[confPath];\n    return require(confPath);\n  }\n};\n\nCommon.retErr = function(e) {\n  if (!e)\n    return new Error('Unidentified error');\n  if (e instanceof Error)\n    return e;\n  return new Error(e);\n}\n\nCommon.sink = {};\n\nCommon.sink.determineCron = function(app) {\n  if (app.cron_restart) {\n    try {\n      Common.printOut(cst.PREFIX_MSG + 'cron restart at ' + app.cron_restart);\n      new cronJob(app.cron_restart, function() {\n        Common.printOut(cst.PREFIX_MSG + 'cron pattern for auto restart detected and valid');\n      });\n    } catch(ex) {\n      return new Error('Cron pattern is not valid, trace: ' + ex.stack);\n    }\n  }\n};\n\n/**\n * Handle alias (fork <=> fork_mode, cluster <=> cluster_mode)\n */\nCommon.sink.determineExecMode = function(app) {\n  if (typeof app.instances == 'undefined')\n    app.instances = 1;\n  if (app.exec_mode)\n    app.exec_mode = app.exec_mode.replace(/^(fork|cluster)$/, '$1_mode');\n\n  /**\n   * Here we put the default exec mode\n   */\n  if (!app.exec_mode && app.instances > 1) {\n    app.exec_mode = 'cluster_mode';\n  } else if (!app.exec_mode) {\n    app.exec_mode = 'fork_mode';\n  }\n};\n\nvar resolveNodeInterpreter = function(app) {\n  if (app.exec_mode.indexOf('cluster') > -1) {\n    Common.printError(cst.PREFIX_MSG_WARNING + chalk.bold.yellow('Choosing the Node.js version in cluster mode is not supported'));\n    return false;\n  }\n  if (!process.env.NVM_DIR) {\n    Common.printError(cst.PREFIX_MSG_ERR + chalk.red('NVM is not available in PATH'));\n    Common.printError(cst.PREFIX_MSG_ERR + chalk.red('Fallback to node in PATH'));\n    Common.printOut(cst.PREFIX_MSG_ERR + chalk.bold('Install NVM:\\n$ curl https://raw.githubusercontent.com/creationix/nvm/master/install.sh | bash'));\n  }\n  else {\n    var node_version  = app.exec_interpreter.split('@')[1];\n    var nvm_node_path;\n\n    if (semver.satisfies(node_version, '>= 0.12.0'))\n      nvm_node_path = path.join(process.env.NVM_DIR, '/versions/node/v' + node_version + '/bin/node');\n    else\n      nvm_node_path = path.join(process.env.NVM_DIR, '/v' + node_version + '/bin/node');\n\n    try {\n      fs.accessSync(nvm_node_path);\n    } catch(e) {\n      Common.printOut(cst.PREFIX_MSG + 'Installing Node v%s', node_version);\n      var nvm_bin = path.join(process.env.NVM_DIR, 'nvm.sh');\n      var nvm_cmd = '. ' + nvm_bin + ' ; nvm install ' + node_version;\n\n      Common.printOut(cst.PREFIX_MSG + 'Executing: %s', nvm_cmd);\n      shelljs.exec(nvm_cmd);\n    }\n\n    Common.printOut(cst.PREFIX_MSG + chalk.green.bold('Setting Node to v%s (path=%s)'),\n                    node_version,\n                    nvm_node_path);\n\n    app.exec_interpreter = nvm_node_path;\n  }\n};\n\n/**\n * Resolve interpreter\n */\nCommon.sink.resolveInterpreter = function(app) {\n  var noInterpreter     = (!app.exec_interpreter || 'none' == app.exec_interpreter),\n      extName           = path.extname(app.pm_exec_path),\n      betterInterpreter = extItps[extName];\n\n  // No interpreter defined and correspondance in schema hashmap\n  if (noInterpreter && betterInterpreter)\n    app.exec_interpreter = betterInterpreter;\n  // Else if no Interpreter detect if process is binary\n  else if (noInterpreter)\n    app.exec_interpreter = isBinary(app.pm_exec_path) ? 'none' : 'node';\n  else if (app.exec_interpreter.indexOf('node@') > -1)\n    resolveNodeInterpreter(app);\n\n  /**\n   * Specific installed JS transpilers\n   */\n  if (app.exec_interpreter == 'ts-node') {\n    app.exec_interpreter = path.resolve(__dirname, '../node_modules/.bin/ts-node');\n  }\n\n  if (app.exec_interpreter == 'lsc') {\n    app.exec_interpreter = path.resolve(__dirname, '../node_modules/.bin/lsc');\n  }\n\n  if (app.exec_interpreter == 'coffee') {\n    app.exec_interpreter = path.resolve(__dirname, '../node_modules/.bin/coffee');\n  }\n\n  if (app.exec_interpreter != 'none' && shelljs.which(app.exec_interpreter) == null) {\n    Common.printError(cst.PREFIX_MSG_ERR + 'Interpreter ' + app.exec_interpreter + ' does not seems to be available');\n  }\n  return app;\n};\n\nCommon.deepCopy = Common.serialize = Common.clone = function(obj) {\n  if (obj === null || obj === undefined) return {};\n  return fclone(obj);\n};\n\n/**\n * Description\n * @method printError\n * @param {} msg\n * @return CallExpression\n */\nCommon.printError = function(msg) {\n  if (process.env.PM2_SILENT || process.env.PM2_PROGRAMMATIC === 'true') return false;\n  if (msg instanceof Error)\n    return console.error(msg.message);\n  return console.error.apply(console, arguments);\n};\n\n/**\n * Description\n * @method printOut\n * @return\n */\nCommon.printOut = function() {\n  if (process.env.PM2_SILENT === 'true' || process.env.PM2_PROGRAMMATIC === 'true') return false;\n  return console.log.apply(console, arguments);\n};\n\n\n/**\n * Raw extend\n */\nCommon.extend = function(destination, source){\n  if (!source || typeof source != 'object') return destination;\n\n  Object.keys(source).forEach(function(new_key) {\n    if (source[new_key] != '[object Object]')\n      destination[new_key] = source[new_key];\n  });\n\n  return destination;\n};\n\n/**\n * This is useful when starting script programmatically\n */\nCommon.safeExtend = function(origin, add){\n  if (!add || typeof add != 'object') return origin;\n\n  //Ignore PM2's set environment variables from the nested env\n  var keysToIgnore = ['name', 'exec_mode', 'env', 'args', 'pm_cwd', 'exec_interpreter', 'pm_exec_path', 'node_args', 'pm_out_log_path', 'pm_err_log_path', 'pm_pid_path', 'pm_id', 'status', 'pm_uptime', 'created_at', 'unstable_restarts', 'restart_time', 'axm_actions', 'pmx_module', 'command', 'watch', 'versioning', 'vizion_runing', 'MODULE_DEBUG', 'pmx', 'axm_options', 'created_at', 'watch', 'vizion', 'axm_dynamic', 'axm_monitor', 'instances', 'automation', 'autorestart', 'node_args', 'unstable_restart', 'treekill', 'exit_code'];\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n  \t//Only copy stuff into the env that we don't have already.\n  \tif(keysToIgnore.indexOf(keys[i]) == -1 && add[keys[i]] != '[object Object]')\n      origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\n\n/**\n * Extend the app.env object of with the properties taken from the\n * app.env_[envName] and deploy configuration.\n * Also update current json attributes\n *\n * Used only for Configuration file processing\n *\n * @param {Object} app The app object.\n * @param {string} envName The given environment name.\n * @param {Object} deployConf Deployment configuration object (from JSON file or whatever).\n * @returns {Object} The app.env variables object.\n */\nCommon.mergeEnvironmentVariables = function(app_env, env_name, deploy_conf) {\n  var app = fclone(app_env);\n\n  if (!app.env)\n    app.env = {};\n\n  if (env_name) {\n    var finalEnv = {};\n\n    // First merge variables from deploy.production.env object as least priority.\n    if (deploy_conf && deploy_conf[env_name] && deploy_conf[env_name]['env']) {\n      util._extend(finalEnv, deploy_conf[env_name]['env']);\n    }\n\n    // Then merge app.env object.\n    util._extend(finalEnv, app.env);\n\n    // Then, last and highest priority, merge the app.env_production object.\n    if ('env_' + env_name in app) {\n      util._extend(finalEnv, app['env_' + env_name]);\n    }\n\n    app.env = finalEnv;\n  }\n\n  for (var key in app.env) {\n    if (typeof app.env[key] == 'object') {\n      app.env[key] = JSON.stringify(app.env[key]);\n    }\n  }\n\n  /**\n   * Extra configuration update\n   */\n  var current_conf = fclone(app);\n  delete current_conf.env;\n  app.env.current_conf = current_conf;\n\n  // #2541 force resolution of node interpreter\n  if (app.env.current_conf.exec_interpreter &&\n      app.env.current_conf.exec_interpreter.indexOf('@') > -1)\n    resolveNodeInterpreter(app.env.current_conf);\n\n  return app.env;\n}\n\n/**\n * This function will resolve paths, option and environment\n * CALLED before 'prepare' God call (=> PROCESS INITIALIZATION)\n * @method resolveAppAttributes\n * @param {Object} opts\n * @param {Object} opts.cwd\n * @param {Object} opts.pm2_home\n * @param {Object} appConf application configuration\n * @return app\n */\nCommon.resolveAppAttributes = function(opts, legacy_app) {\n  var appConf = fclone(legacy_app);\n\n  var app = Common.prepareAppConf(opts, appConf);\n  if (app instanceof Error) {\n    Common.printError(cst.PREFIX_MSG_ERR + app.message);\n    throw new Error(app.message);\n  }\n  return app;\n}\n\n\n/**\n * Verify configurations\n * Called on EVERY Operation (start/restart/reload/stop...)\n * @param {Array} appConfs\n * @returns {Array}\n */\nCommon.verifyConfs = function(appConfs){\n  if (!appConfs || appConfs.length == 0){\n    return [];\n  }\n\n  // Make sure it is an Array.\n  appConfs = [].concat(appConfs);\n\n  var verifiedConf = [];\n\n  for (var i = 0; i < appConfs.length; i++) {\n    var app = appConfs[i];\n\n    if (app.disable_trace) {\n      app.trace = false\n      delete app.disable_trace;\n    }\n\n    // Warn deprecates.\n    checkDeprecates(app);\n\n    // Check Exec mode\n    checkExecMode(app);\n\n    // Render an app name if not existing.\n    prepareAppName(app);\n\n    var ret = Config.validateJSON(app);\n    //debug('After processing', ret);\n    // Show errors if existing.\n\n    if (ret.errors && ret.errors.length > 0){\n      ret.errors.forEach(function(err){\n        warn(err);\n      });\n      // Return null == error\n      return new Error(ret.errors);\n    }\n    verifiedConf.push(ret.config);\n  }\n\n  return verifiedConf;\n}\n\n/**\n * Check if right Node.js version for cluster mode\n * @param {Object} conf\n */\nfunction checkExecMode(conf) {\n\n  if (conf.exec_mode === 'cluster' ||\n      conf.exec_mode === 'cluster_mode' ||\n      conf.instances && conf.exec_mode === undefined)\n    conf.exec_mode = 'cluster_mode';\n  else\n    conf.exec_mode = 'fork_mode';\n\n  // -x -i 4\n\n  if (!isNaN(conf.instances) && /^fork(_mode)?$/i.test(conf.exec_mode)) {\n\n    warn('You are starting ' +\n         chalk.blue(conf.instances) +\n         ' processes in ' +\n         chalk.blue(conf.exec_mode) +\n         ' without load balancing. To enable it remove -x option.');\n  }\n\n  if (conf.instances && conf.exec_mode === undefined)\n    conf.exec_mode = 'cluster_mode';\n\n  // Tell user about unstability of cluster module + Roadmap\n  if (/^cluster(_mode)?$/i.test(conf.exec_mode) &&\n      process.version.match(/0.10/) &&\n      !process.env.TRAVIS) {\n    warn('You should not use the cluster_mode (-i) in production, it\\'s still a beta feature. A front HTTP load balancer or interaction with NGINX will be developed in the future.');\n  }\n}\n\n/**\n * Check deprecates and show warnings.\n * @param {Object} conf\n */\nfunction checkDeprecates(conf){\n  if (conf.instances == 'max')\n    conf.instances = 0;\n  // Sanity check, default to number of cores if value can't be parsed\n  if (typeof(conf.instances) === 'string')\n    conf.instances = parseInt(conf.instances) || 0;\n}\n\n/**\n * Render an app name if not existing.\n * @param {Object} conf\n */\nfunction prepareAppName(conf){\n  if (!conf.name && conf.script){\n    conf.name = conf.script !== undefined ? path.basename(conf.script) : 'undefined';\n    var lastDot = conf.name.lastIndexOf('.');\n    if (lastDot > 0){\n      conf.name = conf.name.slice(0, lastDot);\n    }\n  }\n}\n\n\n/**\n * Show warnings\n * @param {String} warning\n */\nfunction warn(warning){\n  Common.printOut(cst.PREFIX_MSG_WARNING + warning);\n}\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/tools/isbinaryfile.js":"/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\nvar fs = require('fs');\nvar path = require(\"path\");\nvar max_bytes = 512;\n\nmodule.exports = function(bytes, size) {\n  // Read the file with no encoding for raw buffer access.\n  if (size === undefined) {\n    var file = bytes;\n    try {\n      if(!fs.statSync(file).isFile()) return false;\n    } catch (err) {\n      // otherwise continue on\n    }\n    var descriptor = fs.openSync(file, 'r');\n    try {\n      bytes = new Buffer(max_bytes);\n      size = fs.readSync(descriptor, bytes, 0, bytes.length, 0);\n    } finally {\n      fs.closeSync(descriptor);\n    }\n  }\n  // async version has a function instead of a `size`\n  else if (typeof size === \"function\") {\n    var file = bytes, callback = size;\n    fs.stat(file, function(err, stat) {\n      if (err || !stat.isFile()) return callback(null, false);\n\n      fs.open(file, 'r', function(err, descriptor){\n        if (err) return callback(err);\n        var bytes = new Buffer(max_bytes);\n        // Read the file with no encoding for raw buffer access.\n        fs.read(descriptor, bytes, 0, bytes.length, 0, function(err, size, bytes){\n          fs.close(descriptor, function(err2){\n            if (err || err2)\n              return callback(err || err2);\n            return callback(null, isBinaryCheck(bytes, size));\n          });\n        });\n      });\n    });\n  }\n\n  return isBinaryCheck(bytes, size);\n}\n\nfunction isBinaryCheck(bytes, size) {\n  if (size === 0)\n    return false;\n\n  var suspicious_bytes = 0;\n  var total_bytes = Math.min(size, max_bytes);\n\n  if (size >= 3 && bytes[0] == 0xEF && bytes[1] == 0xBB && bytes[2] == 0xBF) {\n    // UTF-8 BOM. This isn't binary.\n    return false;\n  }\n\n  for (var i = 0; i < total_bytes; i++) {\n    if (bytes[i] === 0) { // NULL byte--it's binary!\n      return true;\n    }\n    else if ((bytes[i] < 7 || bytes[i] > 14) && (bytes[i] < 32 || bytes[i] > 127)) {\n      // UTF-8 detection\n      if (bytes[i] > 193 && bytes[i] < 224 && i + 1 < total_bytes) {\n        i++;\n        if (bytes[i] > 127 && bytes[i] < 192) {\n          continue;\n        }\n      }\n      else if (bytes[i] > 223 && bytes[i] < 240 && i + 2 < total_bytes) {\n        i++;\n        if (bytes[i] > 127 && bytes[i] < 192 && bytes[i + 1] > 127 && bytes[i + 1] < 192) {\n          i++;\n          continue;\n        }\n      }\n      suspicious_bytes++;\n      // Read at least 32 bytes before making a decision\n      if (i > 32 && (suspicious_bytes * 100) / total_bytes > 10) {\n        return true;\n      }\n    }\n  }\n\n  if ((suspicious_bytes * 100) / total_bytes > 10) {\n    return true;\n  }\n\n  return false;\n}\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/tools/Config.js":"/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\nvar util    = require('util');\n\n/**\n * Validator of configured file / commander options.\n */\nvar Config = module.exports = {\n  _errMsgs: {\n    'require': '\"%s\" is required',\n    'type'   : 'Expect \"%s\" to be a typeof %s, but now is %s',\n    'regex'  : 'Verify \"%s\" with regex failed, %s',\n    'max'    : 'The maximum of \"%s\" is %s, but now is %s',\n    'min'    : 'The minimum of \"%s\" is %s, but now is %s'\n  },\n  /**\n   * Schema definition.\n   * @returns {exports|*}\n   */\n  get schema(){\n    // Cache.\n    if (this._schema) {\n      return this._schema;\n    }\n    // Render aliases.\n    this._schema = require('../API/schema');\n    for (var k in this._schema) {\n      if (k.indexOf('\\\\') > 0) {\n        continue;\n      }\n      var aliases = [\n        k.split('_').map(function(n, i){\n          if (i != 0 && n && n.length > 1) {\n            return n[0].toUpperCase() + n.slice(1);\n          }\n          return n;\n        }).join('')\n      ];\n\n      if (this._schema[k].alias && Array.isArray(this._schema[k].alias)) {\n        // If multiple aliases, merge\n        this._schema[k].alias.forEach(function(alias) {\n          aliases.splice(0, 0, alias);\n        });\n      }\n      else if (this._schema[k].alias)\n        aliases.splice(0, 0, this._schema[k].alias);\n\n      this._schema[k].alias = aliases;\n    }\n    return this._schema;\n  }\n};\n\n/**\n * Transform commander options to app config.\n * @param {Commander} cmd\n * @returns {{}}\n */\nConfig.transCMDToConf = function(cmd){\n  var conf = {}, defines = this.schema;\n  // Wrap.\n  for(var k in defines){\n    var aliases = defines[k].alias;\n    aliases && aliases.forEach(function(alias){\n      //if (cmd[alias]) {\n        conf[k] || (conf[k] = cmd[alias]);\n      //}\n    });\n  }\n  return conf;\n};\n\n/**\n * Verify JSON configurations.\n * @param {Object} json\n * @returns {{errors: Array, config: {}}}\n */\nConfig.validateJSON = function(json){\n  // clone config\n  var conf = util._extend({}, json),\n      res = {};\n  this._errors = [];\n\n  var regexKeys = {}, defines = this.schema;\n\n  for (var sk in defines) {\n    // Pick up RegExp keys.\n    if (sk.indexOf('\\\\') >= 0) {\n      regexKeys[sk] = false;\n      continue;\n    }\n\n    var aliases = defines[sk].alias;\n\n    aliases && aliases.forEach(function(alias){\n      conf[sk] || (conf[sk] = json[alias]);\n    })\n\n    var val = conf[sk];\n    delete conf[sk];\n\n    // Validate key-value pairs.\n    if (val === undefined ||\n        val === null ||\n        ((val = this._valid(sk, val)) === null)) {\n\n      // If value is not defined\n      // Set default value (via schema.json)\n      if (typeof(defines[sk].default) !== 'undefined')\n        res[sk] = defines[sk].default;\n      continue;\n    }\n    //console.log(sk, val, val === null, val === undefined);\n    res[sk] = val;\n  }\n\n  // Validate RegExp values.\n  var hasRegexKey = false;\n  for (var k in regexKeys) {\n    hasRegexKey = true;\n    regexKeys[k] = new RegExp(k);\n  }\n  if (hasRegexKey) {\n    for (var k in conf) {\n      for (var rk in regexKeys) {\n        if (regexKeys[rk].test(k))\n          if (this._valid(k, conf[k], defines[rk])) {\n            res[k] = conf[k];\n            delete conf[k];\n          }\n      }\n    }\n  }\n\n  return {errors: this._errors, config: res};\n};\n\n/**\n * Validate key-value pairs by specific schema\n * @param {String} key\n * @param {Mixed} value\n * @param {Object} sch\n * @returns {*}\n * @private\n */\nConfig._valid = function(key, value, sch){\n  var sch = sch || this.schema[key],\n      scht = typeof sch.type == 'string' ? [sch.type] : sch.type;\n\n  // Required value.\n  var undef = typeof value == 'undefined';\n  if(this._error(sch.require && undef, 'require', key)){\n    return null;\n  }\n\n  // If undefined, make a break.\n  if (undef) {\n    return null;\n  }\n\n  // Wrap schema types.\n  scht = scht.map(function(t){\n    return '[object ' + t[0].toUpperCase() + t.slice(1) + ']'\n  });\n\n  // Typeof value.\n  var type = Object.prototype.toString.call(value), nt = '[object Number]';\n\n  // Auto parse Number\n  if (type != '[object Boolean]' && scht.indexOf(nt) >= 0 && !isNaN(value)) {\n    value = parseFloat(value);\n    type = nt;\n  }\n\n  // Verify types.\n  if (this._error(!~scht.indexOf(type), 'type', key, scht.join(' / '), type)) {\n    return null;\n  }\n\n  // Verify RegExp if exists.\n  if (this._error(type == '[object String]' && sch.regex && !(new RegExp(sch.regex)).test(value),\n      'regex', key, sch.desc || ('should match ' + sch.regex))) {\n    return null;\n  }\n\n  // Verify maximum / minimum of Number value.\n  if (type == '[object Number]') {\n    if (this._error(typeof sch.max != 'undefined' && value > sch.max, 'max', key, sch.max, value)) {\n      return null;\n    }\n    if (this._error(typeof sch.min != 'undefined' && value < sch.min, 'min', key, sch.min, value)) {\n      return null;\n    }\n  }\n\n  // If first type is Array, but current is String, try to split them.\n  if(scht.length > 1 && type != scht[0] && type == '[object String]'){\n    if(scht[0] == '[object Array]') {\n      // unfortunately, js does not support lookahead RegExp (/(?<!\\\\)\\s+/) now (until next ver).\n      value = value.split(/([\\w\\-]+\\=\"[^\"]*\")|([\\w\\-]+\\='[^']*')|\"([^\"]*)\"|'([^']*)'|\\s/)\n        .filter(function(v){\n          return v && v.trim();\n        });\n    }\n  }\n\n  // Custom types: sbyte && stime.\n  if(sch.ext_type && type == '[object String]' && value.length >= 2) {\n    var seed = {\n      'sbyte': {\n        'G': 1024 * 1024 * 1024,\n        'M': 1024 * 1024,\n        'K': 1024\n      },\n      'stime': {\n        'h': 60 * 60 * 1000,\n        'm': 60 * 1000,\n        's': 1000\n      }\n    }[sch.ext_type];\n\n    if(seed){\n      value = parseFloat(value.slice(0, -1)) * (seed[value.slice(-1)]);\n    }\n  }\n  return value;\n};\n\n/**\n * Wrap errors.\n * @param {Boolean} possible A value indicates whether it is an error or not.\n * @param {String} type\n * @returns {*}\n * @private\n */\nConfig._error = function(possible, type){\n  if (possible) {\n    var args = Array.prototype.slice.call(arguments);\n    args.splice(0, 2, this._errMsgs[type]);\n    this._errors && this._errors.push(util.format.apply(null, args));\n  }\n  return possible;\n}\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/Interactor/InteractorDaemonizer.js":"/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\n\n'use strict';\n\nvar debug  = require('debug')('pm2:interface:daemon');\nvar fs     = require('fs');\nvar path   = require('path');\nvar util   = require('util');\nvar rpc    = require('pm2-axon-rpc');\nvar axon   = require('pm2-axon');\nvar chalk  = require('chalk');\nvar os     = require('os');\nvar cst    = require('../../constants.js');\nvar Common = require('../Common');\nvar json5  = require('../tools/json5.js');\nvar UX     = require('../API/CliUx.js');\n\nvar InteractorDaemonizer        = module.exports = {};\n\nInteractorDaemonizer.rpc = {};\n\n/**\n * Description\n * @method ping\n * @param {} cb\n * @return\n */\nInteractorDaemonizer.ping = function(conf, cb) {\n  var req = axon.socket('req');\n  var client = new rpc.Client(req);\n\n  debug('[PING INTERACTOR] Trying to connect to Interactor daemon');\n\n  client.sock.once('reconnect attempt', function() {\n    client.sock.close();\n    debug('Interactor Daemon not launched');\n    return cb(false);\n  });\n\n  client.sock.once('connect', function() {\n    client.sock.once('close', function() {\n      return cb(true);\n    });\n    client.sock.close();\n    debug('Interactor Daemon alive');\n  });\n\n  req.connect(conf.INTERACTOR_RPC_PORT);\n};\n\nInteractorDaemonizer.killInteractorDaemon = function(conf, cb) {\n  process.env.PM2_INTERACTOR_PROCESSING = true;\n\n  debug('Killing interactor #1 ping');\n  InteractorDaemonizer.ping(conf, function(online) {\n    debug('Interactor online', online);\n\n    if (!online) {\n      if (!cb) Common.printError('Interactor not launched');\n\n      return cb(new Error('Interactor not launched'));\n    }\n\n    InteractorDaemonizer.launchRPC(conf, function(err, data) {\n      if (err) {\n        setTimeout(function() {\n          InteractorDaemonizer.disconnectRPC(cb);\n        }, 100);\n        return false;\n      }\n      InteractorDaemonizer.rpc.kill(function(err) {\n        if (err) Common.printError(err);\n        setTimeout(function() {\n          InteractorDaemonizer.disconnectRPC(cb);\n        }, 100);\n      });\n      return false;\n    });\n    return false;\n  });\n};\n\n/**\n * Description\n * @method launchRPC\n * @param {} cb\n * @return\n */\nInteractorDaemonizer.launchRPC = function(conf, cb) {\n  var self    = this;\n  var req     = axon.socket('req');\n  this.client = new rpc.Client(req);\n\n  debug('Generating methods');\n\n  /**\n   * Description\n   * @method generateMethods\n   * @param {} cb\n   * @return\n   */\n  var generateMethods = function(cb) {\n    self.client.methods(function(err, methods) {\n      Object.keys(methods).forEach(function(key) {\n        var method_signature = methods[key];\n        debug('+-- Creating %s method', method_signature.name);\n\n        (function(name) {\n          /**\n           * Description\n           * @method name\n           * @return\n           */\n          self.rpc[name] = function() {\n            var args = Array.prototype.slice.call(arguments);\n            args.unshift(name);\n            self.client.call.apply(self.client, args);\n          };\n        })(method_signature.name);\n\n      });\n      return cb();\n    });\n  };\n\n  this.client.sock.once('reconnect attempt', function(e) {\n    self.client.sock.removeAllListeners();\n    return cb({success:false, msg:'reconnect attempt'});\n  });\n\n  this.client.sock.once('error', function(e) {\n    console.error('Error in error catch all on Interactor');\n    console.error(e.stack || e);\n  });\n\n  this.client.sock.once('connect', function() {\n    self.client.sock.removeAllListeners();\n    generateMethods(function() {\n      debug('Methods generated');\n      cb(null, {success:true});\n    });\n  });\n\n  this.client_sock = req.connect(conf.INTERACTOR_RPC_PORT);\n};\n\n/**\n * Description\n * @method launchOrAttach\n * @param {} secret_key\n * @param {} public_key\n * @param {} machine_name\n * @param {} cb\n * @return\n */\nfunction launchOrAttach(conf, infos, cb) {\n  InteractorDaemonizer.ping(conf, function(online) {\n    if (online) {\n      debug('Interactor online, restarting it...');\n      InteractorDaemonizer.launchRPC(conf, function() {\n        InteractorDaemonizer.rpc.kill(function(err) {\n          daemonize(conf, infos, function(err, msg, proc) {\n            return cb(err, msg, proc);\n          });\n        });\n      });\n    }\n    else {\n      debug('Interactor offline, launching it...');\n      daemonize(conf, infos, function(err, msg, proc) {\n        return cb(err, msg, proc);\n      });\n    }\n    return false;\n  });\n};\n\n/**\n * Description\n * @method daemonize\n * @param {} secret_key\n * @param {} public_key\n * @param {} machine_name\n * @param {} cb\n * @return\n */\nvar daemonize = function(conf, infos, cb) {\n  var InteractorJS = path.resolve(path.dirname(module.filename), 'Daemon.js');\n\n  var out = null;\n  var err = null;\n\n  if (process.env.TRAVIS || process.env.NODE_ENV == 'local_test') {\n    // Redirect PM2 internal err and out\n    // to STDERR STDOUT when running with Travis\n    out = 1;\n    err = 2;\n  }\n  else {\n    out = fs.openSync(conf.INTERACTOR_LOG_FILE_PATH, 'a');\n    err = fs.openSync(conf.INTERACTOR_LOG_FILE_PATH, 'a');\n  }\n\n  var child = require('child_process').spawn('node', [InteractorJS], {\n    silent     : false,\n    detached   : true,\n    cwd        : process.cwd(),\n    env        : util._extend({\n      PM2_HOME             : conf.PM2_HOME,\n      PM2_MACHINE_NAME     : infos.machine_name,\n      PM2_SECRET_KEY       : infos.secret_key,\n      PM2_PUBLIC_KEY       : infos.public_key,\n      PM2_REVERSE_INTERACT : infos.reverse_interact,\n      KEYMETRICS_NODE      : infos.info_node\n    }, process.env),\n    stdio      : ['ipc', out, err]\n  });\n\n  UX.processing.start();\n\n  fs.writeFileSync(conf.INTERACTOR_PID_PATH, child.pid);\n\n  function onError(msg) {\n    debug('Error when launching Interactor, please check the agent logs');\n    return cb(msg);\n  }\n\n  child.once('error', onError);\n\n  child.unref();\n\n  child.once('message', function(msg) {\n    debug('Interactor daemon launched', msg);\n\n    UX.processing.stop();\n\n    if (msg.debug) {\n      return cb(null, msg, child);\n    }\n\n    child.removeAllListeners('error');\n    child.disconnect();\n\n    /*****************\n     * Error messages\n     */\n    if (msg.error == true) {\n      console.log(chalk.red('[Keymetrics.io][ERROR]'), msg.msg);\n      console.log(chalk.cyan('[Keymetrics.io]') + ' Contact support contact@keymetrics.io and send us the error message');\n      return cb(msg);\n    }\n\n    if (msg.km_data.disabled == true) {\n      console.log(chalk.cyan('[Keymetrics.io]') + ' Server DISABLED BY ADMINISTRATION contact support contact@keymetrics.io with reference to your public and secret keys)');\n      return cb(msg);\n    }\n\n    if (msg.km_data.error == true) {\n      console.log(chalk.red('[Keymetrics.io][ERROR]') + ' ' + msg.km_data.msg + ' (Public: %s) (Secret: %s) (Machine name: %s)', msg.public_key, msg.secret_key, msg.machine_name);\n      return cb(msg);\n    }\n\n    else if (msg.km_data.active == false && msg.km_data.pending == true) {\n      console.log(chalk.red('[Keymetrics.io]') + ' ' + chalk.bold.red('Agent PENDING') + ' - Web Access: https://app.keymetrics.io/');\n      console.log(chalk.red('[Keymetrics.io]') + ' You must upgrade your bucket in order to monitor more servers.');\n\n      return cb(msg);\n    }\n\n    if (msg.km_data.active == true) {\n      console.log(chalk.cyan('[Keymetrics.io]') + ' [%s] Agent ACTIVE - Web Access: https://app.keymetrics.io/',\n                  msg.km_data.new ? 'Agent created' : 'Agent updated');\n      return cb(null, msg, child);\n    }\n\n    return cb(null, msg, child);\n  });\n\n};\n\nInteractorDaemonizer.update = function(conf, cb) {\n  InteractorDaemonizer.ping(conf, function(online) {\n    if (!online) {\n      Common.printError('Interactor not launched');\n      return cb(new Error('Interactor not launched'));\n    }\n    InteractorDaemonizer.launchRPC(conf, function() {\n      InteractorDaemonizer.rpc.kill(function(err) {\n        if (err) {\n          Common.printError(err);\n          return cb(new Error(err));\n        }\n        Common.printOut('Interactor successfully killed');\n        setTimeout(function() {\n          InteractorDaemonizer.launchAndInteract(conf, {}, function() {\n            return cb(null, {msg : 'Daemon launched'});\n          });\n        }, 500);\n      });\n    });\n    return false;\n  });\n};\n\n/**\n * Get/Update/Merge agent configuration\n * @param {object} _infos\n */\nInteractorDaemonizer.getOrSetConf = function(conf, infos, cb) {\n  var reverse_interact = true;\n  var version_management_active = true;\n  var version_management_password = null;\n  var secret_key;\n  var public_key;\n  var machine_name;\n  var info_node;\n  var new_connection = false;\n\n  // 1# Load configuration file\n  try {\n    var interaction_conf     = json5.parse(fs.readFileSync(conf.INTERACTION_CONF));\n\n    public_key       = interaction_conf.public_key;\n    machine_name     = interaction_conf.machine_name;\n    secret_key       = interaction_conf.secret_key;\n    info_node        = interaction_conf.info_node;\n\n    reverse_interact = interaction_conf.reverse_interact || true;\n\n    if (interaction_conf.version_management) {\n      version_management_password = interaction_conf.version_management.password || version_management_password;\n      version_management_active   = interaction_conf.version_management.active   || version_management_active;\n    }\n  } catch (e) {\n    debug('Interaction file does not exists');\n  }\n\n  // 2# Override with passed informations\n  if (infos) {\n    if (infos.secret_key)\n      secret_key = infos.secret_key;\n\n    if (infos.public_key)\n      public_key = infos.public_key;\n\n    if (infos.machine_name)\n      machine_name = infos.machine_name;\n\n    if (infos.info_node)\n      info_node = infos.info_node;\n\n    new_connection = true;\n  }\n\n  // 3# Override with environment variables (highest-priority conf)\n  if (process.env.PM2_SECRET_KEY || process.env.KEYMETRICS_SECRET)\n    secret_key = process.env.PM2_SECRET_KEY || process.env.KEYMETRICS_SECRET;\n\n  if (process.env.PM2_PUBLIC_KEY || process.env.KEYMETRICS_PUBLIC)\n    public_key = process.env.PM2_PUBLIC_KEY || process.env.KEYMETRICS_PUBLIC;\n\n  if (new_connection && info_node == null)\n    info_node = process.env.KEYMETRICS_NODE || cst.KEYMETRICS_ROOT_URL;\n\n  if (!info_node)\n    info_node = cst.KEYMETRICS_ROOT_URL;\n\n  if (!secret_key)\n    return cb(new Error('secret key is not defined'));\n\n  if (!public_key)\n    return cb(new Error('public key is not defined'));\n\n  if (!machine_name)\n    machine_name = os.hostname();\n\n  /**\n   * Write new data to configuration file\n   */\n  try {\n    var new_interaction_conf = {\n      secret_key   : secret_key,\n      public_key   : public_key,\n      machine_name : machine_name,\n      reverse_interact : reverse_interact,\n      info_node : info_node,\n      version_management : {\n        active   : version_management_active,\n        password : version_management_password\n      }\n    };\n    fs.writeFileSync(conf.INTERACTION_CONF, json5.stringify(new_interaction_conf, null, 4));\n  } catch(e) {\n    console.error('Error when writting configuration file %s', conf.INTERACTION_CONF);\n    return cb(e);\n  }\n\n  // Don't block the event loop\n  process.nextTick(function() {\n    cb(null, new_interaction_conf);\n  });\n};\n\nInteractorDaemonizer.disconnectRPC = function(cb) {\n  if (!InteractorDaemonizer.client_sock ||\n      !InteractorDaemonizer.client_sock.close)\n    return cb(null, {\n      success : false,\n      msg : 'RPC connection to Interactor Daemon is not launched'\n    });\n\n  if (InteractorDaemonizer.client_sock.connected === false ||\n      InteractorDaemonizer.client_sock.closing === true) {\n    return cb(null, {\n      success : false,\n      msg : 'RPC closed'\n    });\n  }\n\n  try {\n    var timer;\n\n    debug('Closing RPC INTERACTOR');\n\n    InteractorDaemonizer.client_sock.once('close', function() {\n      debug('RPC INTERACTOR cleanly closed');\n      clearTimeout(timer);\n      return cb ? cb(null, {success:true}) : false;\n    });\n\n    timer = setTimeout(function() {\n      if (InteractorDaemonizer.client_sock.destroy)\n        InteractorDaemonizer.client_sock.destroy();\n      return cb ? cb(null, {success:true}) : false;\n    }, 200);\n\n    InteractorDaemonizer.client_sock.close();\n  } catch(e) {\n    debug('Error while closing RPC INTERACTOR', e.stack || e);\n    return cb ? cb(e.stack || e) : false;\n  }\n  return false;\n};\n\nInteractorDaemonizer.rescueStart = function(conf, cb) {\n  InteractorDaemonizer.getOrSetConf(conf, null, function(err, infos)  {\n    if (err || !infos) {\n      return cb(err);\n    }\n\n    console.log(chalk.cyan('[Keymetrics.io]') + ' Using (Public key: %s) (Private key: %s)', infos.public_key, infos.secret_key);\n\n    daemonize(conf, infos, function(err, msg, proc) {\n      return cb(err, msg, proc);\n    });\n  });\n};\n\nInteractorDaemonizer.launchAndInteract = function(conf, opts, cb) {\n  // For Watchdog\n  if (process.env.PM2_AGENT_ONLINE) {\n    return process.nextTick(cb);\n  }\n\n  process.env.PM2_INTERACTOR_PROCESSING = true;\n\n  this.getOrSetConf(conf, opts, function(err, data)  {\n    if (err || !data) {\n      return cb(err);\n    }\n\n    console.log(chalk.cyan('[Keymetrics.io]') + ' Using (Public key: %s) (Private key: %s)', data.public_key, data.secret_key);\n\n    launchOrAttach(conf, data, function(err, msg, proc) {\n      if (err)\n        return cb(err);\n      return cb(null, msg, proc);\n    });\n    return false;\n  });\n};\n\n/**\n * Description\n * @method getInteractInfo\n * @param {} cb\n * @return\n */\nInteractorDaemonizer.getInteractInfo = function(conf, cb) {\n  debug('Getting interaction info');\n  if (process.env.PM2_NO_INTERACTION) return;\n  InteractorDaemonizer.ping(conf, function(online) {\n    if (!online) {\n      return cb(new Error('Interactor is offline'));\n    }\n    InteractorDaemonizer.launchRPC(conf, function() {\n      InteractorDaemonizer.rpc.getInfos(function(err, infos) {\n        if (err)\n          return cb(err);\n\n        // Avoid general CLI to interfere with Keymetrics CLI commands\n        if (process.env.PM2_INTERACTOR_PROCESSING)\n          return cb(null, infos);\n\n        InteractorDaemonizer.disconnectRPC(function() {\n          return cb(null, infos);\n        });\n        return false;\n      });\n    });\n    return false;\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2-axon-rpc/index.js":"\nexports.Server = require('./lib/server');\nexports.Client = require('./lib/client');","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2-axon-rpc/lib/server.js":"\n/**\n * Module dependencies.\n */\n\nvar debug = require('debug');\nvar clone = require('fclone');\n\n/**\n * Expose `Server`.\n */\n\nmodule.exports = Server;\n\n/**\n * Initialize a server with the given `sock`.\n *\n * @param {Socket} sock\n * @api public\n */\n\nfunction Server(sock) {\n  if (typeof sock.format === 'function') sock.format('json');\n  this.sock = sock;\n  this.methods = {};\n  this.sock.on('message', this.onmessage.bind(this));\n}\n\n/**\n * Return method descriptions with:\n *\n *  `.name` string\n *  `.params` array\n *\n * @return {Object}\n * @api private\n */\n\nServer.prototype.methodDescriptions = function(){\n  var obj = {};\n  var fn;\n\n  for (var name in this.methods) {\n    fn = this.methods[name];\n    obj[name] = {\n      name: name,\n      params: params(fn)\n    };\n  }\n\n  return obj;\n};\n\n/**\n * Response with the method descriptions.\n *\n * @param {Function} fn\n * @api private\n */\n\nServer.prototype.respondWithMethods = function(reply){\n  reply({ methods: this.methodDescriptions() });\n};\n\n/**\n * Handle `msg`.\n *\n * @param {Object} msg\n * @param {Object} fn\n * @api private\n */\n\nServer.prototype.onmessage = function(msg, reply){\n  if ('methods' == msg.type) return this.respondWithMethods(reply);\n\n  if (!reply) {\n    console.error('reply false');\n    return false;\n  }\n\n  // .method\n  var meth = msg.method;\n  if (!meth) return reply({ error: '.method required' });\n\n  // ensure .method is exposed\n  var fn = this.methods[meth];\n  if (!fn) return reply({ error: 'method \"' + meth + '\" does not exist' });\n\n  // .args\n  var args = msg.args;\n  if (!args) return reply({ error: '.args required' });\n\n  // invoke\n  args.push(function(err){\n    if (err) {\n      if (err instanceof Error)\n        return reply({ error: err.message, stack: err.stack });\n      else\n        return reply({error : err});\n    }\n    var args = [].slice.call(arguments, 1);\n    reply({ args: args });\n  });\n\n  fn.apply(null, args);\n};\n\n/**\n * Expose many or a single method.\n *\n * @param {String|Object} name\n * @param {String|Object} fn\n * @api public\n */\n\nServer.prototype.expose = function(name, fn){\n  if (1 == arguments.length) {\n    for (var key in name) {\n      this.expose(key, name[key]);\n    }\n  } else {\n    debug('expose \"%s\"', name);\n    this.methods[name] = fn;\n  }\n};\n\n/**\n * Parse params.\n *\n * @param {Function} fn\n * @return {Array}\n * @api private\n */\n\nfunction params(fn) {\n  var ret = fn.toString().match(/^function *(\\w*)\\((.*?)\\)/)[2];\n  if (ret) return ret.split(/ *, */);\n  return [];\n}\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2-axon-rpc/node_modules/fclone/dist/fclone.js":"(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD\n        define('fclone', [], factory);\n    } else if (typeof module === 'object' && module.exports) {\n\t\t\t  //node\n        module.exports = factory();\n    } else {\n        // Browser globals (root is window)\n        root.fclone = factory();\n    }\n}(this, function () {\n  'use strict';\n\n// see if it looks and smells like an iterable object, and do accept length === 0\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nfunction isArrayLike(item) {\n  if (Array.isArray(item)) return true;\n\n  var len = item && item.length;\n  return typeof len === 'number' && (len === 0 || len - 1 in item) && typeof item.indexOf === 'function';\n}\n\nfunction fclone(obj, refs) {\n  if (!obj || \"object\" !== (typeof obj === 'undefined' ? 'undefined' : _typeof(obj))) return obj;\n\n  if (obj instanceof Date) {\n    return new Date(obj);\n  }\n\n  if (typeof Buffer !== 'undefined' && Buffer.isBuffer(obj)) {\n    return new Buffer(obj);\n  }\n\n  // typed array\n  switch (Object.prototype.toString.call(obj)) {\n    case '[object Uint8Array]':\n    case '[object Uint8ClampedArray]':\n    case '[object Uint16Array]':\n    case '[object Uint32Array]':\n    case '[object Int8Array]':\n    case '[object Int16Array]':\n    case '[object Int32Array]':\n    case '[object Float32Array]':\n    case '[object Float64Array]':\n      return obj.subarray(0);\n  }\n\n  if (!refs) {\n    refs = [];\n  }\n\n  if (isArrayLike(obj)) {\n    refs[refs.length] = obj;\n    var _l = obj.length;\n    var i = -1;\n    var _copy = [];\n\n    while (_l > ++i) {\n      _copy[i] = ~refs.indexOf(obj[i]) ? '[Circular]' : fclone(obj[i], refs);\n    }\n\n    refs.length && refs.length--;\n    return _copy;\n  }\n\n  refs[refs.length] = obj;\n  var copy = {};\n\n  if (obj instanceof Error) {\n    copy.name = obj.name;\n    copy.message = obj.message;\n    copy.stack = obj.stack;\n  }\n\n  var keys = Object.keys(obj);\n  var l = keys.length;\n\n  while (l--) {\n    var k = keys[l];\n    copy[k] = ~refs.indexOf(obj[k]) ? '[Circular]' : fclone(obj[k], refs);\n  }\n\n  refs.length && refs.length--;\n  return copy;\n}\n  return fclone\n}));","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2-axon-rpc/lib/client.js":"\n/**\n * Expose `Client`.\n */\n\nmodule.exports = Client;\n\n/**\n * Initialize an rpc client with `sock`.\n *\n * @param {Socket} sock\n * @api public\n */\n\nfunction Client(sock) {\n  if (typeof sock.format === 'function') sock.format('json');\n  this.sock = sock;\n}\n\n/**\n * Invoke method `name` with args and invoke the\n * tailing callback function.\n *\n * @param {String} name\n * @param {Mixed} ...\n * @param {Function} fn\n * @api public\n */\n\nClient.prototype.call = function(name){\n  var args = [].slice.call(arguments, 1, -1);\n  var fn = arguments[arguments.length - 1];\n\n  this.sock.send({\n    type: 'call',\n    method: name,\n    args: args\n  }, function(msg){\n    if ('error' in msg) {\n      var err = new Error(msg.error);\n      err.stack = msg.stack || err.stack;\n      fn(err);\n    } else {\n      msg.args.unshift(null);\n      fn.apply(null, msg.args);\n    }\n  });\n};\n\n/**\n * Fetch the methods exposed and invoke `fn(err, methods)`.\n *\n * @param {Function} fn\n * @api public\n */\n\nClient.prototype.methods = function(fn){\n  this.sock.send({\n    type: 'methods'\n  }, function(msg){\n    fn(null, msg.methods);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2-axon/index.js":"\nmodule.exports = require('./lib');\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2-axon/lib/index.js":"\n/**\n * Constructors.\n */\n\nexports.PubEmitterSocket = require('./sockets/pub-emitter');\nexports.SubEmitterSocket = require('./sockets/sub-emitter');\nexports.PushSocket = require('./sockets/push');\nexports.PullSocket = require('./sockets/pull');\nexports.PubSocket = require('./sockets/pub');\nexports.SubSocket = require('./sockets/sub');\nexports.ReqSocket = require('./sockets/req');\nexports.RepSocket = require('./sockets/rep');\nexports.Socket = require('./sockets/sock');\n\n/**\n * Socket types.\n */\n\nexports.types = {\n  'pub-emitter': exports.PubEmitterSocket,\n  'sub-emitter': exports.SubEmitterSocket,\n  'push': exports.PushSocket,\n  'pull': exports.PullSocket,\n  'pub': exports.PubSocket,\n  'sub': exports.SubSocket,\n  'req': exports.ReqSocket,\n  'rep': exports.RepSocket\n};\n\n/**\n * Return a new socket of the given `type`.\n *\n * @param {String} type\n * @param {Object} options\n * @return {Socket}\n * @api public\n */\n\nexports.socket = function(type, options){\n  var fn = exports.types[type];\n  if (!fn) throw new Error('invalid socket type \"' + type + '\"');\n  return new fn(options);\n};\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2-axon/lib/sockets/pub-emitter.js":"\n/**\n * Module dependencies.\n */\n\nvar PubSocket = require('./pub');\n\n/**\n * Expose `SubPubEmitterSocket`.\n */\n\nmodule.exports = PubEmitterSocket;\n\n/**\n * Initialzie a new `PubEmitterSocket`.\n *\n * @api private\n */\n\nfunction PubEmitterSocket() {\n  this.sock = new PubSocket;\n  this.emit = this.sock.send.bind(this.sock);\n  this.bind = this.sock.bind.bind(this.sock);\n  this.connect = this.sock.connect.bind(this.sock);\n  this.close = this.sock.close.bind(this.sock);\n}\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2-axon/lib/sockets/pub.js":"\n/**\n * Module dependencies.\n */\n\nvar Socket = require('./sock');\nvar slice = require('../utils').slice;\n\n/**\n * Expose `PubSocket`.\n */\n\nmodule.exports = PubSocket;\n\n/**\n * Initialize a new `PubSocket`.\n *\n * @api private\n */\n\nfunction PubSocket() {\n  Socket.call(this);\n}\n\n/**\n * Inherits from `Socket.prototype`.\n */\n\nPubSocket.prototype.__proto__ = Socket.prototype;\n\n/**\n * Send `msg` to all established peers.\n *\n * @param {Mixed} msg\n * @api public\n */\n\nPubSocket.prototype.send = function(msg){\n  var socks = this.socks;\n  var len = socks.length;\n  var sock;\n\n  var buf = this.pack(arguments);\n\n  for (var i = 0; i < len; i++) {\n    sock = socks[i];\n    if (sock.writable) sock.write(buf);\n  }\n\n  return this;\n};\n\nPubSocket.prototype.sendv2 = function(data, cb){\n  var socks = this.socks;\n  var len = socks.length;\n  var sock;\n\n  if (len == 0)\n    return process.nextTick(cb);\n\n  var buf = this.pack([data]);\n\n  var i = 0;\n\n  socks.forEach(function(sock) {\n    if (sock.writable)\n      sock.write(buf, function() {\n        i++;\n        if (i == len)\n          process.nextTick(cb);\n      });\n    else {\n      i++;\n      if (i == len)\n        process.nextTick(cb);\n    }\n  });\n\n  return this;\n};\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2-axon/lib/sockets/sock.js":"\n/**\n * Module dependencies.\n */\n\nvar Emitter = require('events').EventEmitter;\nvar Configurable = require('../configurable');\nvar debug = require('debug')('axon:sock');\nvar Message = require('amp-message');\nvar Parser = require('amp').Stream;\nvar url = require('url');\nvar net = require('net');\nvar fs = require('fs');\n\n/**\n * Errors to ignore.\n */\n\nvar ignore = [\n  'ECONNREFUSED',\n  'ECONNRESET',\n  'ETIMEDOUT',\n  'EHOSTUNREACH',\n  'ENETUNREACH',\n  'ENETDOWN',\n  'EPIPE',\n  'ENOENT'\n];\n\n/**\n * Expose `Socket`.\n */\n\nmodule.exports = Socket;\n\n/**\n * Initialize a new `Socket`.\n *\n * A \"Socket\" encapsulates the ability of being\n * the \"client\" or the \"server\" depending on\n * whether `connect()` or `bind()` was called.\n *\n * @api private\n */\n\nfunction Socket() {\n  var self = this;\n  this.opts = {};\n  this.server = null;\n  this.socks = [];\n  this.settings = {};\n  this.set('hwm', Infinity);\n  this.set('identity', String(process.pid));\n  this.set('retry timeout', 100);\n  this.set('retry max timeout', 5000);\n}\n\n/**\n * Inherit from `Emitter.prototype`.\n */\n\nSocket.prototype.__proto__ = Emitter.prototype;\n\n/**\n * Make it configurable `.set()` etc.\n */\n\nConfigurable(Socket.prototype);\n\n/**\n * Use the given `plugin`.\n *\n * @param {Function} plugin\n * @api private\n */\n\nSocket.prototype.use = function(plugin){\n  plugin(this);\n  return this;\n};\n\n/**\n * Creates a new `Message` and write the `args`.\n *\n * @param {Array} args\n * @return {Buffer}\n * @api private\n */\n\nSocket.prototype.pack = function(args){\n  var msg = new Message(args);\n  return msg.toBuffer();\n};\n\n/**\n * Close all open underlying sockets.\n *\n * @api private\n */\n\nSocket.prototype.closeSockets = function(){\n  debug('closing %d connections', this.socks.length);\n  this.socks.forEach(function(sock){\n    sock.destroy();\n  });\n};\n\n/**\n * Close the socket.\n *\n * Delegates to the server or clients\n * based on the socket `type`.\n *\n * @param {Function} [fn]\n * @api public\n */\n\nSocket.prototype.close = function(fn){\n  debug('closing');\n  this.closing = true;\n  this.closeSockets();\n  if (this.server) this.closeServer(fn);\n};\n\n/**\n * Close the server.\n *\n * @param {Function} [fn]\n * @api public\n */\n\nSocket.prototype.closeServer = function(fn){\n  debug('closing server');\n  this.server.on('close', this.emit.bind(this, 'close'));\n  this.server.close();\n  fn && fn();\n};\n\n/**\n * Return the server address.\n *\n * @return {Object}\n * @api public\n */\n\nSocket.prototype.address = function(){\n  if (!this.server) return;\n  var addr = this.server.address();\n  addr.string = 'tcp://' + addr.address + ':' + addr.port;\n  return addr;\n};\n\n/**\n * Remove `sock`.\n *\n * @param {Socket} sock\n * @api private\n */\n\nSocket.prototype.removeSocket = function(sock){\n  var i = this.socks.indexOf(sock);\n  if (!~i) return;\n  debug('remove socket %d', i);\n  this.socks.splice(i, 1);\n};\n\n/**\n * Add `sock`.\n *\n * @param {Socket} sock\n * @api private\n */\n\nSocket.prototype.addSocket = function(sock){\n  var parser = new Parser;\n  var i = this.socks.push(sock) - 1;\n  debug('add socket %d', i);\n  sock.pipe(parser);\n  parser.on('data', this.onmessage(sock));\n};\n\n/**\n * Handle `sock` errors.\n *\n * Emits:\n *\n *  - `error` (err) when the error is not ignored\n *  - `ignored error` (err) when the error is ignored\n *  - `socket error` (err) regardless of ignoring\n *\n * @param {Socket} sock\n * @api private\n */\n\nSocket.prototype.handleErrors = function(sock){\n  var self = this;\n  sock.on('error', function(err){\n    debug('error %s', err.code || err.message);\n    self.emit('socket error', err);\n    self.removeSocket(sock);\n    if (!~ignore.indexOf(err.code)) return self.emit('error', err);\n    debug('ignored %s', err.code);\n    self.emit('ignored error', err);\n  });\n};\n\n/**\n * Handles framed messages emitted from the parser, by\n * default it will go ahead and emit the \"message\" events on\n * the socket. However, if the \"higher level\" socket needs\n * to hook into the messages before they are emitted, it\n * should override this method and take care of everything\n * it self, including emitted the \"message\" event.\n *\n * @param {net.Socket} sock\n * @return {Function} closure(msg, mulitpart)\n * @api private\n */\n\nSocket.prototype.onmessage = function(sock){\n  var self = this;\n  return function(buf){\n    var msg = new Message(buf);\n    self.emit.apply(self, ['message'].concat(msg.args), sock);\n  };\n};\n\n/**\n * Connect to `port` at `host` and invoke `fn()`.\n *\n * Defaults `host` to localhost.\n *\n * TODO: needs big cleanup\n *\n * @param {Number|String} port\n * @param {String} host\n * @param {Function} fn\n * @return {Socket}\n * @api public\n */\n\nSocket.prototype.connect = function(port, host, fn){\n  var self = this;\n  if ('server' == this.type) throw new Error('cannot connect() after bind()');\n  if ('function' == typeof host) fn = host, host = undefined;\n\n  if ('string' == typeof port) {\n    port = url.parse(port);\n\n    if (port.pathname) {\n      fn = host;\n      host = null;\n      fn = undefined;\n      port = port.pathname;\n    } else {\n      host = port.hostname || '0.0.0.0';\n      port = parseInt(port.port, 10);\n    }\n  } else {\n    host = host || '0.0.0.0';\n  }\n\n  var max = self.get('retry max timeout');\n  var sock = new net.Socket;\n  sock.setNoDelay();\n  this.type = 'client';\n  port = port;\n\n  this.handleErrors(sock);\n\n  sock.on('close', function(){\n    self.connected = false;\n    self.removeSocket(sock);\n    if (self.closing) return self.emit('close');\n    var retry = self.retry || self.get('retry timeout');\n    setTimeout(function(){\n      debug('attempting reconnect');\n      self.emit('reconnect attempt');\n      sock.destroy();\n      self.connect(port, host);\n      self.retry = Math.round(Math.min(max, retry * 1.5));\n    }, retry);\n  });\n\n  sock.on('connect', function(){\n    debug('connect');\n    self.connected = true;\n    self.addSocket(sock);\n    self.retry = self.get('retry timeout');\n    self.emit('connect');\n    fn && fn();\n  });\n\n  debug('connect attempt %s:%s', host, port);\n  sock.connect(port, host);\n  return this;\n};\n\n/**\n * Handle connection.\n *\n * @param {Socket} sock\n * @api private\n */\n\nSocket.prototype.onconnect = function(sock){\n  var self = this;\n  var addr = null;\n\n  if (sock.remoteAddress && sock.remotePort)\n    addr = sock.remoteAddress + ':' + sock.remotePort;\n  else if (sock.server && sock.server._pipeName)\n    addr = sock.server._pipeName;\n\n  debug('accept %s', addr);\n  this.addSocket(sock);\n  this.handleErrors(sock);\n  this.emit('connect', sock);\n  sock.on('close', function(){\n    debug('disconnect %s', addr);\n    self.emit('disconnect', sock);\n    self.removeSocket(sock);\n  });\n};\n\n/**\n * Bind to `port` at `host` and invoke `fn()`.\n *\n * Defaults `host` to INADDR_ANY.\n *\n * Emits:\n *\n *  - `connection` when a client connects\n *  - `disconnect` when a client disconnects\n *  - `bind` when bound and listening\n *\n * @param {Number|String} port\n * @param {Function} fn\n * @return {Socket}\n * @api public\n */\n\nSocket.prototype.bind = function(port, host, fn){\n  var self = this;\n  if ('client' == this.type) throw new Error('cannot bind() after connect()');\n  if ('function' == typeof host) fn = host, host = undefined;\n\n  var unixSocket = false;\n\n  if ('string' == typeof port) {\n    port = url.parse(port);\n\n    if (port.pathname) {\n      fn = host;\n      host = null;\n      port = port.pathname;\n      unixSocket = true;\n    } else {\n      host = port.hostname || '0.0.0.0';\n      port = parseInt(port.port, 10);\n    }\n  } else {\n    host = host || '0.0.0.0';\n  }\n\n  this.type = 'server';\n\n  this.server = net.createServer(this.onconnect.bind(this));\n\n  debug('bind %s:%s', host, port);\n  this.server.on('listening', this.emit.bind(this, 'bind'));\n\n  if (unixSocket) {\n    // TODO: move out\n    this.server.on('error', function(e) {\n      debug('Got error while trying to bind', e.stack || e);\n      if (e.code == 'EADDRINUSE') {\n        // Unix file socket and error EADDRINUSE is the case if\n        // the file socket exists. We check if other processes\n        // listen on file socket, otherwise it is a stale socket\n        // that we could reopen\n        // We try to connect to socket via plain network socket\n        var clientSocket = new net.Socket();\n\n        clientSocket.on('error', function(e2) {\n          debug('Got sub-error', e2);\n          if (e2.code == 'ECONNREFUSED' || e2.code == 'ENOENT') {\n            // No other server listening, so we can delete stale\n            // socket file and reopen server socket\n            try {\n              fs.unlinkSync(port);\n            } catch(e) {}\n            self.server.listen(port, host, fn);\n          }\n        });\n\n        clientSocket.connect({path: port}, function() {\n          // Connection is possible, so other server is listening\n          // on this file socket\n          if (fn) return fn(new Error('Process already listening on socket ' + port));\n        });\n      }\n      else {\n        try {\n          fs.unlinkSync(port);\n        } catch(e) {}\n        self.server.listen(port, host, fn);\n      }\n    });\n  }\n\n  this.server.listen(port, host, fn);\n  return this;\n};\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2-axon/lib/configurable/index.js":"\nmodule.exports = require('./lib/configurable');","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2-axon/lib/configurable/lib/configurable.js":"\n/**\n * Make `obj` configurable.\n *\n * @param {Object} obj\n * @return {Object} the `obj`\n * @api public\n */\n\nmodule.exports = function(obj){\n\n  obj.settings = {};\n\n  obj.set = function(name, val){\n    if (1 == arguments.length) {\n      for (var key in name) {\n        this.set(key, name[key]);\n      }\n    } else {\n      this.settings[name] = val;\n    }\n\n    return this;\n  };\n\n  obj.get = function(name){\n    return this.settings[name];\n  };\n\n  obj.enable = function(name){\n    return this.set(name, true);\n  };\n\n  obj.disable = function(name){\n    return this.set(name, false);\n  };\n\n  obj.enabled = function(name){\n    return !! this.get(name);\n  };\n\n  obj.disabled = function(name){\n    return ! this.get(name);\n  };\n\n  return obj;\n};","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2-axon/node_modules/debug/node.js":"\n/**\n * Module dependencies.\n */\n\nvar tty = require('tty');\nvar util = require('util');\n\n/**\n * This is the Node.js implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\n/**\n * The file descriptor to write the `debug()` calls to.\n * Set the `DEBUG_FD` env variable to override with another value. i.e.:\n *\n *   $ DEBUG_FD=3 node script.js 3>debug.log\n */\n\nvar fd = parseInt(process.env.DEBUG_FD, 10) || 2;\nvar stream = 1 === fd ? process.stdout :\n             2 === fd ? process.stderr :\n             createWritableStdioStream(fd);\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n  var debugColors = (process.env.DEBUG_COLORS || '').trim().toLowerCase();\n  if (0 === debugColors.length) {\n    return tty.isatty(fd);\n  } else {\n    return '0' !== debugColors\n        && 'no' !== debugColors\n        && 'false' !== debugColors\n        && 'disabled' !== debugColors;\n  }\n}\n\n/**\n * Map %o to `util.inspect()`, since Node doesn't do that out of the box.\n */\n\nvar inspect = (4 === util.inspect.length ?\n  // node <= 0.8.x\n  function (v, colors) {\n    return util.inspect(v, void 0, void 0, colors);\n  } :\n  // node > 0.8.x\n  function (v, colors) {\n    return util.inspect(v, { colors: colors });\n  }\n);\n\nexports.formatters.o = function(v) {\n  return inspect(v, this.useColors)\n    .replace(/\\s*\\n\\s*/g, ' ');\n};\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs() {\n  var args = arguments;\n  var useColors = this.useColors;\n  var name = this.namespace;\n\n  if (useColors) {\n    var c = this.color;\n\n    args[0] = '  \\u001b[3' + c + ';1m' + name + ' '\n      + '\\u001b[0m'\n      + args[0] + '\\u001b[3' + c + 'm'\n      + ' +' + exports.humanize(this.diff) + '\\u001b[0m';\n  } else {\n    args[0] = new Date().toUTCString()\n      + ' ' + name + ' ' + args[0];\n  }\n  return args;\n}\n\n/**\n * Invokes `console.error()` with the specified arguments.\n */\n\nfunction log() {\n  return stream.write(util.format.apply(this, arguments) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  if (null == namespaces) {\n    // If you set a process.env field to null or undefined, it gets cast to the\n    // string 'null' or 'undefined'. Just delete instead.\n    delete process.env.DEBUG;\n  } else {\n    process.env.DEBUG = namespaces;\n  }\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  return process.env.DEBUG;\n}\n\n/**\n * Copied from `node/src/node.js`.\n *\n * XXX: It's lame that node doesn't expose this API out-of-the-box. It also\n * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.\n */\n\nfunction createWritableStdioStream (fd) {\n  var stream;\n  var tty_wrap = process.binding('tty_wrap');\n\n  // Note stream._type is used for test-module-load-list.js\n\n  switch (tty_wrap.guessHandleType(fd)) {\n    case 'TTY':\n      stream = new tty.WriteStream(fd);\n      stream._type = 'tty';\n\n      // Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n\n    case 'FILE':\n      var fs = require('fs');\n      stream = new fs.SyncWriteStream(fd, { autoClose: false });\n      stream._type = 'fs';\n      break;\n\n    case 'PIPE':\n    case 'TCP':\n      var net = require('net');\n      stream = new net.Socket({\n        fd: fd,\n        readable: false,\n        writable: true\n      });\n\n      // FIXME Should probably have an option in net.Socket to create a\n      // stream from an existing fd which is writable only. But for now\n      // we'll just add this hack and set the `readable` member to false.\n      // Test: ./node test/fixtures/echo.js < /etc/passwd\n      stream.readable = false;\n      stream.read = null;\n      stream._type = 'pipe';\n\n      // FIXME Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n\n    default:\n      // Probably an error on in uv_guess_handle()\n      throw new Error('Implement me. Unknown stream file type!');\n  }\n\n  // For supporting legacy API we put the FD here.\n  stream.fd = fd;\n\n  stream._isStdio = true;\n\n  return stream;\n}\n\n/**\n * Enable namespaces listed in `process.env.DEBUG` initially.\n */\n\nexports.enable(load());\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2-axon/node_modules/debug/debug.js":"\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = debug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lowercased letter, i.e. \"n\".\n */\n\nexports.formatters = {};\n\n/**\n * Previously assigned color.\n */\n\nvar prevColor = 0;\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n *\n * @return {Number}\n * @api private\n */\n\nfunction selectColor() {\n  return exports.colors[prevColor++ % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction debug(namespace) {\n\n  // define the `disabled` version\n  function disabled() {\n  }\n  disabled.enabled = false;\n\n  // define the `enabled` version\n  function enabled() {\n\n    var self = enabled;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // add the `color` if not set\n    if (null == self.useColors) self.useColors = exports.useColors();\n    if (null == self.color && self.useColors) self.color = selectColor();\n\n    var args = Array.prototype.slice.call(arguments);\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %o\n      args = ['%o'].concat(args);\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    if ('function' === typeof exports.formatArgs) {\n      args = exports.formatArgs.apply(self, args);\n    }\n    var logFn = enabled.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n  enabled.enabled = true;\n\n  var fn = exports.enabled(namespace) ? enabled : disabled;\n\n  fn.namespace = namespace;\n\n  return fn;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  var split = (namespaces || '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2-axon/node_modules/ms/index.js":"/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options){\n  options = options || {};\n  if ('string' == typeof val) return parse(val);\n  return options.long\n    ? long(val)\n    : short(val);\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = '' + str;\n  if (str.length > 10000) return;\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n  if (!match) return;\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction short(ms) {\n  if (ms >= d) return Math.round(ms / d) + 'd';\n  if (ms >= h) return Math.round(ms / h) + 'h';\n  if (ms >= m) return Math.round(ms / m) + 'm';\n  if (ms >= s) return Math.round(ms / s) + 's';\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction long(ms) {\n  return plural(ms, d, 'day')\n    || plural(ms, h, 'hour')\n    || plural(ms, m, 'minute')\n    || plural(ms, s, 'second')\n    || ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) return;\n  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2-axon/lib/utils.js":"\n/**\n * Slice helper.\n *\n * @api private\n * @param {Arguments} args\n * @return {Array}\n */\n\nexports.slice = function(args){\n  var len = args.length;\n  var ret = new Array(len);\n\n  for (var i = 0; i < len; i++) {\n    ret[i] = args[i];\n  }\n\n  return ret;\n};","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2-axon/lib/sockets/sub-emitter.js":"\n/**\n * Module dependencies.\n */\n\nvar Message = require('amp-message');\nvar SubSocket = require('./sub');\n\n/**\n * Expose `SubEmitterSocket`.\n */\n\nmodule.exports = SubEmitterSocket;\n\n/**\n * Initialzie a new `SubEmitterSocket`.\n *\n * @api private\n */\n\nfunction SubEmitterSocket() {\n  this.sock = new SubSocket;\n  this.sock.onmessage = this.onmessage.bind(this);\n  this.bind = this.sock.bind.bind(this.sock);\n  this.connect = this.sock.connect.bind(this.sock);\n  this.close = this.sock.close.bind(this.sock);\n  this.listeners = [];\n}\n\n/**\n * Message handler.\n *\n * @param {net.Socket} sock\n * @return {Function} closure(msg, mulitpart)\n * @api private\n */\n\nSubEmitterSocket.prototype.onmessage = function(){\n  var listeners = this.listeners;\n  var self = this;\n\n  return function(buf){\n    var msg = new Message(buf);\n    var topic = msg.shift();\n\n    for (var i = 0; i < listeners.length; ++i) {\n      var listener = listeners[i];\n\n      var m = listener.re.exec(topic);\n      if (!m) continue;\n\n      listener.fn.apply(this, m.slice(1).concat(msg.args));\n    }\n  }\n};\n\n/**\n * Subscribe to `event` and invoke the given callback `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {SubEmitterSocket} self\n * @api public\n */\n\nSubEmitterSocket.prototype.on = function(event, fn){\n  var re = this.sock.subscribe(event);\n  this.listeners.push({\n    event: event,\n    re: re,\n    fn: fn\n  });\n  return this;\n};\n\n/**\n * Unsubscribe with the given `event`.\n *\n * @param {String} event\n * @return {SubEmitterSocket} self\n * @api public\n */\n\nSubEmitterSocket.prototype.off = function(event){\n  for (var i = 0; i < this.listeners.length; ++i) {\n    if (this.listeners[i].event === event) {\n      this.sock.unsubscribe(this.listeners[i].re);\n      this.listeners.splice(i--, 1);\n    }\n  }\n  return this;\n};\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2-axon/lib/sockets/sub.js":"\n/**\n * Module dependencies.\n */\n\nvar debug = require('debug')('axon:sub');\nvar escape = require('escape-regexp');\nvar Message = require('amp-message');\nvar Socket = require('./sock');\n\n/**\n * Expose `SubSocket`.\n */\n\nmodule.exports = SubSocket;\n\n/**\n * Initialize a new `SubSocket`.\n *\n * @api private\n */\n\nfunction SubSocket() {\n  Socket.call(this);\n  this.subscriptions = [];\n}\n\n/**\n * Inherits from `Socket.prototype`.\n */\n\nSubSocket.prototype.__proto__ = Socket.prototype;\n\n/**\n * Check if this socket has subscriptions.\n *\n * @return {Boolean}\n * @api public\n */\n\nSubSocket.prototype.hasSubscriptions = function(){\n  return !! this.subscriptions.length;\n};\n\n/**\n * Check if any subscriptions match `topic`.\n *\n * @param {String} topic\n * @return {Boolean}\n * @api public\n */\n\nSubSocket.prototype.matches = function(topic){\n  for (var i = 0; i < this.subscriptions.length; ++i) {\n    if (this.subscriptions[i].test(topic)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Message handler.\n *\n * @param {net.Socket} sock\n * @return {Function} closure(msg, mulitpart)\n * @api private\n */\n\nSubSocket.prototype.onmessage = function(sock){\n  var subs = this.hasSubscriptions();\n  var self = this;\n\n  return function(buf){\n    var msg = new Message(buf);\n\n    if (subs) {\n      var topic = msg.args[0];\n      if (!self.matches(topic)) return debug('not subscribed to \"%s\"', topic);\n    }\n\n    self.emit.apply(self, ['message'].concat(msg.args).concat(sock));\n  };\n};\n\n/**\n * Subscribe with the given `re`.\n *\n * @param {RegExp|String} re\n * @return {RegExp}\n * @api public\n */\n\nSubSocket.prototype.subscribe = function(re){\n  debug('subscribe to \"%s\"', re);\n  this.subscriptions.push(re = toRegExp(re));\n  return re;\n};\n\n/**\n * Unsubscribe with the given `re`.\n *\n * @param {RegExp|String} re\n * @api public\n */\n\nSubSocket.prototype.unsubscribe = function(re){\n  debug('unsubscribe from \"%s\"', re);\n  re = toRegExp(re);\n  for (var i = 0; i < this.subscriptions.length; ++i) {\n    if (this.subscriptions[i].toString() === re.toString()) {\n      this.subscriptions.splice(i--, 1);\n    }\n  }\n};\n\n/**\n * Clear current subscriptions.\n *\n * @api public\n */\n\nSubSocket.prototype.clearSubscriptions = function(){\n  this.subscriptions = [];\n};\n\n/**\n * Subscribers should not send messages.\n */\n\nSubSocket.prototype.send = function(){\n  throw new Error('subscribers cannot send messages');\n};\n\n/**\n * Convert `str` to a `RegExp`.\n *\n * @param {String} str\n * @return {RegExp}\n * @api private\n */\n\nfunction toRegExp(str) {\n  if (str instanceof RegExp) return str;\n  str = escape(str);\n  str = str.replace(/\\\\\\*/g, '(.+)');\n  return new RegExp('^' + str + '$');\n}\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2-axon/lib/sockets/push.js":"\n/**\n * Module dependencies.\n */\n\nvar roundrobin = require('../plugins/round-robin');\nvar queue = require('../plugins/queue');\nvar Socket = require('./sock');\n\n/**\n * Expose `PushSocket`.\n */\n\nmodule.exports = PushSocket;\n\n/**\n * Initialize a new `PushSocket`.\n *\n * @api private\n */\n\nfunction PushSocket() {\n  Socket.call(this);\n  this.use(queue());\n  this.use(roundrobin({ fallback: this.enqueue }));\n}\n\n/**\n * Inherits from `Socket.prototype`.\n */\n\nPushSocket.prototype.__proto__ = Socket.prototype;","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2-axon/lib/plugins/round-robin.js":"\n/**\n * Deps.\n */\n\nvar slice = require('../utils').slice;\n\n/**\n * Round-robin plugin.\n *\n * Provides a `send` method which will\n * write the `msg` to all connected peers.\n *\n * @param {Object} options\n * @api private\n */\n\nmodule.exports = function(options){\n  options = options || {};\n  var fallback = options.fallback || function(){};\n\n  return function(sock){\n\n    /**\n     * Bind callback to `sock`.\n     */\n\n    fallback = fallback.bind(sock);\n\n    /**\n     * Initialize counter.\n     */\n\n    var n = 0;\n\n    /**\n     * Sends `msg` to all connected peers round-robin.\n     */\n\n    sock.send = function(){\n      var socks = this.socks;\n      var len = socks.length;\n      var sock = socks[n++ % len];\n\n      var msg = slice(arguments);\n\n      if (sock && sock.writable) {\n        sock.write(this.pack(msg));\n      } else {\n        fallback(msg);\n      }\n    };\n\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2-axon/lib/plugins/queue.js":"\n/**\n * Module dependencies.\n */\n\nvar debug = require('debug')('axon:queue');\n\n/**\n * Queue plugin.\n *\n * Provides an `.enqueue()` method to the `sock`. Messages\n * passed to `enqueue` will be buffered until the next\n * `connect` event is emitted.\n *\n * Emits:\n *\n *  - `drop` (msg) when a message is dropped\n *  - `flush` (msgs) when the queue is flushed\n *\n * @param {Object} options\n * @api private\n */\n\nmodule.exports = function(options){\n  options = options || {};\n\n  return function(sock){\n\n    /**\n     * Message buffer.\n     */\n\n    sock.queue = [];\n\n    /**\n     * Flush `buf` on `connect`.\n     */\n\n    sock.on('connect', function(){\n      var prev = sock.queue;\n      var len = prev.length;\n      sock.queue = [];\n      debug('flush %d messages', len);\n\n      for (var i = 0; i < len; ++i) {\n        this.send.apply(this, prev[i]);\n      }\n\n      sock.emit('flush', prev);\n    });\n\n    /**\n     * Pushes `msg` into `buf`.\n     */\n\n    sock.enqueue = function(msg){\n      var hwm = sock.settings.hwm;\n      if (sock.queue.length >= hwm) return drop(msg);\n      sock.queue.push(msg);\n    };\n\n    /**\n     * Drop the given `msg`.\n     */\n\n    function drop(msg) {\n      debug('drop');\n      sock.emit('drop', msg);\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2-axon/lib/sockets/pull.js":"\n/**\n * Module dependencies.\n */\n\nvar Socket = require('./sock');\n\n/**\n * Expose `PullSocket`.\n */\n\nmodule.exports = PullSocket;\n\n/**\n * Initialize a new `PullSocket`.\n *\n * @api private\n */\n\nfunction PullSocket() {\n  Socket.call(this);\n  // TODO: selective reception\n}\n\n/**\n * Inherits from `Socket.prototype`.\n */\n\nPullSocket.prototype.__proto__ = Socket.prototype;\n\n/**\n * Pull sockets should not send messages.\n */\n\nPullSocket.prototype.send = function(){\n  throw new Error('pull sockets should not send messages');\n};\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2-axon/lib/sockets/req.js":"\n/**\n * Module dependencies.\n */\n\nvar debug = require('debug')('axon:req');\nvar queue = require('../plugins/queue');\nvar slice = require('../utils').slice;\nvar Message = require('amp-message');\nvar Socket = require('./sock');\n\n/**\n * Expose `ReqSocket`.\n */\n\nmodule.exports = ReqSocket;\n\n/**\n * Initialize a new `ReqSocket`.\n *\n * @api private\n */\n\nfunction ReqSocket() {\n  Socket.call(this);\n  this.n = 0;\n  this.ids = 0;\n  this.callbacks = {};\n  this.identity = this.get('identity');\n  this.use(queue());\n}\n\n/**\n * Inherits from `Socket.prototype`.\n */\n\nReqSocket.prototype.__proto__ = Socket.prototype;\n\n/**\n * Return a message id.\n *\n * @return {String}\n * @api private\n */\n\nReqSocket.prototype.id = function(){\n  return this.identity + ':' + this.ids++;\n};\n\n/**\n * Emits the \"message\" event with all message parts\n * after the null delimeter part.\n *\n * @param {net.Socket} sock\n * @return {Function} closure(msg, multipart)\n * @api private\n */\n\nReqSocket.prototype.onmessage = function(){\n  var self = this;\n\n  return function(buf){\n    var msg = new Message(buf);\n    var id = msg.pop();\n    var fn = self.callbacks[id];\n    if (!fn) return debug('missing callback %s', id);\n    fn.apply(null, msg.args);\n    delete self.callbacks[id];\n  };\n};\n\n/**\n * Sends `msg` to the remote peers. Appends\n * the null message part prior to sending.\n *\n * @param {Mixed} msg\n * @api public\n */\n\nReqSocket.prototype.send = function(msg){\n  var socks = this.socks;\n  var len = socks.length;\n  var sock = socks[this.n++ % len];\n  var args = slice(arguments);\n\n  if (sock) {\n    var hasCallback = 'function' == typeof args[args.length - 1];\n    if (!hasCallback) args.push(function(){});\n    var fn = args.pop();\n    fn.id = this.id();\n    this.callbacks[fn.id] = fn;\n    args.push(fn.id);\n  }\n\n  if (sock) {\n    sock.write(this.pack(args));\n  } else {\n    debug('no connected peers');\n    this.enqueue(args);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2-axon/lib/sockets/rep.js":"\n/**\n * Module dependencies.\n */\n\nvar slice = require('../utils').slice;\nvar debug = require('debug')('axon:rep');\nvar Message = require('amp-message');\nvar Socket = require('./sock');\n\n/**\n * Expose `RepSocket`.\n */\n\nmodule.exports = RepSocket;\n\n/**\n * Initialize a new `RepSocket`.\n *\n * @api private\n */\n\nfunction RepSocket() {\n  Socket.call(this);\n}\n\n/**\n * Inherits from `Socket.prototype`.\n */\n\nRepSocket.prototype.__proto__ = Socket.prototype;\n\n/**\n * Incoming.\n *\n * @param {net.Socket} sock\n * @return {Function} closure(msg, mulitpart)\n * @api private\n */\n\nRepSocket.prototype.onmessage = function(sock){\n  var self = this;\n\n  return function (buf){\n    var msg = new Message(buf);\n    var args = msg.args;\n\n    var id = args.pop();\n    args.unshift('message');\n    args.push(reply);\n    self.emit.apply(self, args);\n\n    function reply() {\n      var fn = function(){};\n      var args = slice(arguments);\n      args[0] = args[0] || null;\n\n      var hasCallback = 'function' == typeof args[args.length - 1];\n      if (hasCallback) fn = args.pop();\n\n      args.push(id);\n\n      if (sock.writable) {\n        sock.write(self.pack(args), function(){ fn(true) });\n        return true;\n      } else {\n        debug('peer went away');\n        process.nextTick(function(){ fn(false) });\n        return false;\n      }\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/tools/json5.js":"// json5.js\n// Modern JSON. See README.md for details.\n//\n// This file is based directly off of Douglas Crockford's json_parse.js:\n// https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js\n\nvar JSON5 = (typeof exports === 'object' ? exports : {});\n\nJSON5.parse = (function () {\n    \"use strict\";\n\n// This is a function that can parse a JSON5 text, producing a JavaScript\n// data structure. It is a simple, recursive descent parser. It does not use\n// eval or regular expressions, so it can be used as a model for implementing\n// a JSON5 parser in other languages.\n\n// We are defining the function inside of another function to avoid creating\n// global variables.\n\n    var at,     // The index of the current character\n        ch,     // The current character\n        escapee = {\n            \"'\":  \"'\",\n            '\"':  '\"',\n            '\\\\': '\\\\',\n            '/':  '/',\n            '\\n': '',       // Replace escaped newlines in strings w/ empty string\n            b:    '\\b',\n            f:    '\\f',\n            n:    '\\n',\n            r:    '\\r',\n            t:    '\\t'\n        },\n        ws = [\n            ' ',\n            '\\t',\n            '\\r',\n            '\\n',\n            '\\v',\n            '\\f',\n            '\\xA0',\n            '\\uFEFF'\n        ],\n        text,\n\n        error = function (m) {\n\n// Call error when something is wrong.\n\n            var error = new SyntaxError();\n            error.message = m;\n            error.at = at;\n            error.text = text;\n            throw error;\n        },\n\n        next = function (c) {\n\n// If a c parameter is provided, verify that it matches the current character.\n\n            if (c && c !== ch) {\n                error(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n            }\n\n// Get the next character. When there are no more characters,\n// return the empty string.\n\n            ch = text.charAt(at);\n            at += 1;\n            return ch;\n        },\n\n        peek = function () {\n\n// Get the next character without consuming it or\n// assigning it to the ch varaible.\n\n            return text.charAt(at);\n        },\n\n        identifier = function () {\n\n// Parse an identifier. Normally, reserved words are disallowed here, but we\n// only use this for unquoted object keys, where reserved words are allowed,\n// so we don't check for those here. References:\n// - http://es5.github.com/#x7.6\n// - https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Core_Language_Features#Variables\n// - http://docstore.mik.ua/orelly/webprog/jscript/ch02_07.htm\n\n            var key = ch;\n\n            // Identifiers must start with a letter, _ or $.\n            if ((ch !== '_' && ch !== '$') &&\n                    (ch < 'a' || ch > 'z') &&\n                    (ch < 'A' || ch > 'Z')) {\n                error(\"Bad identifier\");\n            }\n\n            // Subsequent characters can contain digits.\n            while (next() && (\n                    ch === '_' || ch === '$' ||\n                    (ch >= 'a' && ch <= 'z') ||\n                    (ch >= 'A' && ch <= 'Z') ||\n                    (ch >= '0' && ch <= '9'))) {\n                key += ch;\n            }\n\n            return key;\n        },\n\n        number = function () {\n\n// Parse a number value.\n\n            var number,\n                sign = '',\n                string = '',\n                base = 10;\n\n            if (ch === '-' || ch === '+') {\n                sign = ch;\n                next(ch);\n            }\n\n            // support for Infinity (could tweak to allow other words):\n            if (ch === 'I') {\n                number = word();\n                if (typeof number !== 'number' || isNaN(number)) {\n                    error('Unexpected word for number');\n                }\n                return (sign === '-') ? -number : number;\n            }\n\n            // support for NaN\n            if (ch === 'N' ) {\n              number = word();\n              if (!isNaN(number)) {\n                error('expected word to be NaN');\n              }\n              // ignore sign as -NaN also is NaN\n              return number;\n            }\n\n            if (ch === '0') {\n                string += ch;\n                next();\n                if (ch === 'x' || ch === 'X') {\n                    string += ch;\n                    next();\n                    base = 16;\n                } else if (ch >= '0' && ch <= '9') {\n                    error('Octal literal');\n                }\n            }\n\n            switch (base) {\n            case 10:\n                while (ch >= '0' && ch <= '9' ) {\n                    string += ch;\n                    next();\n                }\n                if (ch === '.') {\n                    string += '.';\n                    while (next() && ch >= '0' && ch <= '9') {\n                        string += ch;\n                    }\n                }\n                if (ch === 'e' || ch === 'E') {\n                    string += ch;\n                    next();\n                    if (ch === '-' || ch === '+') {\n                        string += ch;\n                        next();\n                    }\n                    while (ch >= '0' && ch <= '9') {\n                        string += ch;\n                        next();\n                    }\n                }\n                break;\n            case 16:\n                while (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') {\n                    string += ch;\n                    next();\n                }\n                break;\n            }\n\n            if(sign === '-') {\n                number = -string;\n            } else {\n                number = +string;\n            }\n\n            if (!isFinite(number)) {\n                error(\"Bad number\");\n            } else {\n                return number;\n            }\n        },\n\n        string = function () {\n\n// Parse a string value.\n\n            var hex,\n                i,\n                string = '',\n                delim,      // double quote or single quote\n                uffff;\n\n// When parsing for string values, we must look for ' or \" and \\ characters.\n\n            if (ch === '\"' || ch === \"'\") {\n                delim = ch;\n                while (next()) {\n                    if (ch === delim) {\n                        next();\n                        return string;\n                    } else if (ch === '\\\\') {\n                        next();\n                        if (ch === 'u') {\n                            uffff = 0;\n                            for (i = 0; i < 4; i += 1) {\n                                hex = parseInt(next(), 16);\n                                if (!isFinite(hex)) {\n                                    break;\n                                }\n                                uffff = uffff * 16 + hex;\n                            }\n                            string += String.fromCharCode(uffff);\n                        } else if (ch === '\\r') {\n                            if (peek() === '\\n') {\n                                next();\n                            }\n                        } else if (typeof escapee[ch] === 'string') {\n                            string += escapee[ch];\n                        } else {\n                            break;\n                        }\n                    } else if (ch === '\\n') {\n                        // unescaped newlines are invalid; see:\n                        // https://github.com/aseemk/json5/issues/24\n                        // invalid unescaped chars?\n                        break;\n                    } else {\n                        string += ch;\n                    }\n                }\n            }\n            error(\"Bad string\");\n        },\n\n        inlineComment = function () {\n\n// Skip an inline comment, assuming this is one. The current character should\n// be the second / character in the // pair that begins this inline comment.\n// To finish the inline comment, we look for a newline or the end of the text.\n\n            if (ch !== '/') {\n                error(\"Not an inline comment\");\n            }\n\n            do {\n                next();\n                if (ch === '\\n' || ch === '\\r') {\n                    next();\n                    return;\n                }\n            } while (ch);\n        },\n\n        blockComment = function () {\n\n// Skip a block comment, assuming this is one. The current character should be\n// the * character in the /* pair that begins this block comment.\n// To finish the block comment, we look for an ending */ pair of characters,\n// but we also watch for the end of text before the comment is terminated.\n\n            if (ch !== '*') {\n                error(\"Not a block comment\");\n            }\n\n            do {\n                next();\n                while (ch === '*') {\n                    next('*');\n                    if (ch === '/') {\n                        next('/');\n                        return;\n                    }\n                }\n            } while (ch);\n\n            error(\"Unterminated block comment\");\n        },\n\n        comment = function () {\n\n// Skip a comment, whether inline or block-level, assuming this is one.\n// Comments always begin with a / character.\n\n            if (ch !== '/') {\n                error(\"Not a comment\");\n            }\n\n            next('/');\n\n            if (ch === '/') {\n                inlineComment();\n            } else if (ch === '*') {\n                blockComment();\n            } else {\n                error(\"Unrecognized comment\");\n            }\n        },\n\n        white = function () {\n\n// Skip whitespace and comments.\n// Note that we're detecting comments by only a single / character.\n// This works since regular expressions are not valid JSON(5), but this will\n// break if there are other valid values that begin with a / character!\n\n            while (ch) {\n                if (ch === '/') {\n                    comment();\n                } else if (ws.indexOf(ch) >= 0) {\n                    next();\n                } else {\n                    return;\n                }\n            }\n        },\n\n        word = function () {\n\n// true, false, or null.\n\n            switch (ch) {\n            case 't':\n                next('t');\n                next('r');\n                next('u');\n                next('e');\n                return true;\n            case 'f':\n                next('f');\n                next('a');\n                next('l');\n                next('s');\n                next('e');\n                return false;\n            case 'n':\n                next('n');\n                next('u');\n                next('l');\n                next('l');\n                return null;\n            case 'I':\n                next('I');\n                next('n');\n                next('f');\n                next('i');\n                next('n');\n                next('i');\n                next('t');\n                next('y');\n                return Infinity;\n            case 'N':\n              next( 'N' );\n              next( 'a' );\n              next( 'N' );\n              return NaN;\n            }\n            error(\"Unexpected '\" + ch + \"'\");\n        },\n\n        value,  // Place holder for the value function.\n\n        array = function () {\n\n// Parse an array value.\n\n            var array = [];\n\n            if (ch === '[') {\n                next('[');\n                white();\n                while (ch) {\n                    if (ch === ']') {\n                        next(']');\n                        return array;   // Potentially empty array\n                    }\n                    // ES5 allows omitting elements in arrays, e.g. [,] and\n                    // [,null]. We don't allow this in JSON5.\n                    if (ch === ',') {\n                        error(\"Missing array element\");\n                    } else {\n                        array.push(value());\n                    }\n                    white();\n                    // If there's no comma after this value, this needs to\n                    // be the end of the array.\n                    if (ch !== ',') {\n                        next(']');\n                        return array;\n                    }\n                    next(',');\n                    white();\n                }\n            }\n            error(\"Bad array\");\n        },\n\n        object = function () {\n\n// Parse an object value.\n\n            var key,\n                object = {};\n\n            if (ch === '{') {\n                next('{');\n                white();\n                while (ch) {\n                    if (ch === '}') {\n                        next('}');\n                        return object;   // Potentially empty object\n                    }\n\n                    // Keys can be unquoted. If they are, they need to be\n                    // valid JS identifiers.\n                    if (ch === '\"' || ch === \"'\") {\n                        key = string();\n                    } else {\n                        key = identifier();\n                    }\n\n                    white();\n                    next(':');\n                    object[key] = value();\n                    white();\n                    // If there's no comma after this pair, this needs to be\n                    // the end of the object.\n                    if (ch !== ',') {\n                        next('}');\n                        return object;\n                    }\n                    next(',');\n                    white();\n                }\n            }\n            error(\"Bad object\");\n        };\n\n    value = function () {\n\n// Parse a JSON value. It could be an object, an array, a string, a number,\n// or a word.\n\n        white();\n        switch (ch) {\n        case '{':\n            return object();\n        case '[':\n            return array();\n        case '\"':\n        case \"'\":\n            return string();\n        case '-':\n        case '+':\n        case '.':\n            return number();\n        default:\n            return ch >= '0' && ch <= '9' ? number() : word();\n        }\n    };\n\n// Return the json_parse function. It will have access to all of the above\n// functions and variables.\n\n    return function (source, reviver) {\n        var result;\n\n        text = String(source);\n        at = 0;\n        ch = ' ';\n        result = value();\n        white();\n        if (ch) {\n            error(\"Syntax error\");\n        }\n\n// If there is a reviver function, we recursively walk the new structure,\n// passing each name/value pair to the reviver function for possible\n// transformation, starting with a temporary root object that holds the result\n// in an empty key. If there is not a reviver function, we simply return the\n// result.\n\n        return typeof reviver === 'function' ? (function walk(holder, key) {\n            var k, v, value = holder[key];\n            if (value && typeof value === 'object') {\n                for (k in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                        v = walk(value, k);\n                        if (v !== undefined) {\n                            value[k] = v;\n                        } else {\n                            delete value[k];\n                        }\n                    }\n                }\n            }\n            return reviver.call(holder, key, value);\n        }({'': result}, '')) : result;\n    };\n}());\n\n// JSON5 stringify will not quote keys where appropriate\nJSON5.stringify = function (obj, replacer, space) {\n    if (replacer && (typeof(replacer) !== \"function\" && !isArray(replacer))) {\n        throw new Error('Replacer must be a function or an array');\n    }\n    var getReplacedValueOrUndefined = function(holder, key, isTopLevel) {\n        var value = holder[key];\n\n        // Replace the value with its toJSON value first, if possible\n        if (value && value.toJSON && typeof value.toJSON === \"function\") {\n            value = value.toJSON();\n        }\n\n        // If the user-supplied replacer if a function, call it. If it's an array, check objects' string keys for\n        // presence in the array (removing the key/value pair from the resulting JSON if the key is missing).\n        if (typeof(replacer) === \"function\") {\n            return replacer.call(holder, key, value);\n        } else if(replacer) {\n            if (isTopLevel || isArray(holder) || replacer.indexOf(key) >= 0) {\n                return value;\n            } else {\n                return undefined;\n            }\n        } else {\n            return value;\n        }\n    };\n\n    function isWordChar(char) {\n        return (char >= 'a' && char <= 'z') ||\n            (char >= 'A' && char <= 'Z') ||\n            (char >= '0' && char <= '9') ||\n            char === '_' || char === '$';\n    }\n\n    function isWordStart(char) {\n        return (char >= 'a' && char <= 'z') ||\n            (char >= 'A' && char <= 'Z') ||\n            char === '_' || char === '$';\n    }\n\n    function isWord(key) {\n        if (typeof key !== 'string') {\n            return false;\n        }\n        if (!isWordStart(key[0])) {\n            return false;\n        }\n        var i = 1, length = key.length;\n        while (i < length) {\n            if (!isWordChar(key[i])) {\n                return false;\n            }\n            i++;\n        }\n        return true;\n    }\n\n    // export for use in tests\n    JSON5.isWord = isWord;\n\n    // polyfills\n    function isArray(obj) {\n        if (Array.isArray) {\n            return Array.isArray(obj);\n        } else {\n            return Object.prototype.toString.call(obj) === '[object Array]';\n        }\n    }\n\n    function isDate(obj) {\n        return Object.prototype.toString.call(obj) === '[object Date]';\n    }\n\n    isNaN = isNaN || function(val) {\n        return typeof val === 'number' && val !== val;\n    };\n\n    var objStack = [];\n    function checkForCircular(obj) {\n        for (var i = 0; i < objStack.length; i++) {\n            if (objStack[i] === obj) {\n                throw new TypeError(\"Converting circular structure to JSON\");\n            }\n        }\n    }\n\n    function makeIndent(str, num, noNewLine) {\n        if (!str) {\n            return \"\";\n        }\n        // indentation no more than 10 chars\n        if (str.length > 10) {\n            str = str.substring(0, 10);\n        }\n\n        var indent = noNewLine ? \"\" : \"\\n\";\n        for (var i = 0; i < num; i++) {\n            indent += str;\n        }\n\n        return indent;\n    }\n\n    var indentStr;\n    if (space) {\n        if (typeof space === \"string\") {\n            indentStr = space;\n        } else if (typeof space === \"number\" && space >= 0) {\n            indentStr = makeIndent(\" \", space, true);\n        } else {\n            // ignore space parameter\n        }\n    }\n\n    // Copied from Crokford's implementation of JSON\n    // See https://github.com/douglascrockford/JSON-js/blob/e39db4b7e6249f04a195e7dd0840e610cc9e941e/json2.js#L195\n    // Begin\n    var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n        escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n        meta = { // table of character substitutions\n        '\\b': '\\\\b',\n        '\\t': '\\\\t',\n        '\\n': '\\\\n',\n        '\\f': '\\\\f',\n        '\\r': '\\\\r',\n        '\"' : '\\\\\"',\n        '\\\\': '\\\\\\\\'\n    };\n    function escapeString(string) {\n\n// If the string contains no control characters, no quote characters, and no\n// backslash characters, then we can safely slap some quotes around it.\n// Otherwise we must also replace the offending characters with safe escape\n// sequences.\n        escapable.lastIndex = 0;\n        return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n            var c = meta[a];\n            return typeof c === 'string' ?\n                c :\n                '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n        }) + '\"' : '\"' + string + '\"';\n    }\n    // End\n\n    function internalStringify(holder, key, isTopLevel) {\n        var buffer, res;\n\n        // Replace the value, if necessary\n        var obj_part = getReplacedValueOrUndefined(holder, key, isTopLevel);\n\n        if (obj_part && !isDate(obj_part)) {\n            // unbox objects\n            // don't unbox dates, since will turn it into number\n            obj_part = obj_part.valueOf();\n        }\n        switch(typeof obj_part) {\n            case \"boolean\":\n                return obj_part.toString();\n\n            case \"number\":\n                if (isNaN(obj_part) || !isFinite(obj_part)) {\n                    return \"null\";\n                }\n                return obj_part.toString();\n\n            case \"string\":\n                return escapeString(obj_part.toString());\n\n            case \"object\":\n                if (obj_part === null) {\n                    return \"null\";\n                } else if (isArray(obj_part)) {\n                    checkForCircular(obj_part);\n                    buffer = \"[\";\n                    objStack.push(obj_part);\n\n                    for (var i = 0; i < obj_part.length; i++) {\n                        res = internalStringify(obj_part, i, false);\n                        buffer += makeIndent(indentStr, objStack.length);\n                        if (res === null || typeof res === \"undefined\") {\n                            buffer += \"null\";\n                        } else {\n                            buffer += res;\n                        }\n                        if (i < obj_part.length-1) {\n                            buffer += \",\";\n                        } else if (indentStr) {\n                            buffer += \"\\n\";\n                        }\n                    }\n                    objStack.pop();\n                    buffer += makeIndent(indentStr, objStack.length, true) + \"]\";\n                } else {\n                    checkForCircular(obj_part);\n                    buffer = \"{\";\n                    var nonEmpty = false;\n                    objStack.push(obj_part);\n                    for (var prop in obj_part) {\n                        if (obj_part.hasOwnProperty(prop)) {\n                            var value = internalStringify(obj_part, prop, false);\n                            isTopLevel = false;\n                            if (typeof value !== \"undefined\" && value !== null) {\n                                buffer += makeIndent(indentStr, objStack.length);\n                                nonEmpty = true;\n                                var key = isWord(prop) ? prop : escapeString(prop);\n                                buffer += key + \":\" + (indentStr ? ' ' : '') + value + \",\";\n                            }\n                        }\n                    }\n                    objStack.pop();\n                    if (nonEmpty) {\n                        buffer = buffer.substring(0, buffer.length-1) + makeIndent(indentStr, objStack.length) + \"}\";\n                    } else {\n                        buffer = '{}';\n                    }\n                }\n                return buffer;\n            default:\n                // functions and undefined should be ignored\n                return undefined;\n        }\n    }\n\n    // special case...when undefined is used inside of\n    // a compound object/array, return null.\n    // but when top-level, return undefined\n    var topLevelHolder = {\"\":obj};\n    if (obj === undefined) {\n        return getReplacedValueOrUndefined(topLevelHolder, '', true);\n    }\n    return internalStringify(topLevelHolder, '', true);\n};\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/API/CliUx.js":"/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\nvar Table         = require('cli-table');\nvar p             = require('path');\nvar chalk         = require('chalk');\nvar Common        = require('../Common');\nvar Spinner       = require('./Spinner.js');\n\nvar UX = module.exports = {};\n\n/**\n * Description\n * @method miniDisplay\n * @param {} list\n * @return\n */\nUX.miniDisplay = function(list) {\n  list.forEach(function(l) {\n\n    var mode = l.pm2_env.exec_mode.split('_mode')[0];\n    var status = l.pm2_env.status;\n    var key = l.pm2_env.name || p.basename(l.pm2_env.pm_exec_path.script);\n\n    console.log('+--- %s', key);\n    console.log('pid : %s', l.pid);\n    console.log('pm2 id : %s', l.pm2_env.pm_id);\n    console.log('status : %s', status);\n    console.log('mode : %s', mode);\n    console.log('restarted : %d', l.pm2_env.restart_time ? l.pm2_env.restart_time : 0);\n    console.log('uptime : %s', (l.pm2_env.pm_uptime && status == 'online') ? timeSince(l.pm2_env.pm_uptime) : 0);\n    console.log('memory usage : %s', l.monit ? UX.bytesToSize(l.monit.memory, 3) : '');\n    console.log('error log : %s', l.pm2_env.pm_err_log_path);\n    console.log('watching : %s', l.pm2_env.watch ? 'yes' : 'no');\n    console.log('PID file : %s\\n', [l.pm2_env.pm_pid_path, l.pm_id, '.pid'].join(''));\n  });\n};\n\nUX.postModuleInfos = function(module_name, human_info) {\n  var table = new Table({\n    style : {'padding-left' : 1, head : ['cyan', 'bold'], compact : true}\n  });\n\n  var disp = {};\n\n  human_info.unshift(['Module name', module_name]);\n  human_info.forEach(function(info) {\n    var obj = {};\n    obj[chalk.bold.cyan(info[0])] = info[1];\n    table.push(obj);\n  });\n\n  console.log();\n  console.log(chalk.bold.inverse(' Module %s infos '), module_name);\n  console.log(table.toString());\n};\n\n/**\n * Description\n * @method describeTable\n * @param {} process\n * @return\n */\nUX.describeTable = function(process) {\n  var table = new Table({\n    style : {'padding-left' : 1, head : ['cyan', 'bold'], compact : true}\n  });\n\n  var pm2_env = process.pm2_env;\n\n  var created_at = 'N/A';\n\n  if (pm2_env.axm_options && pm2_env.axm_options.human_info) {\n    this.postModuleInfos(pm2_env.name, pm2_env.axm_options.human_info);\n  }\n\n  try {\n    if (pm2_env.created_at != null)\n      created_at = new Date(pm2_env.created_at).toISOString();\n  } catch (e) {\n    //throw new Error(pm2_env.created_at + ' is not a valid date: '+e.message, e.fileName, e.lineNumber);\n  }\n\n  console.log(chalk.bold.inverse(' Describing process with id %d - name %s '), pm2_env.pm_id, pm2_env.name);\n  safe_push(table,\n            { 'status' : colorStatus(pm2_env.status) },\n            { 'name': pm2_env.name },\n            { 'restarts' : pm2_env.restart_time },\n            { 'uptime' : (pm2_env.pm_uptime && pm2_env.status == 'online') ? timeSince(pm2_env.pm_uptime) : 0 },\n            { 'script path' : pm2_env.pm_exec_path },\n            { 'script args' : pm2_env.args ? (typeof pm2_env.args == 'string' ? JSON.parse(pm2_env.args.replace(/'/g, '\"')):pm2_env.args).join(' ') : null },\n            { 'error log path' : pm2_env.pm_err_log_path },\n            { 'out log path' : pm2_env.pm_out_log_path },\n            { 'pid path' : pm2_env.pm_pid_path },\n\n            { 'interpreter' : pm2_env.exec_interpreter },\n            { 'interpreter args' : pm2_env.node_args.length != 0 ? pm2_env.node_args : null },\n\n            { 'script id' : pm2_env.pm_id },\n            { 'exec cwd' : pm2_env.pm_cwd },\n\n            { 'exec mode' : pm2_env.exec_mode },\n            { 'node.js version' : pm2_env.node_version },\n            { 'watch & reload' : pm2_env.watch ? chalk.green.bold('✔') : '✘' },\n            { 'unstable restarts' : pm2_env.unstable_restarts },\n            { 'created at' : created_at }\n           );\n\n  if('pm_log_path' in pm2_env){\n    table.splice(6, 0, {'entire log path': pm2_env.pm_log_path});\n  }\n\n  console.log(table.toString());\n\n  /**\n   * Module conf display\n   */\n  if (pm2_env.axm_options && pm2_env.axm_options.module_conf && Object.keys(pm2_env.axm_options.module_conf).length > 0) {\n    var table_conf = new Table({\n      style : {'padding-left' : 1, head : ['cyan', 'bold'], compact : true}\n    });\n    console.log('Process configuration');\n\n    Object.keys(pm2_env.axm_options.module_conf).forEach(function(key) {\n      var tmp = {};\n      tmp[key] = pm2_env.axm_options.module_conf[key];\n      safe_push(table_conf, tmp);\n    });\n\n    console.log(table_conf.toString());\n  }\n\n  /**\n   * Versioning metadata\n   */\n  if (pm2_env.versioning) {\n\n    var table2 = new Table({\n      style : {'padding-left' : 1, head : ['cyan', 'bold'], compact : true}\n    });\n\n    console.log(chalk.inverse.bold(' Revision control metadata '));\n    safe_push(table2,\n              { 'revision control' : pm2_env.versioning.type },\n              { 'remote url' : pm2_env.versioning.url },\n              { 'repository root' : pm2_env.versioning.repo_path },\n              { 'last update' : pm2_env.versioning.update_time },\n              { 'revision' : pm2_env.versioning.revision },\n              { 'comment' :  pm2_env.versioning.comment },\n              { 'branch' :  pm2_env.versioning.branch }\n             );\n    console.log(table2.toString());\n  }\n\n  if (pm2_env.axm_actions && Object.keys(pm2_env.axm_actions).length > 0) {\n    var table_actions = new Table({\n      style : {'padding-left' : 1, head : ['cyan', 'bold'], compact : true}\n    });\n\n    console.log(chalk.inverse.bold(' Actions available '));\n    pm2_env.axm_actions.forEach(function(action_set) {\n      safe_push(table_actions, [action_set.action_name]);\n    });\n\n    console.log(table_actions.toString());\n    Common.printOut(chalk.white.italic(' Trigger via: pm2 trigger %s <action_name>\\n'), pm2_env.name);\n  }\n\n  if (pm2_env.axm_monitor && Object.keys(pm2_env.axm_monitor).length > 0) {\n    var table_probes = new Table({\n      style : {'padding-left' : 1, head : ['cyan', 'bold'], compact : true}\n    });\n\n    console.log(chalk.inverse.bold(' Code metrics value '));\n    Object.keys(pm2_env.axm_monitor).forEach(function(key) {\n      var obj = {};\n      var value = pm2_env.axm_monitor[key].hasOwnProperty(\"value\") ? pm2_env.axm_monitor[key].value : pm2_env.axm_monitor[key];\n      obj[key] = value;\n      safe_push(table_probes, obj);\n    });\n\n    console.log(table_probes.toString());\n  }\n\n  Common.printOut(chalk.white.italic(' Add your own code metrics: http://bit.ly/code-metrics'));\n  Common.printOut(chalk.white.italic(' Use `pm2 logs %s [--lines 1000]` to display logs'), pm2_env.name);\n  Common.printOut(chalk.white.italic(' Use `pm2 monit` to monitor CPU and Memory usage'), pm2_env.name);\n};\n\n/**\n * Description\n * @method dispAsTable\n * @param {} list\n * @param {} interact_infos\n * @return\n */\nUX.dispAsTable = function(list, interact_infos) {\n  var stacked = (process.stdout.columns || 90) < 90;\n  var app_head = stacked ? ['Name', 'mode', 'status', '↺', 'cpu', 'memory'] :\n              ['App name', 'id', 'mode', 'pid', 'status', 'restart', 'uptime', 'cpu', 'mem', 'watching'];\n  var mod_head = stacked ? ['Module', 'status', 'cpu', 'mem'] :\n              ['Module', 'version', 'target PID',  'status', 'restart', 'cpu', 'memory'];\n\n  var app_table = new Table({\n    head : app_head,\n    colAligns : ['left'],\n    style : {'padding-left' : 1, head : ['cyan', 'bold'], compact : true}\n  });\n\n  var module_table = new Table({\n    head : mod_head,\n    colAligns : ['left'],\n    style : {'padding-left' : 1, head : ['cyan', 'bold'],  compact : true}\n  });\n\n  if (!list)\n    return console.log('list empty');\n\n  list.sort(function(a, b) {\n    if (a.pm2_env.name < b.pm2_env.name)\n      return -1;\n    if (a.pm2_env.name > b.pm2_env.name)\n      return 1;\n    return 0;\n  });\n\n  list.forEach(function(l) {\n    var obj = {};\n\n    var mode = l.pm2_env.exec_mode;\n    var status = l.pm2_env.status;\n    var key = l.pm2_env.name || p.basename(l.pm2_env.pm_exec_path.script);\n    key = chalk.bold.cyan(key);\n\n    if (l.pm2_env.axm_options) {\n      var deep_monitored = l.pm2_env.axm_options.tracing_enabled || false;\n      if (deep_monitored == true) {\n        key = key + ' ' + chalk.green('⏱');\n      }\n    }\n\n    if (l.pm2_env.pmx_module == true) {\n      obj[key] = [];\n      if (!stacked)\n        obj[key].push(chalk.bold(l.pm2_env.axm_options.module_version || 'N/A'),\n          typeof(l.pm2_env.axm_options.pid) === 'number' ? l.pm2_env.axm_options.pid : 'N/A' );\n      obj[key].push(colorStatus(status));\n      if (!stacked)\n        obj[key].push(l.pm2_env.restart_time ? l.pm2_env.restart_time : 0);\n      obj[key].push(l.monit ? (l.monit.cpu + '%') : 'N/A', l.monit ? UX.bytesToSize(l.monit.memory, 3) : 'N/A' );\n\n      safe_push(module_table, obj);\n    }\n    else {\n      obj[key] = [];\n      if (!stacked)\n        obj[key].push(l.pm2_env.pm_id);\n      obj[key].push(mode == 'fork_mode' ? chalk.inverse.bold('fork') : chalk.blue.bold('cluster'));\n      if (!stacked)\n        obj[key].push(l.pid);\n      obj[key].push(colorStatus(status));\n      obj[key].push(l.pm2_env.restart_time ? l.pm2_env.restart_time : 0);\n      if (!stacked)\n        obj[key].push((l.pm2_env.pm_uptime && status == 'online') ? timeSince(l.pm2_env.pm_uptime) : 0);\n\n      obj[key].push(l.monit ? l.monit.cpu + '%' : 'N/A');\n      obj[key].push(l.monit ? UX.bytesToSize(l.monit.memory, 1) : 'N/A');\n      if (!stacked)\n        obj[key].push(l.pm2_env.watch ? chalk.green.bold('enabled') : chalk.grey('disabled'));\n\n      safe_push(app_table, obj);\n    }\n\n  });\n\n  console.log(app_table.toString());\n  if (module_table.length > 0) {\n    console.log(chalk.bold(' Module activated'));\n    console.log(module_table.toString());\n  }\n};\n\nUX.dispKeys = function(kv, target_module) {\n  Object.keys(kv).forEach(function(key) {\n\n    if (target_module != null && target_module != key)\n      return false;\n\n    if (typeof(kv[key]) == 'object') {\n      var app_table = new Table({\n        head:       ['key', 'value'],\n        colAligns : ['left', 'left'],\n        style : {'padding-left' : 1, head : ['cyan', 'bold'], compact : true}\n      });\n\n      var obj = {};\n\n      Object.keys(kv[key]).forEach(function(sub_key) {\n        app_table.push([sub_key, kv[key][sub_key]]);\n      });\n\n      console.log('== ' + chalk.bold.blue(key) + ' ==');\n      console.log(app_table.toString());\n    }\n  });\n}\n\nUX.processing = {\n  current_spinner : null,\n  start : function(text) {\n    this.current_spinner = new Spinner(text || 'Connecting...');\n    this.current_spinner.start();\n  },\n  stop : function() {\n    if (!this.current_spinner) return;\n    this.current_spinner.stop();\n    this.current_spinner = null;\n  }\n};\n\n\n/**\n * Description\n * @method bytesToSize\n * @param {} bytes\n * @param {} precision\n * @return\n */\nUX.bytesToSize = function(bytes, precision) {\n  var kilobyte = 1024;\n  var megabyte = kilobyte * 1024;\n  var gigabyte = megabyte * 1024;\n  var terabyte = gigabyte * 1024;\n\n  if ((bytes >= 0) && (bytes < kilobyte)) {\n    return bytes + ' B   ';\n  } else if ((bytes >= kilobyte) && (bytes < megabyte)) {\n    return (bytes / kilobyte).toFixed(precision) + ' KB  ';\n  } else if ((bytes >= megabyte) && (bytes < gigabyte)) {\n    return (bytes / megabyte).toFixed(precision) + ' MB  ';\n  } else if ((bytes >= gigabyte) && (bytes < terabyte)) {\n    return (bytes / gigabyte).toFixed(precision) + ' GB  ';\n  } else if (bytes >= terabyte) {\n    return (bytes / terabyte).toFixed(precision) + ' TB  ';\n  } else {\n    return bytes + ' B   ';\n  }\n};\n\n/**\n * Description\n * @method colorStatus\n * @param {} status\n * @return\n */\nfunction colorStatus(status) {\n  switch (status) {\n  case 'online':\n    return chalk.green.bold('online');\n    break;\n  case 'launching':\n    return chalk.blue.bold('launching');\n    break;\n  default:\n    return chalk.red.bold(status);\n  }\n}\n\nvar safe_push = function() {\n  var argv = arguments;\n  var table = argv[0];\n\n  for (var i = 1; i < argv.length; ++i) {\n    var elem = argv[i];\n    if (elem[Object.keys(elem)[0]] === undefined\n        || elem[Object.keys(elem)[0]] === null) {\n      elem[Object.keys(elem)[0]] = 'N/A';\n    }\n    else if (Array.isArray(elem[Object.keys(elem)[0]])) {\n      elem[Object.keys(elem)[0]].forEach(function(curr, j) {\n        if (curr === undefined || curr === null)\n          elem[Object.keys(elem)[0]][j] = 'N/A';\n      });\n    }\n    table.push(elem);\n  }\n};\n\n/**\n * Description\n * @method timeSince\n * @param {} date\n * @return BinaryExpression\n */\nfunction timeSince(date) {\n\n  var seconds = Math.floor((new Date() - date) / 1000);\n\n  var interval = Math.floor(seconds / 31536000);\n\n  if (interval > 1) {\n    return interval + 'Y';\n  }\n  interval = Math.floor(seconds / 2592000);\n  if (interval > 1) {\n    return interval + 'M';\n  }\n  interval = Math.floor(seconds / 86400);\n  if (interval > 1) {\n    return interval + 'D';\n  }\n  interval = Math.floor(seconds / 3600);\n  if (interval > 1) {\n    return interval + 'h';\n  }\n  interval = Math.floor(seconds / 60);\n  if (interval > 1) {\n    return interval + 'm';\n  }\n  return Math.floor(seconds) + 's';\n}\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/API/Spinner.js":"/**\n * Spinner\n * Handle TTY and non-TTY based terminals\n */\n\nvar defaultSpinnerString = [\n  \"⠋\",\n  \"⠙\",\n  \"⠹\",\n  \"⠸\",\n  \"⠼\",\n  \"⠴\",\n  \"⠦\",\n  \"⠧\",\n  \"⠇\",\n  \"⠏\"\n].join('');\n\nvar InteractiveSpinner = function(textToShow){\n  this.text = textToShow || '';\n  this.setSpinnerString(defaultSpinnerString); // use default spinner string\n};\n\nInteractiveSpinner.setDefaultSpinnerString = function(value) {\n  defaultSpinnerString = value;\n};\n\nInteractiveSpinner.prototype.start = function() {\n  var current = 0;\n  var self = this;\n  this.id = setInterval(function() {\n    try {\n      process.stdout.clearLine();\n      process.stdout.cursorTo(0);\n      process.stdout.write(self.chars[current] + ' ' + self.text);\n      current = ++current % self.chars.length;\n    } catch(e) { // ignore error if term is not tty, just display nothing\n    }\n  }, 80);\n};\n\nInteractiveSpinner.prototype.setSpinnerString = function(str) {\n  this.chars = str.split(\"\");\n};\n\nInteractiveSpinner.prototype.stop = function() {\n  try {\n    process.stdout.clearLine();\n    process.stdout.cursorTo(0);\n  } catch(e) {}\n  clearInterval(this.id);\n};\n\n/**\n * Display dots if non TTY terminal\n */\nvar StaticSpinner = function(text) {\n  console.log(text);\n}\n\nStaticSpinner.prototype.start = function() {\n  this.interval = setInterval(function() {\n    process.stdout.write('.');\n  }, 500);\n};\n\nStaticSpinner.prototype.stop = function() {\n  clearInterval(this.interval);\n  console.log();\n};\n\nmodule.exports = function(text) {\n  if (process.stdout.isTTY)\n    return new InteractiveSpinner(text);\n  else\n    return new StaticSpinner(text);\n};\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/API/Modules/Modularizer.js":"/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\nvar shelljs  = require('shelljs');\nvar path     = require('path');\nvar fs       = require('fs');\nvar async    = require('async');\nvar p        = path;\nvar readline = require('readline');\nvar spawn    = require('child_process').spawn;\nvar chalk    = require('chalk');\nvar Configuration = require('../../Configuration.js');\nvar cst           = require('../../../constants.js');\nvar Common        = require('../../Common');\nvar UX            = require('../CliUx.js');\nvar Utility       = require('../../Utility.js');\nvar semver   = require('semver');\n\nvar Modularizer = module.exports = {};\n\nvar MODULE_CONF_PREFIX = 'module-db';\n\nfunction startModule(CLI, opts, cb) {\n  /** SCRIPT\n   * Open file and make the script detection smart\n   */\n\n  if (!opts.cmd) throw new Error('module package.json not defined');\n  if (!opts.development_mode) opts.development_mode = false;\n\n  var package_json = require(opts.cmd);\n\n  /**\n   * Script file detection\n   * 1- *apps* field (default pm2 json configuration)\n   * 2- *bin* field\n   * 3- *main* field\n   */\n  if (!package_json.apps) {\n    package_json.apps = {};\n\n    if (package_json.bin) {\n      var bin = Object.keys(package_json.bin)[0];\n\n      package_json.apps.script = package_json.bin[bin];\n    }\n    else if (package_json.main) {\n      package_json.apps.script = package_json.main;\n    }\n  }\n\n  /**\n   * Verify that the module is valid\n   * If not, delete\n   */\n  if (isValidModule(package_json) === false) {\n    if (!opts.development_mode) shelljs.rm('-rf', opts.proc_pabth);\n    Common.printError(cst.PREFIX_MSG_MOD + 'Module uninstalled');\n    return cb(new Error('Invalid module (script is missing)'));\n  }\n\n  // Start the module\n  CLI.start(package_json, {\n    cwd               : opts.proc_path,\n    watch             : opts.development_mode,\n    force_name        : package_json.name,\n    started_as_module : true\n  }, function(err, data) {\n    if (err) return cb(err);\n    return cb(null, data);\n  });\n};\n\nfunction installModule(CLI, module_name, cb) {\n  var proc_path = '',\n      cmd  = '',\n      conf = {},\n      development_mode = false;\n\n  if (module_name == '.') {\n    /**\n     * Development mode\n     */\n    Common.printOut(cst.PREFIX_MSG_MOD + 'Installing local module in DEVELOPMENT MODE with WATCH auto restart');\n    development_mode = true;\n    proc_path = process.cwd();\n\n    cmd = p.join(proc_path, cst.DEFAULT_MODULE_JSON);\n\n    startModule(CLI, {\n      cmd : cmd,\n      development_mode : development_mode,\n      proc_path : proc_path\n    }, function(err, dt) {\n      if (err) return cb(err);\n      Common.printOut(cst.PREFIX_MSG_MOD + 'Module successfully installed and launched');\n      return cb(null, dt);\n    });\n  }\n  else {\n    /**\n     * Production mode\n     */\n    var cli = {};\n\n    if (semver.satisfies(process.version, '> 0.12') && shelljs.which('yarn')) {\n      cli = {\n        bin : 'yarn',\n        cmd : 'add'\n      }\n    }\n    else {\n      cli = {\n        bin : 'npm',\n        cmd : 'install'\n      }\n    }\n\n    Common.printOut(cst.PREFIX_MSG_MOD + 'Calling ' + chalk.bold.red('[' + cli.bin.toUpperCase() + ']') + ' to install ' + module_name + ' ...');\n\n    var install_instance = spawn(cst.IS_WINDOWS ? cli.bin + '.cmd' : cli.bin, [cli.cmd, module_name, '--loglevel=error'], {\n      stdio : 'inherit',\n      env: process.env,\n\t\t\tshell : true,\n      cwd : cst.PM2_ROOT_PATH\n    });\n\n    install_instance.on('close', finalize);\n\n    install_instance.on('error', function (err) {\n      console.error(err.stack || err);\n    });\n\n    function finalize(code) {\n      if (code != 0) {\n        return cb(new Error(\"Installation failed\"));\n      }\n\n      Common.printOut(cst.PREFIX_MSG_MOD + 'Module downloaded');\n\n      if (module_name.match(/\\.tgz($|\\?)/)) {\n        module_name = Utility.packageNameToModuleName(module_name);\n      }\n      else if (module_name.indexOf('/') != -1)\n        module_name = module_name.split('/')[1];\n\n      //pm2 install module@2.1.0-beta\n      if(module_name.indexOf('@') != -1)\n        module_name = module_name.split('@')[0]\n\n      proc_path = p.join(cst.PM2_ROOT_PATH, 'node_modules', module_name);\n\n      cmd = p.join(proc_path, cst.DEFAULT_MODULE_JSON);\n\n      Configuration.set(MODULE_CONF_PREFIX + ':' + module_name, 'true', function(err, data) {\n        startModule(CLI, {\n          cmd : cmd,\n          development_mode : development_mode,\n          proc_path : proc_path\n        }, function(err, dt) {\n          if (err) return cb(err);\n          Common.printOut(cst.PREFIX_MSG_MOD + 'Module successfully installed and launched');\n          Common.printOut(cst.PREFIX_MSG_MOD + ': To configure module do');\n          Common.printOut(cst.PREFIX_MSG_MOD + ': $ pm2 conf <key> <value>');\n          return cb(null, dt);\n        });\n      });\n    }\n  }\n}\n\nfunction uninstallModule(CLI, module_name, cb) {\n  var proc_path = p.join(cst.PM2_ROOT_PATH, 'node_modules', module_name);\n\n  Configuration.unsetSync(MODULE_CONF_PREFIX + ':' + module_name);\n\n  CLI.deleteModule(module_name, function(err, data) {\n    if (err) {\n      Common.printError(err);\n\n      if (module_name != '.') {\n        console.log(proc_path);\n        shelljs.rm('-r', proc_path);\n      }\n\n      return cb(err);\n    }\n\n    if (module_name != '.') {\n      shelljs.rm('-r', proc_path);\n    }\n\n    return cb(null, data);\n  });\n}\n\nfunction installLangModule(module_name, cb) {\n  var node_module_path = path.resolve(path.join(__dirname, '../../../'));\n\n  var cli = semver.satisfies(process.version, '> 0.12') && shelljs.which('yarn') ? 'yarn' : 'npm'\n  Common.printOut(cst.PREFIX_MSG_MOD + 'Calling ' + chalk.bold.red('[' + cli.toUpperCase() + ']') + ' to install ' + module_name + ' ...');\n\n  var install_instance = spawn(cst.IS_WINDOWS ? 'npm.cmd' : 'npm', ['install', module_name, '--loglevel=error'], {\n    stdio : 'inherit',\n    env: process.env,\n\t\tshell : true,\n    cwd : node_module_path\n  });\n\n  install_instance.on('close', function done() {\n    cb(null);\n  });\n\n  install_instance.on('error', function (err) {\n    console.error(err.stack || err);\n  });\n};\n\n/**\n * List modules on the old way\n */\nvar listModules = function() {\n  var module_folder = p.join(cst.PM2_ROOT_PATH, 'node_modules');\n  var ret = [];\n\n  shelljs.config.silent = true;\n  var modules = shelljs.ls(module_folder);\n  shelljs.config.silent = false;\n\n  modules.forEach(function(module_name) {\n    if (module_name.indexOf('pm2-') > -1)\n      ret.push(module_name);\n  });\n\n  return ret;\n};\n\n/**\n * List modules based on internal database\n */\nvar listModulesV2 = Modularizer.listModules = function() {\n  var config = Configuration.getSync(MODULE_CONF_PREFIX);\n\n  if (!config) {\n    var modules_already_installed = listModules();\n\n    modules_already_installed.forEach(function(module_name) {\n      Configuration.setSync(MODULE_CONF_PREFIX + ':' + module_name, true);\n    });\n    return modules_already_installed;\n  }\n\n  return Object.keys(config);\n};\n\nModularizer.getAdditionalConf = function(app_name) {\n  if (!app_name) throw new Error('No app_name defined');\n\n  var module_conf = Configuration.getAllSync();\n\n  var additional_env = {};\n\n  if (!module_conf[app_name]) {\n    additional_env = {};\n    additional_env[app_name] = {};\n  }\n  else {\n    additional_env = Common.clone(module_conf[app_name]);\n    additional_env[app_name] = JSON.stringify(module_conf[app_name]);\n  }\n  return additional_env;\n};\n\nModularizer.launchAll = function(CLI, cb) {\n  var module_folder = p.join(cst.PM2_ROOT_PATH, 'node_modules');\n\n  var modules = listModulesV2();\n\n  async.eachLimit(modules, 1, function(module, next) {\n    var pmod = p.join(module_folder, module, cst.DEFAULT_MODULE_JSON);\n\n    Common.printOut(cst.PREFIX_MSG_MOD + 'Starting module ' + module);\n\n    startModule(CLI, {\n      cmd : pmod,\n      development_mode : false,\n      proc_path : p.join(module_folder, module)\n    }, function(err, dt) {\n      if (err) console.error(err);\n      return next();\n    });\n\n  }, function() {\n    return cb ? cb(null) : false;\n  });\n};\n\nModularizer.install = function(CLI, module_name, cb) {\n  Common.printOut(cst.PREFIX_MSG_MOD + 'Installing module ' + module_name);\n\n  var canonic_module_name = Utility.packageNameToModuleName(module_name);\n\n  if (module_name == 'v8-profiler' || module_name == 'profiler') {\n    installLangModule('v8-profiler', function(e) {\n      Common.printOut(cst.PREFIX_MSG + chalk.bold.green('V8 profiling enabled'));\n      return cb();\n    });\n    return false;\n  }\n\n  if (module_name == 'typescript') {\n    // Special dependency install\n    installLangModule('typescript', function(e) {\n      installLangModule('ts-node@latest', function(e) {\n        Common.printOut(cst.PREFIX_MSG + chalk.bold.green('Typescript support enabled'));\n        return cb();\n      });\n    });\n    return false;\n  }\n\n  if (module_name == 'livescript') {\n    installLangModule('livescript', function(e) {\n      Common.printOut(cst.PREFIX_MSG + chalk.bold.green('Livescript support enabled'));\n      return cb();\n    });\n    return false;\n  }\n\n  if (module_name == 'coffeescript') {\n    installLangModule('coffee-script', function(e) {\n      Common.printOut(cst.PREFIX_MSG + chalk.bold.green('Coffeescript support enabled'));\n      return cb();\n    });\n    return false;\n  }\n\n\n  if (moduleExist(canonic_module_name) === true) {\n    /**\n     * Update\n     */\n    Common.printOut(cst.PREFIX_MSG_MOD + 'Module already installed. Updating.');\n\n    uninstallModule(CLI, canonic_module_name, function(err) {\n      return installModule(CLI, module_name, cb);\n    });\n\n    return false;\n  }\n\n  /**\n   * Install\n   */\n  installModule(CLI, module_name, cb);\n};\n\n/**\n * Uninstall module\n */\nModularizer.uninstall = function(CLI, module_name, cb) {\n  Common.printOut(cst.PREFIX_MSG_MOD + 'Uninstalling module ' + module_name);\n\n  //if (moduleExist(module_name) === false && module_name != '.') {\n  //Common.printError(cst.PREFIX_MSG_MOD_ERR + 'Module unknown.');\n  //return cb({msg:'Module unknown'});\n  //}\n  if (module_name == 'all') {\n    var modules = listModulesV2();\n    async.forEachLimit(modules, 1, function(module, next) {\n      uninstallModule(CLI, module, next);\n    }, cb);\n    return false;\n  }\n\n  uninstallModule(CLI, module_name, cb);\n};\n\n/**\n * Publish a module\n */\nModularizer.publish = function(cb) {\n  var rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n  });\n\n  var semver = require('semver');\n\n  var package_file = p.join(process.cwd(), 'package.json');\n\n  var package_json = require(package_file);\n\n  package_json.version = semver.inc(package_json.version, 'minor');\n  Common.printOut(cst.PREFIX_MSG_MOD + 'Incrementing module to: %s@%s',\n                  package_json.name,\n                  package_json.version);\n\n\n  rl.question(\"Write & Publish? [Y/N]\", function(answer) {\n    if (answer != \"Y\")\n      return cb();\n\n\n    fs.writeFile(package_file, JSON.stringify(package_json, null, 2), function(err, data) {\n      if (err) return cb(err);\n\n      Common.printOut(cst.PREFIX_MSG_MOD + 'Publishing module - %s@%s',\n                      package_json.name,\n                      package_json.version);\n\n      shelljs.exec('npm publish', function(code) {\n        Common.printOut(cst.PREFIX_MSG_MOD + 'Module - %s@%s successfully published',\n                        package_json.name,\n                        package_json.version);\n\n        Common.printOut(cst.PREFIX_MSG_MOD + 'Pushing module on Git');\n        shelljs.exec('git add . ; git commit -m \"' + package_json.version + '\"; git push origin master', function(code) {\n\n          Common.printOut(cst.PREFIX_MSG_MOD + 'Installable with pm2 install %s', package_json.name);\n          return cb(null, package_json);\n        });\n      });\n    });\n\n  });\n};\n\nModularizer.generateSample = function(app_name, cb) {\n  var rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n  });\n\n  function samplize(module_name) {\n    var cmd1 = 'git clone https://github.com/pm2-hive/sample-module.git ' + module_name + '; cd ' + module_name + '; rm -rf .git';\n    var cmd2 = 'cd ' + module_name + ' ; sed -i \"s:sample-module:'+ module_name  +':g\" package.json';\n    var cmd3 = 'cd ' + module_name + ' ; npm install';\n\n    Common.printOut(cst.PREFIX_MSG_MOD + 'Getting sample app');\n    shelljs.exec(cmd1, function(err) {\n      if (err) Common.printError(cst.PREFIX_MSG_MOD_ERR + err.message);\n      shelljs.exec(cmd2, function(err) {\n        console.log('');\n        shelljs.exec(cmd3, function(err) {\n          console.log('');\n          Common.printOut(cst.PREFIX_MSG_MOD + 'Module sample created in folder: ', path.join(process.cwd(), module_name));\n          console.log('');\n          Common.printOut('Start module in development mode:');\n          Common.printOut('$ cd ' + module_name + '/');\n          Common.printOut('$ pm2 install . ');\n          console.log('');\n\n          Common.printOut('Module Log: ');\n          Common.printOut('$ pm2 logs ' + module_name);\n          console.log('');\n          Common.printOut('Uninstall module: ');\n          Common.printOut('$ pm2 uninstall ' + module_name);\n          console.log('');\n          Common.printOut('Force restart: ');\n          Common.printOut('$ pm2 restart ' + module_name);\n          return cb ?  cb() : false;\n        });\n      });\n    });\n  }\n\n  if (app_name) return samplize(app_name);\n\n  rl.question(cst.PREFIX_MSG_MOD + \"Module name: \", function(module_name) {\n    samplize(module_name);\n  });\n\n};\n\nfunction isValidModule(conf) {\n  var valid = true;\n\n  if (!conf.apps) {\n    Common.printError(cst.PREFIX_MSG_MOD_ERR + 'apps attribute indicating the script to launch is not defined in the package.json');\n    return false;\n  }\n\n  if (Array.isArray(conf.apps)) {\n    conf.apps.forEach(function(app) {\n      if (!app.script)\n        valid = false;\n    });\n  }\n  else {\n    if (!conf.apps.script)\n      valid = false;\n  }\n\n  return valid;\n};\n\nfunction moduleExist(module_name) {\n  var modules = getModuleInstalled();\n\n  if (module_name.indexOf('/') > -1)\n    module_name = module_name.split('/')[1];\n\n  return modules.indexOf(module_name) > -1 ? true : false;\n};\n\nfunction getModuleInstalled() {\n  shelljs.config.silent = true;\n  var module_folder = p.join(cst.PM2_ROOT_PATH, 'node_modules');\n  var modules       = shelljs.ls('-A', module_folder);\n  shelljs.config.silent = false;\n  return modules;\n}\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/Configuration.js":"/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\n\nvar Configuration = module.exports = {};\n\nvar fs            = require('fs');\n\nvar Common        = require('./Common');\nvar async         = require('async');\nvar cst           = require('../constants.js');\n\nfunction splitKey(key) {\n  var values = [key];\n\n  if (key.indexOf('.') > -1)\n    values = key.match(/(?:[^.\"]+|\"[^\"]*\")+/g).map(function(dt) { return dt.replace(/\"/g, '') });\n  else if (key.indexOf(':') > -1)\n    values = key.match(/(?:[^:\"]+|\"[^\"]*\")+/g).map(function(dt) { return dt.replace(/\"/g, '') });\n\n  return values;\n}\n\nConfiguration.set = function(key, value, cb) {\n  fs.readFile(cst.PM2_MODULE_CONF_FILE, function(err, data) {\n    if (err) return cb(err);\n\n    var json_conf = JSON.parse(data);\n\n    var values = splitKey(key);\n\n    if (values.length > 0) {\n      var levels = values;\n\n      var tmp = json_conf;\n\n      levels.forEach(function(key, index) {\n        if (index == levels.length -1)\n          tmp[key] = value;\n        else if (!tmp[key]) {\n          tmp[key] = {};\n          tmp = tmp[key];\n        }\n        else {\n          if (typeof(tmp[key]) != 'object')\n            tmp[key] = {};\n          tmp = tmp[key];\n        }\n      });\n\n    }\n    else {\n      if (json_conf[key] && typeof(json_conf[key]) === 'string')\n        Common.printOut(cst.PREFIX_MSG + 'Replacing current value key %s by %s', key, value);\n\n      json_conf[key] = value;\n    }\n\n    fs.writeFile(cst.PM2_MODULE_CONF_FILE, JSON.stringify(json_conf, null, 4), function(err, data) {\n      if (err) return cb(err);\n\n      return cb(null, json_conf);\n    });\n    return false;\n  });\n};\n\nConfiguration.unset = function(key, cb) {\n  fs.readFile(cst.PM2_MODULE_CONF_FILE, function(err, data) {\n    if (err) return cb(err);\n\n    var json_conf = JSON.parse(data);\n\n    var values = splitKey(key);\n\n    if (values.length > 0) {\n      var levels = values;\n\n      var tmp = json_conf;\n\n      levels.forEach(function(key, index) {\n        if (index == levels.length -1)\n          delete tmp[key];\n        else if (!tmp[key]) {\n          tmp[key] = {};\n          tmp = tmp[key];\n        }\n        else {\n          if (typeof(tmp[key]) != 'object')\n            tmp[key] = {};\n          tmp = tmp[key];\n        }\n      });\n\n    }\n    else\n      delete json_conf[key];\n\n    if (err) return cb(err);\n\n    if (key === 'all')\n      json_conf = {};\n\n    fs.writeFile(cst.PM2_MODULE_CONF_FILE, JSON.stringify(json_conf), function(err, data) {\n      if (err) return cb(err);\n\n      return cb(null, json_conf);\n    });\n    return false;\n  });\n}\n\nConfiguration.setSync = function(key, value) {\n  try {\n    var data = fs.readFileSync(cst.PM2_MODULE_CONF_FILE);\n  } catch(e) {\n    return null;\n  }\n\n  var json_conf = JSON.parse(data);\n\n  var values = splitKey(key);\n\n  if (values.length > 0) {\n    var levels = values;\n\n    var tmp = json_conf;\n\n    levels.forEach(function(key, index) {\n      if (index == levels.length -1)\n        tmp[key] = value;\n      else if (!tmp[key]) {\n        tmp[key] = {};\n        tmp = tmp[key];\n      }\n      else {\n        if (typeof(tmp[key]) != 'object')\n          tmp[key] = {};\n        tmp = tmp[key];\n      }\n    });\n\n  }\n  else {\n    if (json_conf[key] && typeof(json_conf[key]) === 'string')\n      Common.printOut(cst.PREFIX_MSG + 'Replacing current value key %s by %s', key, value);\n\n    json_conf[key] = value;\n  }\n\n  if (key === 'all')\n    json_conf = {};\n\n  try {\n    fs.writeFileSync(cst.PM2_MODULE_CONF_FILE, JSON.stringify(json_conf));\n    return json_conf;\n  } catch(e) {\n    console.error(e.message);\n    return null;\n  }\n};\n\nConfiguration.unsetSync = function(key) {\n  try {\n    var data = fs.readFileSync(cst.PM2_MODULE_CONF_FILE);\n  } catch(e) {\n    return null;\n  }\n\n  var json_conf = JSON.parse(data);\n\n  var values = splitKey(key);\n\n  if (values.length > 0) {\n    var levels = values;\n\n    var tmp = json_conf;\n\n    levels.forEach(function(key, index) {\n      if (index == levels.length -1)\n        delete tmp[key];\n      else if (!tmp[key]) {\n        tmp[key] = {};\n        tmp = tmp[key];\n      }\n      else {\n        if (typeof(tmp[key]) != 'object')\n          tmp[key] = {};\n        tmp = tmp[key];\n      }\n    });\n\n  }\n  else\n    delete json_conf[key];\n\n  if (key === 'all')\n    json_conf = {};\n\n  try {\n    fs.writeFileSync(cst.PM2_MODULE_CONF_FILE, JSON.stringify(json_conf));\n  } catch(e) {\n    console.error(e.message);\n    return null;\n  }\n};\n\nConfiguration.multiset = function(serial, cb) {\n  var arrays = [];\n  serial = serial.match(/(?:[^ \"]+|\"[^\"]*\")+/g);\n\n  while (serial.length > 0)\n    arrays.push(serial.splice(0, 2));\n\n  async.eachSeries(arrays, function(el, next) {\n    Configuration.set(el[0], el[1], next);\n  }, cb);\n};\n\nConfiguration.get = function(key, cb) {\n  Configuration.getAll(function(err, data) {\n    var climb = splitKey(key);\n\n    climb.some(function(val) {\n      if (!data[val]) {\n        data = null;\n        return true;\n      }\n      data = data[val];\n      return false;\n    });\n\n    if (!data) return cb({err : 'Unknown key'}, null);\n    return cb(null, data);\n  });\n};\n\nConfiguration.getSync = function(key) {\n  try {\n    var data = Configuration.getAllSync();\n  } catch(e) {\n    return null;\n  }\n\n  var climb = splitKey(key);\n\n  climb.some(function(val) {\n    if (!data[val]) {\n      data = null;\n      return true;\n    }\n    data = data[val];\n    return false;\n  });\n\n  if (!data) return null;\n  return data;\n};\n\nConfiguration.getAll = function(cb) {\n  fs.readFile(cst.PM2_MODULE_CONF_FILE, function(err, data) {\n    if (err) return cb(err);\n    return cb(null, JSON.parse(data));\n  });\n};\n\nConfiguration.getAllSync = function() {\n  try {\n    return JSON.parse(fs.readFileSync(cst.PM2_MODULE_CONF_FILE));\n  } catch(e) {\n    console.error(e.stack || e);\n    return {};\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/Utility.js":"/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\n\nvar fclone = require('fclone');\nvar fs     = require('fs');\nvar path   = require('path');\nvar cst    = require('../constants.js');\nvar async  = require('async');\nvar util   = require('util');\n\nvar Utility = module.exports = {\n  getDate : function() {\n    return Date.now();\n  },\n  extendExtraConfig : function(proc, opts) {\n    if (opts.env && opts.env.current_conf) {\n      Utility.extend(proc.pm2_env, opts.env.current_conf);\n      delete opts.env.current_conf;\n    }\n  },\n  formatCLU : function(process) {\n    if (!process.pm2_env) {\n      return process;\n    }\n\n    var obj = Utility.clone(process.pm2_env);\n    delete obj.env;\n\n    return obj;\n  },\n  extend : function(destination, source){\n    if (!source || typeof source != 'object') return destination;\n\n      Object.keys(source).forEach(function(new_key) {\n        if (source[new_key] != '[object Object]')\n          destination[new_key] = source[new_key];\n      });\n\n    return destination;\n  },\n  whichFileExists : function(file_arr) {\n    var f = null;\n\n    file_arr.some(function(file) {\n      try {\n        fs.statSync(file);\n      } catch(e) {\n        return false;\n      }\n      f = file;\n      return true;\n    });\n    return f;\n  },\n  clone     : function(obj) {\n    if (obj === null || obj === undefined) return {};\n    return fclone(obj);\n  },\n  overrideConsole : function(bus) {\n    if (cst.PM2_LOG_DATE_FORMAT && typeof cst.PM2_LOG_DATE_FORMAT == 'string'){\n      var moment = require('moment');\n\n      // Generate timestamp prefix\n      function timestamp(){\n        return moment().format(cst.PM2_LOG_DATE_FORMAT) + ': ';\n      }\n\n      var hacks = ['info', 'log', 'error', 'warn'], consoled = {};\n\n      // store console functions.\n      hacks.forEach(function(method){\n        consoled[method] = console[method];\n      });\n\n      hacks.forEach(function(k){\n        console[k] = function(){\n          if (bus) {\n            bus.emit('log:PM2', {\n              process : {\n                pm_id      : 'PM2',\n                name       : 'PM2',\n                rev        : null\n              },\n              at  : Utility.getDate(),\n              data : util.format.apply(this, arguments) + '\\n'\n            });\n          }\n          // do not destroy variable insertion\n          arguments[0] && (arguments[0] = timestamp() + arguments[0]);\n          consoled[k].apply(console, arguments);\n        };\n      });\n    }\n  },\n  startLogging : function(stds, callback) {\n    /**\n     * Start log outgoing messages\n     * @method startLogging\n     * @param {} callback\n     * @return\n     */\n    // Make sure directories of `logs` and `pids` exist.\n    // try {\n    //   ['logs', 'pids'].forEach(function(n){\n    //     console.log(n);\n    //     (function(_path){\n    //       !fs.existsSync(_path) && fs.mkdirSync(_path, '0755');\n    //     })(path.resolve(cst.PM2_ROOT_PATH, n));\n    //   });\n    // } catch(err) {\n    //   return callback(new Error('can not create directories (logs/pids):' + err.message));\n    // }\n\n    // waterfall.\n    var flows = [];\n    // types of stdio, should be sorted as `std(entire log)`, `out`, `err`.\n    var types = Object.keys(stds).sort(function(x, y){\n      return -x.charCodeAt(0) + y.charCodeAt(0);\n    });\n\n    // Create write streams.\n    (function createWS(io){\n      if(io.length != 1){\n        return false;\n      }\n      io = io[0];\n\n      // If `std` is a Stream type, try next `std`.\n      // compatible with `pm2 reloadLogs`\n      if(typeof stds[io] == 'object' && !isNaN(stds[io].fd)){\n        return createWS(types.splice(0, 1));\n      }\n\n      flows.push(function(next){\n        var file = stds[io];\n        // if file contains ERR or /dev/null, dont try to create stream since he dont want logs\n        if (!file || file.indexOf('NULL') > -1 || file.indexOf('/dev/null') > -1)\n          return next();\n        stds[io] = fs.createWriteStream(file, {flags: 'a'})\n          .on('error', function(err){\n            next(err);\n          })\n          .on('open', function(){\n            next();\n          });\n        stds[io]._file = file;\n      });\n      return createWS(types.splice(0, 1));\n    })(types.splice(0, 1));\n\n    async.waterfall(flows, callback);\n  },\n  /**\n   * Returns the module name from a .tgz package name (or the original name if it is not a valid pkg).\n   * @param {string} package_name The package name (e.g. \"foo.tgz\", \"foo-1.0.0.tgz\", \"folder/foo.tgz\")\n   * @return {string} the name\n   */\n  packageNameToModuleName: function(package_name) {\n    if (package_name.match(/^(.+\\/)?([^\\/]+)\\.tgz($|\\?)/)) {\n      package_name = package_name.match(/^(.+\\/)?([^\\/]+)\\.tgz($|\\?)/)[2];\n      if (package_name.match(/^(.+)-[0-9]+\\.[0-9]+\\.[0-9]+(-[a-zA-Z0-9_]+\\.[0-9]+)?$/)) {\n        package_name = package_name.match(/^(.+)-[0-9]+\\.[0-9]+\\.[0-9]+(-[a-zA-Z0-9_]+\\.[0-9]+)?$/)[1];\n      }\n    }\n    return package_name;\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/API/Deploy.js":"/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\n\nvar fs      = require('fs');\nvar Deploy  = require('pm2-deploy');\n\nvar cst     = require('../../constants.js');\nvar Utility = require('../Utility.js');\nvar Common  = require('../Common.js');\n\nfunction deployHelper() {\n  console.log('');\n  console.log('-----> Helper: Deployment with PM2');\n  console.log('');\n  console.log('  Generate a sample ecosystem.config.js with the command');\n  console.log('  $ pm2 ecosystem');\n  console.log('  Then edit the file depending on your needs');\n  console.log('');\n  console.log('  Commands:');\n  console.log('    setup                run remote setup commands');\n  console.log('    update               update deploy to the latest release');\n  console.log('    revert [n]           revert to [n]th last deployment or 1');\n  console.log('    curr[ent]            output current release commit');\n  console.log('    prev[ious]           output previous release commit');\n  console.log('    exec|run <cmd>       execute the given <cmd>');\n  console.log('    list                 list previous deploy commits');\n  console.log('    [ref]                deploy to [ref], the \"ref\" setting, or latest tag');\n  console.log('');\n  console.log('');\n  console.log('  Basic Examples:');\n  console.log('');\n  console.log('    First initialize remote production host:');\n  console.log('    $ pm2 deploy ecosystem.config.js production setup');\n  console.log('');\n  console.log('    Then deploy new code:');\n  console.log('    $ pm2 deploy ecosystem.config.js production');\n  console.log('');\n  console.log('    If I want to revert to the previous commit:');\n  console.log('    $ pm2 deploy ecosystem.config.js production revert 1');\n  console.log('');\n  console.log('    Execute a command on remote server:');\n  console.log('    $ pm2 deploy ecosystem.config.js production exec \"pm2 restart all\"');\n  console.log('');\n  console.log('    PM2 will look by default to the ecosystem.config.js file so you dont need to give the file name:');\n  console.log('    $ pm2 deploy production');\n  console.log('    Else you have to tell PM2 the name of your ecosystem file');\n  console.log('');\n  console.log('    More examples in https://github.com/Unitech/pm2');\n  console.log('');\n};\n\nmodule.exports = function(CLI) {\n  CLI.prototype.deploy = function(file, commands, cb) {\n    var that = this;\n\n    if (file == 'help') {\n      deployHelper();\n      return cb ? cb() : that.exitCli(cst.SUCCESS_EXIT);\n    }\n\n    var args = commands.rawArgs;\n    var env;\n\n    args.splice(0, args.indexOf('deploy') + 1);\n\n    // Find ecosystem file by default\n    if (!Common.isConfigFile(file)) {\n      env = args[0];\n      file = Utility.whichFileExists(['ecosystem.config.js', 'ecosystem.json', 'ecosystem.json5', 'package.json']);\n\n      if (!file) {\n        Common.printError('Not any default deployment file exists');\n        return cb ? cb('Not any default ecosystem file present') : that.exitCli(cst.ERROR_EXIT);\n      }\n    }\n    else\n      env = args[1];\n\n    var json_conf = null;\n\n    try {\n      json_conf = Common.parseConfig(fs.readFileSync(file), file);\n    } catch (e) {\n      Common.printError(e);\n      return cb ? cb(e) : that.exitCli(cst.ERROR_EXIT);\n    }\n\n    if (!env) {\n      deployHelper();\n      return cb ? cb() : that.exitCli(cst.SUCCESS_EXIT);\n    }\n\n    if (!json_conf.deploy || !json_conf.deploy[env]) {\n      Common.printError('%s environment is not defined in %s file', env, file);\n      return cb ? cb('%s environment is not defined in %s file') : that.exitCli(cst.ERROR_EXIT);\n    }\n\n    if (!json_conf.deploy[env]['post-deploy']) {\n      json_conf.deploy[env]['post-deploy'] = 'pm2 startOrRestart ' + file + ' --env ' + env;\n    }\n\n    Deploy.deployForEnv(json_conf.deploy, env, args, function(err, data) {\n      if (err) {\n        Common.printError('Deploy failed');\n        return cb ? cb(err) : that.exitCli(cst.ERROR_EXIT);\n      }\n      Common.printOut('--> Success');\n      return cb ? cb(null, data) : that.exitCli(cst.SUCCESS_EXIT);\n    });\n  };\n\n};\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2-deploy/deploy.js":"var fs = require('fs');\nvar tv4 = require('tv4');\nvar async = require('async');\nvar childProcess = require('child_process');\nvar path = require('path');\n\n/**\n * Spawn a modified version of visionmedia/deploy\n *\n * @param {string} hostJSON: config string to be piped to deploy\n * @param {array}  args: custom deploy command-line arguments\n * @callback cb\n */\nfunction spawn(hostJSON, args, cb) {\n  var shellSyntaxCommand = \"echo '\" + hostJSON + \"' | \\\"\" + __dirname.replace(/\\\\/g, '/') + \"/deploy\\\" \" + args.join(' ');\n  var proc = childProcess.spawn('sh', ['-c', shellSyntaxCommand], { stdio: 'inherit' });\n\n  proc.on('error', function(e) {\n    return cb(e.stack || e);\n  });\n\n  proc.on('close', function(code) {\n    if (code == 0) return cb(null, args);\n    else return cb(code);\n  });\n}\n\n/**\n * Deploy to a single environment\n *\n * @param {object} deploy_conf: object containing deploy configs for all environments\n * @param {string} env: the name of the environment to deploy to\n * @param {array}  args: custom deploy command-line arguments\n * @callback cb\n */\nfunction deployForEnv(deploy_conf, env, args, cb) {\n  if (!deploy_conf[env]) return cb(env + ' not defined in deploy section');\n\n  var piped_data  = JSON.stringify(deploy_conf[env]);\n  var target_conf = JSON.parse(piped_data); //effectively clones the conf\n\n  if(target_conf.ssh_options) {\n    var ssh_opt = '';\n    if(Array.isArray(target_conf.ssh_options)) {\n      ssh_opt = '-o ' + target_conf.ssh_options.join(' -o ');\n    } else {\n      ssh_opt = '-o ' + target_conf.ssh_options;\n    }\n    target_conf.ssh_options = ssh_opt;\n  }\n\n  if (!tv4.validate(target_conf, {\n    required: [\"user\", \"host\", \"repo\", \"path\", \"ref\"]\n  })) {\n    return cb(tv4.error);\n  }\n\n  if (process.env.NODE_ENV !== 'test') {\n    console.log('--> Deploying to %s environment', env);\n  }\n\n  if (process.platform !== 'win32' && process.platform !== 'win64')\n    target_conf.path = path.resolve(target_conf.path);\n\n  if (Array.isArray(target_conf.host)) {\n    async.series(target_conf.host.reduce(function(jobs, host) {\n      jobs.push(function(done) {\n\n        if (process.env.NODE_ENV !== 'test') {\n          console.log('--> on host %s', host.host ? host.host : host);\n        }\n\n        target_conf.host = host;\n\n        var custom_data = JSON.stringify(target_conf);\n\n        spawn(custom_data, args, done);\n      });\n      return jobs;\n    }, []), cb);\n  }\n  else {\n    if (process.env.NODE_ENV !== 'test') {\n      console.log('--> on host %s', target_conf.host);\n    }\n    spawn(JSON.stringify(target_conf), args, cb);\n  }\n\n  return false;\n}\n\nfunction run() {\n  var conf    = JSON.parse(fs.readFileSync('app.json'));\n  var args    = process.argv;\n\n  if (args.indexOf('deploy') == -1)\n    throw new Error('deploy argument not found');\n\n  args.splice(0, args.indexOf('deploy') + 1);\n\n  var env = args[0];\n\n  Deploy.deployForEnv(conf.deploy, env, args, function(err, data) {\n    console.log(arguments);\n  });\n}\n\nmodule.exports = {\n  deployForEnv: deployForEnv\n};\n\nif (require.main === module) {\n  run();\n}\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/API/Modules/Modules.js":"\n/***************************\n *\n * Module methods\n *\n **************************/\n\nvar cst         = require('../../../constants.js');\nvar Common      = require('../../Common.js');\nvar UX          = require('../CliUx');\nvar chalk       = require('chalk');\nvar async       = require('async');\n\nvar shelljs       = require('shelljs');\nvar path          = require('path');\nvar fs            = require('fs');\nvar p             = path;\nvar Configuration = require('../../Configuration.js');\nvar Utility       = require('../../Utility.js');\n\nvar MODULE_CONF_PREFIX = 'module-db';\n\nvar Modularizer = require('./Modularizer.js');\n\n// Special module with post display\nfunction postDisplay(app, cb) {\n  var that = this;\n  var retry = 0;\n\n  UX.processing.start('Initializing module');\n\n  (function detectModuleInit() {\n    retry++;\n    if (retry > 12) {\n      // Module init has timeouted\n      return displayOrNot(null);\n    }\n    that.describe(app.pm_id, function(err, data) {\n\n      if (data && data[0] && data[0].pm2_env &&\n          data[0].pm2_env.axm_options &&\n          data[0].pm2_env.axm_options.human_info) {\n        return displayOrNot(data[0]);\n      }\n      setTimeout(function() {\n        detectModuleInit();\n      }, 300);\n    });\n  })();\n\n  function displayOrNot(app) {\n    UX.processing.stop();\n\n    if (app) {\n      var module_name = app.name;\n      var human_info = app.pm2_env.axm_options.human_info;\n\n      UX.postModuleInfos(module_name, human_info);\n      Common.printOut(chalk.white.italic(' Use `pm2 show %s` to display this helper'), module_name);\n      Common.printOut(chalk.white.italic(' Use `pm2 logs %s [--lines 1000]` to display logs'), module_name);\n      Common.printOut(chalk.white.italic(' Use `pm2 monit` to monitor CPU and Memory usage'), module_name);\n      return cb ? cb(null, app) : that.exitCli(cst.SUCCESS_EXIT);\n    }\n\n    return cb ? cb(null, { msg : 'Module started' }) : that.speedList(cst.SUCCESS_EXIT);\n  }\n}\n\nmodule.exports = function(CLI) {\n  /**\n   * Install / Update a module\n   */\n  CLI.prototype.install = function(module_name, cb) {\n    var that = this;\n\n    Modularizer.install(this, module_name, function(err, data) {\n      if (err) {\n        Common.printError(cst.PREFIX_MSG_ERR + (err.message || err));\n        return cb ? cb(Common.retErr(err)) : that.speedList(cst.ERROR_EXIT);\n      }\n\n      // Check if special module with post_install display\n      if (data && data[0] && data[0].pm2_env && data[0].pm2_env.PM2_EXTRA_DISPLAY) {\n        return postDisplay.call(that, data[0].pm2_env, cb);\n      }\n      return cb ? cb(null, data) : that.speedList(cst.SUCCESS_EXIT);\n    });\n  };\n\n  /**\n   * Uninstall a module\n   */\n  CLI.prototype.uninstall = function(module_name, cb) {\n    var that = this;\n\n    Modularizer.uninstall(this, module_name, function(err, data) {\n      if (err)\n        return cb ? cb(Common.retErr(err)) : that.speedList(cst.ERROR_EXIT);\n      return cb ? cb(null, data) : that.speedList(cst.SUCCESS_EXIT);\n    });\n  };\n\n  /**\n   * Publish module on NPM + Git push\n   */\n  CLI.prototype.publish = function(module_name, cb) {\n    var that = this;\n\n    Modularizer.publish(function(err, data) {\n      if (err)\n        return cb ? cb(Common.retErr(err)) : that.speedList(cst.ERROR_EXIT);\n      return cb ? cb(null, data) : that.speedList(cst.SUCCESS_EXIT);\n    });\n  };\n\n  /**\n   * Publish module on NPM + Git push\n   */\n  CLI.prototype.generateModuleSample = function(app_name, cb) {\n    var that = this;\n\n    Modularizer.generateSample(app_name, function(err, data) {\n      if (err)\n        return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);\n      return cb ? cb(null, data) : that.exitCli(cst.SUCCESS_EXIT);\n    });\n  };\n\n  CLI.prototype.killAllModules = function(cb) {\n    var that = this;\n\n    this.Client.getAllModulesId(function(err, modules_id) {\n      async.forEachLimit(modules_id, 1, function(id, next) {\n        that._operate('deleteProcessId', id, next);\n      }, function() {\n        return cb ? cb() : false;\n      });\n    });\n  };\n\n  CLI.prototype.deleteModule = function(module_name, cb) {\n    var that = this;\n\n    var found_proc = [];\n\n    this.Client.getAllProcess(function(err, procs) {\n      if (err) {\n        Common.printError('Error retrieving process list: ' + err);\n        return cb(Common.retErr(err));\n      }\n\n      procs.forEach(function(proc) {\n        if (proc.pm2_env.name == module_name && proc.pm2_env.pmx_module) {\n          found_proc.push(proc.pm_id);\n        }\n      });\n\n      if (found_proc.length == 0)\n        return cb();\n\n      that._operate('deleteProcessId', found_proc[0], function(err) {\n        if (err) return cb(Common.retErr(err));\n        Common.printOut('In memory process deleted');\n        return cb();\n      });\n    });\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/API/Configuration.js":"\nvar Password             = require('../Interactor/Password.js');\nvar Common               = require('../Common.js');\nvar cst                  = require('../../constants.js');\nvar UX                   = require('./CliUx');\nvar chalk                = require('chalk');\nvar async                = require('async');\nvar Configuration        = require('../Configuration.js');\n//@todo double check that imported methods works\nvar InteractorDaemonizer = require('../Interactor/InteractorDaemonizer');\n\nmodule.exports = function(CLI) {\n\n  CLI.prototype.get = function(key, cb) {\n    var that = this;\n\n    if (!key || key == 'all') {\n      that.displayConf(function(err, data) {\n        if (err)\n          return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);\n        return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);\n      });\n      return false;\n    }\n    Configuration.get(key, function(err, data) {\n      if (err) {\n        console.error(err);\n        return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);\n      }\n      // pm2 conf module-name\n      if (key.indexOf(':') === -1 && key.indexOf('.') === -1) {\n        displayConf(key, function() {\n          return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);\n        });\n        return false;\n      }\n      // pm2 conf module-name:key\n      var module_name, key_name;\n\n      if (key.indexOf(':') > -1) {\n        module_name = key.split(':')[0];\n        key_name    = key.split(':')[1];\n      } else if (key.indexOf('.') > -1) {\n        module_name = key.split('.')[0];\n        key_name    = key.split('.')[1];\n      }\n\n      Common.printOut('Value for module ' + chalk.blue(module_name), 'key ' + chalk.blue(key_name) + ': ' + chalk.bold.green(data));\n\n\n      return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);\n    });\n  };\n\n  CLI.prototype.set = function(key, value, cb) {\n    var that = this;\n\n    /**\n     * Specific when setting pm2 password\n     * Used for restricted remote actions\n     * Also alert Interactor that password has been set\n     */\n    if (key.indexOf('pm2:passwd') > -1) {\n      value = Password.generate(value);\n      Configuration.set(key, value, function(err) {\n        if (err)\n          return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);\n        InteractorDaemonizer.launchRPC(that._conf, function(err) {\n          if (err) {\n            displayConf('pm2', function() {\n              return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);\n            });\n            return false;\n          }\n          InteractorDaemonizer.rpc.passwordSet(function() {\n            InteractorDaemonizer.disconnectRPC(function() {\n              displayConf('pm2', function() {\n                return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);\n              });\n            });\n          });\n          return false;\n        });\n      });\n      return false;\n    }\n\n    /**\n     * Set value\n     */\n    Configuration.set(key, value, function(err) {\n      if (err)\n        return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);\n\n      var values = [];\n\n      if (key.indexOf('.') > -1)\n        values = key.split('.');\n\n      if (key.indexOf(':') > -1)\n        values = key.split(':');\n\n      if (values && values.length > 1) {\n        // The first element is the app name (module_conf.json)\n        var app_name = values[0];\n\n        process.env.PM2_PROGRAMMATIC = 'true';\n        that.restart(app_name, {\n          updateEnv : true\n        }, function(err, data) {\n          process.env.PM2_PROGRAMMATIC = 'false';\n          if (!err)\n            Common.printOut(cst.PREFIX_MSG + 'Module %s restarted', app_name);\n          displayConf(app_name, function() {\n            return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);\n          });\n        });\n        return false;\n      }\n      displayConf(null, function() {\n        return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);\n      });\n    });\n  };\n\n  CLI.prototype.multiset = function(serial, cb) {\n    var that = this;\n\n    Configuration.multiset(serial, function(err, data) {\n      if (err)\n        return cb ? cb({success:false, err:err}) : that.exitCli(cst.ERROR_EXIT);\n\n      var values = [];\n      var key = serial.match(/(?:[^ \"]+|\"[^\"]*\")+/g)[0];\n\n      if (key.indexOf('.') > -1)\n        values = key.split('.');\n\n      if (key.indexOf(':') > -1)\n        values = key.split(':');\n\n      if (values && values.length > 1) {\n        // The first element is the app name (module_conf.json)\n        var app_name = values[0];\n\n        process.env.PM2_PROGRAMMATIC = 'true';\n        that.restart(app_name, {\n          updateEnv : true\n        }, function(err, data) {\n          process.env.PM2_PROGRAMMATIC = 'false';\n          if (!err)\n            Common.printOut(cst.PREFIX_MSG + 'Module %s restarted', app_name);\n          displayConf(app_name, function() {\n            return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);\n          });\n        });\n        return false;\n      }\n      displayConf(app_name, function() {\n        return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);\n      });\n\n    });\n  };\n\n  CLI.prototype.unset = function(key, cb) {\n    var that = this;\n\n    Configuration.unset(key, function(err) {\n      if (err) {\n        return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);\n      }\n\n      displayConf(function() {\n        return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);\n      });\n    });\n  };\n\n  CLI.prototype.conf = function(key, value, cb) {\n    var that = this;\n\n    if (typeof(value) === 'function') {\n      cb = value;\n      value = null;\n    }\n\n    // If key + value = set\n    if (key && value) {\n      that.set(key, value, function(err) {\n        if (err)\n          return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);\n        return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);\n      });\n    }\n    // If only key = get\n    else if (key) {\n      that.get(key, function(err, data) {\n        if (err)\n          return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);\n        return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);\n      });\n    }\n    else {\n      displayConf(function(err, data) {\n        if (err)\n          return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);\n        return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);\n      });\n    }\n  };\n\n};\n\n\n/**\n * Configuration\n */\nfunction displayConf(target_app, cb) {\n  if (typeof(target_app) == 'function') {\n    cb = target_app;\n    target_app = null;\n  }\n\n  Configuration.getAll(function(err, data) {\n    UX.dispKeys(data, target_app);\n    return cb();\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/Interactor/Password.js":"/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\nvar crypto = require('crypto');\n\nvar saltChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\nvar saltCharsCount = saltChars.length;\n\nfunction generateSalt(len) {\n  if (typeof len != 'number' || len <= 0 || len !== parseInt(len, 10)) throw new Error('Invalid salt length');\n  if (crypto.randomBytes) {\n    return crypto.randomBytes(Math.ceil(len / 2)).toString('hex').substring(0, len);\n  } else {\n    for (var i = 0, salt = ''; i < len; i++) {\n      salt += saltChars.charAt(Math.floor(Math.random() * saltCharsCount));\n    }\n    return salt;\n  }\n}\n\nfunction generateHash(algorithm, salt, password, iterations) {\n  iterations = iterations || 1;\n  try {\n    var hash = password;\n    for(var i=0; i<iterations; ++i) {\n      hash = crypto.createHmac(algorithm, salt).update(hash).digest('hex');\n    }\n\n    return algorithm + '$' + salt + '$' + iterations + '$' + hash;\n  } catch (e) {\n    throw new Error('Invalid message digest algorithm');\n  }\n}\n\nfunction makeBackwardCompatible(hashedPassword) {\n  var parts = hashedPassword.split('$');\n  if(parts.length === 3) {\n    parts.splice(2,0,1);\n    hashedPassword = parts.join(\"$\");\n  }\n\n  return hashedPassword;\n}\n\nmodule.exports.generate = function(password, options) {\n  if (typeof password != 'string') throw new Error('Invalid password');\n  options || (options = {});\n  options.algorithm || (options.algorithm = 'sha1');\n  options.saltLength || options.saltLength == 0 || (options.saltLength = 8);\n  options.iterations || (options.iterations = 1);\n  var salt = generateSalt(options.saltLength);\n  return generateHash(options.algorithm, salt, password, options.iterations);\n};\n\nmodule.exports.verify = function(password, hashedPassword) {\n  if (!password || !hashedPassword) return false;\n  hashedPassword = makeBackwardCompatible(hashedPassword);\n  var parts = hashedPassword.split('$');\n  if (parts.length != 4) return false;\n  try {\n    return generateHash(parts[0], parts[1], password, parts[2]) == hashedPassword;\n  } catch (e) {}\n  return false;\n};\n\nmodule.exports.isHashed = function(password) {\n  if (!password) return false;\n  return password.split('$').length == 4;\n}\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/API/Extra.js":"\n/***************************\n *\n * Extra methods\n *\n **************************/\n\nvar cst         = require('../../constants.js');\nvar Common      = require('../Common.js');\nvar UX          = require('./CliUx');\nvar chalk       = require('chalk');\nvar async       = require('async');\nvar path        = require('path');\nvar fs          = require('fs');\n\nmodule.exports = function(CLI) {\n\n  /**\n   * Get version of the daemonized PM2\n   * @method getVersion\n   * @callback cb\n   */\n  CLI.prototype.getVersion = function(cb) {\n    var that = this;\n\n    that.Client.executeRemote('getVersion', {}, function(err) {\n      return cb ? cb.apply(null, arguments) : that.exitCli(cst.SUCCESS_EXIT);\n    });\n  };\n\n\n  /**\n   * Create PM2 memory snapshot\n   * @method getVersion\n   * @callback cb\n   */\n  CLI.prototype.snapshotPM2 = function(cb) {\n    var that = this;\n    var moment = require('moment');\n    var file = path.join(process.cwd(), moment().format('dd-HH:mm:ss') + '.heapsnapshot');\n\n    that.Client.executeRemote('snapshotPM2', {\n      pwd : file\n    }, function(err) {\n      if (err) {\n        console.error(err);\n        return that.exitCli(1);\n      }\n      console.log('Heapdump in %s', file);\n      return cb ? cb.apply(null, arguments) : that.exitCli(cst.SUCCESS_EXIT);\n    });\n  };\n\n\n  /**\n   * Create PM2 memory snapshot\n   * @method getVersion\n   * @callback cb\n   */\n  CLI.prototype.profilePM2 = function(command, cb) {\n    var that = this;\n    var moment = require('moment');\n    var file = path.join(process.cwd(), moment().format('dd-HH:mm:ss') + '.cpuprofile');\n\n    if (command == 'start') {\n      that.Client.executeRemote('profileStart', {\n      }, function(err) {\n        if (err) {\n          console.error(err);\n          return that.exitCli(1);\n        }\n        console.log('CPU profiling started, type pm2 profile stop once finished');\n        return cb ? cb.apply(null, arguments) : that.exitCli(cst.SUCCESS_EXIT);\n      });\n    }\n    else if (command == 'stop') {\n      that.Client.executeRemote('profileStop', {\n        pwd : file\n      }, function(err) {\n        if (err) {\n          console.error(err);\n          return that.exitCli(1);\n        }\n        console.log('CPU profile in %s', file);\n        return cb ? cb.apply(null, arguments) : that.exitCli(cst.SUCCESS_EXIT);\n      });\n    }\n  };\n\n  /**\n   * Description\n   * @method sendDataToProcessId\n   */\n  CLI.prototype.sendDataToProcessId = function(proc_id, packet, cb) {\n    var that = this;\n\n    packet.id = proc_id;\n\n    that.Client.executeRemote('sendDataToProcessId', packet, function(err, res) {\n      if (err) {\n        Common.printError(err);\n        return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);\n      }\n      Common.printOut('successfully sent data to process');\n      return cb ? cb(null, res) : that.speedList();\n    });\n  };\n\n  /**\n   * Used for custom actions, allows to trigger function inside an app\n   * To expose a function you need to use keymetrics/pmx\n   *\n   * @method msgProcess\n   * @param {Object} opts\n   * @param {String} id           process id\n   * @param {String} action_name  function name to trigger\n   * @param {Object} [opts.opts]  object passed as first arg of the function\n   * @param {String} [uuid]       optional unique identifier when logs are emitted\n   *\n   */\n  CLI.prototype.msgProcess = function(opts, cb) {\n    var that = this;\n\n    that.Client.executeRemote('msgProcess', opts, cb);\n  };\n\n  /**\n   * Trigger a PMX custom action in target application\n   * Custom actions allows to interact with an application\n   *\n   * @method trigger\n   * @param  {String|Number} pm_id       process id or application name\n   * @param  {String}        action_name name of the custom action to trigger\n   * @param  {Mixed}         params      parameter to pass to target action\n   * @param  {Function}      cb          callback\n   */\n  CLI.prototype.trigger = function(pm_id, action_name, params, cb) {\n    if (typeof(params) === 'function') {\n      cb = params;\n      params = null;\n    }\n    var cmd = {\n      msg : action_name\n    };\n    var counter = 0;\n    var process_wait_count = 0;\n    var that = this;\n    var results = [];\n\n    if (params)\n      cmd.opts = params;\n    if (isNaN(pm_id))\n      cmd.name = pm_id;\n    else\n      cmd.id = pm_id;\n\n    this.launchBus(function(err, bus) {\n      bus.on('axm:reply', function(ret) {\n        if (ret.process.name == pm_id || ret.process.pm_id == pm_id) {\n          results.push(ret);\n          Common.printOut('[%s:%s]=%j', ret.process.name, ret.process.pm_id, ret.data.return);\n          if (++counter == process_wait_count)\n            return cb ? cb(null, results) : that.exitCli(cst.SUCCESS_EXIT);\n        }\n      });\n\n      that.msgProcess(cmd, function(err, data) {\n        if (err) {\n          Common.printError(err);\n          return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);\n        }\n        process_wait_count = data.process_count;\n        Common.printOut(chalk.bold('%s processes have received command %s'),\n                        data.process_count, action_name);\n      });\n    });\n  };\n\n  /**\n   * Description\n   * @method sendSignalToProcessName\n   * @param {} signal\n   * @param {} process_name\n   * @return\n   */\n  CLI.prototype.sendSignalToProcessName = function(signal, process_name, cb) {\n    var that = this;\n\n    that.Client.executeRemote('sendSignalToProcessName', {\n      signal : signal,\n      process_name : process_name\n    }, function(err, list) {\n      if (err) {\n        Common.printError(err);\n        return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);\n      }\n      Common.printOut('successfully sent signal %s to process name %s', signal, process_name);\n      return cb ? cb(null, list) : that.speedList();\n    });\n  };\n\n  /**\n   * Description\n   * @method sendSignalToProcessId\n   * @param {} signal\n   * @param {} process_id\n   * @return\n   */\n  CLI.prototype.sendSignalToProcessId = function(signal, process_id, cb) {\n    var that = this;\n\n    that.Client.executeRemote('sendSignalToProcessId', {\n      signal : signal,\n      process_id : process_id\n    }, function(err, list) {\n      if (err) {\n        Common.printError(err);\n        return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);\n      }\n      Common.printOut('successfully sent signal %s to process id %s', signal, process_id);\n      return cb ? cb(null, list) : that.speedList();\n    });\n  };\n\n  /**\n   * Launch API interface\n   * @method web\n   * @return\n   */\n  CLI.prototype.web = function(port, cb) {\n    var that = this;\n\n    if (typeof(port) === 'function') {\n      cb = port;\n      port = 9615;\n    }\n\n    var filepath = path.resolve(path.dirname(module.filename), '../HttpInterface.js');\n\n    that.start({\n      script : filepath,\n      name : 'pm2-http-interface',\n      execMode : 'fork_mode',\n      env : {\n        PM2_WEB_PORT : port\n      }\n    }, function(err, proc) {\n      if (err) {\n        Common.printError(cst.PREFIX_MSG_ERR + 'Error while launching application', err.stack || err);\n        return cb ? cb(Common.retErr(err)) : that.speedList();\n      }\n      Common.printOut(cst.PREFIX_MSG + 'Process launched');\n      return cb ? cb(null, proc) : that.speedList();\n    });\n  };\n\n\n  /**\n   * API method to launch a process that will serve directory over http\n   *\n   * @param {Object} opts options\n   * @param {String} opts.path path to be served\n   * @param {Number} opts.port port on which http will bind\n   * @param {Function} cb optional callback\n   */\n  CLI.prototype.serve = function (target_path, port, opts, cb) {\n    var that = this;\n    var servePort = process.env.PM2_SERVE_PORT || port || 8080;\n    var servePath = path.resolve(process.env.PM2_SERVE_PATH || target_path || '.');\n\n    var filepath = path.resolve(path.dirname(module.filename), './Serve.js');\n\n    if (!opts.name || typeof(opts.name) == 'function')\n      opts.name = 'static-page-server-' + servePort;\n    if (!opts.env)\n      opts.env = {};\n    opts.env.PM2_SERVE_PORT = servePort;\n    opts.env.PM2_SERVE_PATH = servePath;\n    opts.cwd = servePath;\n\n    this.start(filepath, opts,  function (err, res) {\n      if (err) {\n        Common.printError(cst.PREFIX_MSG_ERR + 'Error while trying to serve : ' + err.message || err);\n        return cb ? cb(err) : that.speedList(cst.ERROR_EXIT);\n      }\n      Common.printOut(cst.PREFIX_MSG + 'Serving ' + servePath + ' on port ' + servePort);\n      return cb ? cb(null, res) : that.speedList();\n    });\n  }\n\n  /**\n   * Ping daemon - if PM2 daemon not launched, it will launch it\n   * @method ping\n   */\n  CLI.prototype.ping = function(cb) {\n    var that = this;\n\n    that.Client.executeRemote('ping', {}, function(err, res) {\n      if (err) {\n        Common.printError(err);\n        return cb ? cb(new Error(err)) : that.exitCli(cst.ERROR_EXIT);\n      }\n      Common.printOut(res);\n      return cb ? cb(null, res) : that.exitCli(cst.SUCCESS_EXIT);\n    });\n  };\n\n\n  /**\n   * Execute remote command\n   */\n  CLI.prototype.remote = function(command, opts, cb) {\n    var that = this;\n\n    that[command](opts.name, function(err_cmd, ret) {\n      if (err_cmd)\n        console.error(err_cmd);\n      console.log('Command %s finished', command);\n      return cb(err_cmd, ret);\n    });\n  };\n\n  /**\n   * This remote method allows to pass multiple arguments\n   * to PM2\n   * It is used for the new scoped PM2 action system\n   */\n  CLI.prototype.remoteV2 = function(command, opts, cb) {\n    var that = this;\n\n    if (that[command].length == 1)\n      return that[command](cb);\n\n    opts.args.push(cb);\n    return that[command].apply(this, opts.args);\n  };\n\n\n  /**\n   * Description\n   * @method generateSample\n   * @param {} name\n   * @return\n   */\n  CLI.prototype.generateSample = function(mode) {\n    var that = this;\n    var templatePath;\n\n    if (mode == 'simple')\n      templatePath = path.join(cst.TEMPLATE_FOLDER, cst.APP_CONF_TPL_SIMPLE);\n    else\n      templatePath = path.join(cst.TEMPLATE_FOLDER, cst.APP_CONF_TPL);\n\n    var sample = fs.readFileSync(templatePath);\n    var dt     = sample.toString();\n    var f_name = 'ecosystem.config.js';\n\t\tvar pwd = process.env.PWD || process.cwd();\n\n    try {\n      fs.writeFileSync(path.join(pwd, f_name), dt);\n    } catch (e) {\n      console.error(e.stack || e);\n      return that.exitCli(cst.ERROR_EXIT);\n    }\n    Common.printOut('File %s generated', path.join(pwd, f_name));\n    that.exitCli(cst.SUCCESS_EXIT);\n  };\n\n  /**\n   * Description\n   * @method dashboard\n   * @return\n   */\n  CLI.prototype.dashboard = function(cb) {\n    var that = this;\n\n    var Dashboard = require('./Dashboard');\n\n    if (cb) return cb(new Error('Dashboard cant be called programmatically'));\n\n    Dashboard.init();\n\n    this.Client.launchBus(function (err, bus) {\n      if (err) {\n          console.error('Error launchBus: ' + err);\n          that.exitCli(cst.ERROR_EXIT);\n      }\n      bus.on('log:*', function(type, data) {\n        Dashboard.log(type, data);\n      })\n    });\n\n    process.on('SIGINT', function() {\n      this.Client.disconnectBus(function() {\n        process.exit(cst.SUCCESS_EXIT);\n      });\n    });\n\n    function launchDashboard() {\n      that.Client.executeRemote('getMonitorData', {}, function(err, list) {\n        if (err) {\n          console.error('Error retrieving process list: ' + err);\n          that.exitCli(cst.ERROR_EXIT);\n        }\n\n        Dashboard.refresh(list);\n\n        setTimeout(function() {\n          launchDashboard();\n        }, 800);\n      });\n    }\n\n    launchDashboard();\n  };\n\n  CLI.prototype.monit = function(cb) {\n    var that = this;\n\n    var Monit = require('./Monit.js');\n\n    if (cb) return cb(new Error('Monit cant be called programmatically'));\n\n    Monit.init();\n\n    function launchMonitor() {\n      that.Client.executeRemote('getMonitorData', {}, function(err, list) {\n        if (err) {\n          console.error('Error retrieving process list: ' + err);\n          that.exitCli(conf.ERROR_EXIT);\n        }\n\n        Monit.refresh(list);\n\n        setTimeout(function() {\n          launchMonitor();\n        }, 400);\n      });\n    }\n\n    launchMonitor();\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/API/Version.js":"\nvar cst     = require('../../constants.js');\nvar Common  = require('../Common.js');\nvar fs      = require('fs');\nvar async   = require('async');\nvar vizion  = require('vizion');\nvar child   = require('child_process');\n\nvar printError = Common.printError;\nvar printOut = Common.printOut;\n\nmodule.exports = function(CLI) {\n\n  var EXEC_TIMEOUT = 60000; // Default: 1 min\n\n  CLI.prototype._pull = function(opts, cb) {\n    var that = this;\n\n    var process_name = opts.process_name;\n    var reload_type = opts.action;\n\n    printOut(cst.PREFIX_MSG + 'Updating repository for process name %s', process_name);\n\n    that.Client.getProcessByName(process_name, function(err, processes) {\n\n      if (processes.length === 0) {\n        printError('No processes with this name: %s', process_name);\n        return cb ? cb({msg:'Process not found: '+process_name}) : that.exitCli(cst.ERROR_EXIT);\n      }\n\n      var proc = processes[0];\n      if (!proc.pm2_env.versioning) {\n        printOut(cst.PREFIX_MSG + 'No versioning system found for process %s', process_name);\n        return cb ? cb({success:false, msg: 'No versioning system found for process'}) : that.exitCli(cst.SUCCESS_EXIT);\n      }\n      vizion.update({\n        folder: proc.pm2_env.versioning.repo_path\n      }, function(err, meta) {\n        if (err !== null) {\n          return cb ? cb({msg:err}) : that.exitCli(cst.ERROR_EXIT);\n        }\n\n        if (meta.success === true) {\n          getPostUpdateCmds(proc.pm2_env.versioning.repo_path, process_name, function (command_list) {\n            execCommands(proc.pm2_env.versioning.repo_path, command_list, function(err, res) {\n              if (err !== null) {\n                printError(err);\n                return cb ? cb({msg: meta.output + err}) : that.exitCli(cst.ERROR_EXIT);\n              }\n              else {\n                printOut(cst.PREFIX_MSG + 'Process successfully updated %s', process_name);\n                printOut(cst.PREFIX_MSG + 'Current commit %s', meta.current_revision);\n                return that[reload_type](process_name, function(err, procs) {\n                  if (err && cb) return cb(err);\n                  if (err) console.error(err);\n                  return cb ? cb(null, meta.output + res) : that.exitCli(cst.SUCCESS_EXIT);\n                });\n              }\n            });\n          });\n        }\n        else {\n          printOut(cst.PREFIX_MSG + 'Already up-to-date or an error occured for app: %s', process_name);\n          return cb ? cb({success:false, msg : 'Already up to date'}) : that.exitCli(cst.SUCCESS_EXIT);\n        }\n        return false;\n      });\n      return false;\n    });\n  };\n\n  /**\n   * CLI method for updating a repository to a specific commit id\n   * @method pullCommitId\n   * @param {string} process_name\n   * @param {string} commit_id\n   * @return\n   */\n  CLI.prototype.pullCommitId = function(process_name, commit_id, cb) {\n    var reload_type = 'reload';\n    var that = this;\n\n    printOut(cst.PREFIX_MSG + 'Updating repository for process name %s', process_name);\n\n    that.Client.getProcessByName(process_name, function(err, processes) {\n\n      if (processes.length === 0) {\n        printError('No processes with this name: %s', process_name);\n        return cb ? cb({msg:'Process not found: ' + process_name}) : that.exitCli(cst.ERROR_EXIT);\n      }\n\n      var proc = processes[0];\n      if (proc.pm2_env.versioning) {\n        vizion.isUpToDate({folder: proc.pm2_env.versioning.repo_path}, function(err, meta) {\n          if (err !== null)\n            return cb ? cb({msg:err}) : that.exitCli(cst.ERROR_EXIT);\n          vizion.revertTo(\n            {revision: commit_id,\n             folder: proc.pm2_env.versioning.repo_path},\n            function(err2, meta2) {\n              if (!err2 && meta2.success) {\n                getPostUpdateCmds(proc.pm2_env.versioning.repo_path, process_name, function (command_list) {\n                  execCommands(proc.pm2_env.versioning.repo_path, command_list, function(err, res) {\n                    if (err !== null)\n                    {\n                      printError(err);\n                      return cb ? cb({msg:err}) : that.exitCli(cst.ERROR_EXIT);\n                    }\n                    else {\n                      printOut(cst.PREFIX_MSG + 'Process successfully updated %s', process_name);\n                      printOut(cst.PREFIX_MSG + 'Current commit %s', commit_id);\n                      return that[reload_type](process_name, cb);\n                    }\n                  });\n                });\n              }\n              else {\n                printOut(cst.PREFIX_MSG + 'Already up-to-date or an error occured: %s', process_name);\n                return cb ? cb(null, {success:meta.success}) : that.exitCli(cst.SUCCESS_EXIT);\n              }\n            });\n        });\n      }\n      else {\n        printOut(cst.PREFIX_MSG + 'No versioning system found for process %s', process_name);\n        return cb ? cb(null, {success:false}) : that.exitCli(cst.SUCCESS_EXIT);\n      }\n    });\n  };\n\n  /**\n   * CLI method for downgrading a repository to the previous commit (older)\n   * @method backward\n   * @param {string} process_name\n   * @return\n   */\n  CLI.prototype.backward = function(process_name, cb) {\n    var that = this;\n    printOut(cst.PREFIX_MSG + 'Downgrading to previous commit repository for process name %s', process_name);\n\n    that.Client.getProcessByName(process_name, function(err, processes) {\n\n      if (processes.length === 0) {\n        printError('No processes with this name: %s', process_name);\n        return cb ? cb({msg:'Process not found: '+process_name}) : that.exitCli(cst.ERROR_EXIT);\n      }\n\n      var proc = processes[0];\n\n      if (proc.pm2_env.versioning === undefined ||\n          proc.pm2_env.versioning === null)\n        return cb({msg : 'Versioning unknown'});\n\n      vizion.prev({\n        folder: proc.pm2_env.versioning.repo_path\n      }, function(err, meta) {\n        if (err)\n          return cb ? cb({msg:err, data : meta}) : that.exitCli(cst.ERROR_EXIT);\n\n        if (meta.success !== true) {\n          printOut(cst.PREFIX_MSG + 'No versioning system found for process %s', process_name);\n          return cb ? cb({msg:err, data : meta}) : that.exitCli(cst.ERROR_EXIT);;\n        }\n\n        getPostUpdateCmds(proc.pm2_env.versioning.repo_path, process_name, function (command_list) {\n          execCommands(proc.pm2_env.versioning.repo_path, command_list, function(err, res) {\n            if (err !== null) {\n              vizion.next({folder: proc.pm2_env.versioning.repo_path}, function(err2, meta2) {\n                printError(err);\n                return cb ? cb({msg: meta.output + err}) : that.exitCli(cst.ERROR_EXIT);\n              });\n              return false;\n            }\n\n            printOut(cst.PREFIX_MSG + 'Process successfully updated %s', process_name);\n            printOut(cst.PREFIX_MSG + 'Current commit %s', meta.current_revision);\n            that.reload(process_name, function(err, procs) {\n              if (err) return cb(err);\n              return cb ? cb(null, meta.output + res) : that.exitCli(cst.SUCCESS_EXIT);\n            });\n          });\n        });\n      });\n    });\n  };\n\n  /**\n   * CLI method for updating a repository to the next commit (more recent)\n   * @method forward\n   * @param {string} process_name\n   * @return\n   */\n  CLI.prototype.forward = function(process_name, cb) {\n    var that = this;\n    printOut(cst.PREFIX_MSG + 'Updating to next commit repository for process name %s', process_name);\n\n    that.Client.getProcessByName(process_name, function(err, processes) {\n\n      if (processes.length === 0) {\n        printError('No processes with this name: %s', process_name);\n        return cb ? cb({msg:'Process not found: '+process_name}) : that.exitCli(cst.ERROR_EXIT);\n      }\n\n      var proc = processes[0];\n      if (proc.pm2_env.versioning) {\n        vizion.next({folder: proc.pm2_env.versioning.repo_path}, function(err, meta) {\n          if (err !== null)\n            return cb ? cb({msg:err}) : that.exitCli(cst.ERROR_EXIT);\n          if (meta.success === true) {\n            getPostUpdateCmds(proc.pm2_env.versioning.repo_path, process_name, function (command_list) {\n              execCommands(proc.pm2_env.versioning.repo_path, command_list, function(err, res) {\n                if (err !== null)\n                {\n                  vizion.prev({folder: proc.pm2_env.versioning.repo_path}, function(err2, meta2) {\n                    printError(err);\n                    return cb ? cb({msg:meta.output + err}) : that.exitCli(cst.ERROR_EXIT);\n                  });\n                }\n                else {\n                  printOut(cst.PREFIX_MSG + 'Process successfully updated %s', process_name);\n                  printOut(cst.PREFIX_MSG + 'Current commit %s', meta.current_revision);\n                  that.reload(process_name, function(err, procs) {\n                    if (err) return cb(err);\n                    return cb ? cb(null, meta.output + res) : that.exitCli(cst.SUCCESS_EXIT);\n                  });\n                }\n              });\n            });\n          }\n          else {\n            printOut(cst.PREFIX_MSG + 'Already up-to-date or an error occured: %s', process_name);\n            return cb ? cb(null, {success:meta.success}) : that.exitCli(cst.SUCCESS_EXIT);\n          }\n        });\n      }\n      else {\n        printOut(cst.PREFIX_MSG + 'No versioning system found for process %s', process_name);\n        return cb ? cb({success:false, msg: 'No versioning system found'}) : that.exitCli(cst.SUCCESS_EXIT);\n      }\n    });\n  };\n\n  var exec = function (cmd, callback) {\n    var output = '';\n\n    var c = child.exec(cmd, {\n      env: process.env,\n      maxBuffer: 3*1024*1024,\n      timeout: EXEC_TIMEOUT\n    }, function(err) {\n      if (callback)\n        callback(err ? err.code : 0, output);\n    });\n\n    c.stdout.on('data', function(data) {\n      output += data;\n    });\n\n    c.stderr.on('data', function(data) {\n      output += data;\n    });\n  };\n\n  /**\n   *\n   * @method execCommands\n   * @param {string} repo_path\n   * @param {object} command_list\n   * @return\n   */\n  var execCommands = function(repo_path, command_list, cb) {\n    var stdout = '';\n\n    async.eachSeries(command_list, function(command, callback) {\n      stdout += '\\n' + command;\n      exec('cd '+repo_path+';'+command,\n           function(code, output) {\n             stdout += '\\n' + output;\n             if (code === 0)\n               callback();\n             else\n               callback('`'+command+'` failed');\n           });\n    }, function(err) {\n      if (err)\n        return cb(stdout + '\\n' + err);\n      return cb(null, stdout);\n    });\n  }\n\n  /**\n   * Description Search process.json for post-update commands\n   * @method getPostUpdateCmds\n   * @param {string} repo_path\n   * @param {string} proc_name\n   * @return\n   */\n  var getPostUpdateCmds = function(repo_path, proc_name, cb) {\n    if (typeof repo_path !== 'string')\n      return cb([]);\n    if (repo_path[repo_path.length - 1] !== '/')\n      repo_path += '/';\n\n    var searchForCommands = function(file, callback) {\n      fs.exists(repo_path+file, function(exists) {\n        if (exists) {\n          try {\n            var conf_string = fs.readFileSync(repo_path + file);\n            var data = Common.parseConfig(conf_string, repo_path + file);\n          } catch (e) {\n            console.error(e.message || e);\n          }\n\n          if (data && data.apps) {\n            async.eachSeries(data.apps, function(item, callb) {\n              if (item.name && item.name === proc_name) {\n                if (item.post_update && typeof(item.post_update) === 'object') {\n                  if (item.exec_timeout)\n                    EXEC_TIMEOUT = parseInt(item.exec_timeout);\n                  return callb(item.post_update);\n                }\n                else {\n                  return callb();\n                }\n              }\n              else\n                return callb();\n            }, function(final) {\n              return callback(final);\n            });\n          }\n          else {\n            return callback();\n          }\n        }\n        else {\n          return callback();\n        }\n      });\n    };\n\n    async.eachSeries(['ecosystem.json', 'process.json', 'package.json'], searchForCommands,\n                     function(final) {\n                       return cb(final ? final : []);\n                     });\n  };\n\n\n  /**\n   * CLI method for updating a repository\n   * @method pullAndRestart\n   * @param {string} process_name name of processes to pull\n   * @return\n   */\n  CLI.prototype.pullAndRestart = function (process_name, cb) {\n    this._pull({process_name: process_name, action: 'reload'}, cb);\n  };\n\n  /**\n   * CLI method for updating a repository\n   * @method pullAndReload\n   * @param {string} process_name name of processes to pull\n   * @return\n   */\n  CLI.prototype.pullAndReload = function (process_name, cb) {\n    this._pull({process_name: process_name, action: 'reload'}, cb);\n  };\n\n  /**\n   * CLI method for updating a repository\n   * @method pullAndGracefulReload\n   * @param {string} process_name name of processes to pull\n   * @return\n   */\n  CLI.prototype.pullAndGracefulReload = function (process_name, cb) {\n    this._pull({process_name: process_name, action: 'gracefulReload'}, cb);\n  };\n\n  /**\n   * CLI method for updating a repository to a specific commit id\n   * @method pullCommitId\n   * @param {object} opts\n   * @return\n   */\n  CLI.prototype._pullCommitId = function (opts, cb) {\n    this.pullCommitId(opts.pm2_name, opts.commit_id, cb);\n  };\n\n}\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/API/Startup.js":"/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\nvar debug  = require('debug')('pm2:cli:startup');\nvar chalk  = require('chalk');\nvar path   = require('path');\nvar fs     = require('fs');\nvar async  = require('async');\nvar exec   = require('child_process').exec;\nvar Common = require('../Common.js');\nvar cst    = require('../../constants.js');\nvar spawn    = require('child_process').spawn;\nvar shelljs  = require('shelljs');\n\nmodule.exports = function(CLI) {\n  /**\n   * If command is launched without root right\n   * Display helper\n   */\n  function isNotRoot(platform, opts, cb) {\n    if (opts.user) {\n      console.log(cst.PREFIX_MSG + 'You have to run this command as root. Execute the following command:');\n      console.log('sudo env PATH=$PATH:' + path.dirname(process.execPath) + ' pm2 ' + opts.args[1].name() + ' ' + platform + ' -u ' + opts.user + ' --hp ' + process.env.HOME);\n      return cb(new Error('You have to run this with elevated rights'));\n    }\n    return exec('whoami', function(err, stdout, stderr) {\n      console.log(cst.PREFIX_MSG + 'You have to run this command as root. Execute the following command:');\n      console.log('sudo env PATH=$PATH:' + path.dirname(process.execPath) + ' ' + require.main.filename + ' ' + opts.args[1].name() + ' ' + platform + ' -u ' + stdout.trim() + ' --hp ' + process.env.HOME);\n      return cb(new Error('You have to run this with elevated rights'));\n    });\n  }\n\n  /**\n   * Detect running init system\n   */\n  function detectInitSystem() {\n    var hash_map = {\n      'systemctl'  : 'systemd',\n      'update-rc.d': 'upstart',\n      'chkconfig'  : 'systemv',\n      'rc-update'  : 'openrc',\n      'launchctl'  : 'launchd'\n    };\n    var init_systems = Object.keys(hash_map);\n\n    for (var i = 0; i < init_systems.length; i++) {\n      if (shelljs.which(init_systems[i]) != null) {\n        break;\n      }\n    }\n\n    if (i >= init_systems.length) {\n      Common.printError(cst.PREFIX_MSG_ERR + 'Init system not found');\n      return null;\n    }\n    Common.printOut(cst.PREFIX_MSG + 'Init System found: ' + chalk.bold(hash_map[init_systems[i]]));\n    return hash_map[init_systems[i]];\n  }\n\n  CLI.prototype.uninstallStartup = function(platform, opts, cb) {\n    var commands;\n    var that = this;\n    var actual_platform = detectInitSystem();\n    var user = opts.user || process.env.USER;\n    var service_name = 'pm2-' + user;\n    var launchd_service_name = 'pm2.' + user;\n\n    if (!platform)\n      platform = actual_platform;\n    else if (actual_platform && actual_platform !== platform) {\n      console.log('-----------------------------------------------------------')\n      console.log(' PM2 detected ' + actual_platform + ' but you precised ' + platform)\n      console.log(' Please verify that your choice is indeed your init system')\n      console.log(' If you arent sure, just run : pm2 startup')\n      console.log('-----------------------------------------------------------')\n    }\n    if (platform === null)\n      throw new Error('Init system not found')\n\n    if (!cb) {\n      cb = function(err, data) {\n        if (err)\n          return that.exitCli(cst.ERROR_EXIT);\n        return that.exitCli(cst.SUCCESS_EXIT);\n      }\n    }\n\n    if (process.getuid() != 0) {\n      return isNotRoot(platform, opts, cb);\n    }\n\n    if (fs.existsSync('/etc/init.d/pm2-init.sh')) {\n      platform = 'oldsystem';\n    }\n\n    switch(platform) {\n    case 'systemd':\n      commands = [\n        'systemctl stop ' + service_name,\n        'systemctl disable ' + service_name,\n        'rm /etc/systemd/system/' + service_name + '.service'\n      ];\n      break;\n    case 'systemv':\n      commands = [\n        'chkconfig ' + service_name + ' off',\n        'rm /etc/init.d/' + service_name\n      ];\n      break;\n    case 'oldsystem':\n      Common.printOut(cst.PREFIX_MSG + 'Disabling and deleting old startup system');\n      commands = [\n        'update-rc.d pm2-init.sh disable',\n        'update-rc.d -f pm2-init.sh remove',\n        'rm /etc/init.d/pm2-init.sh'\n      ];\n      break;\n    case 'openrc':\n      commands = [\n\t      '/etc/init.d/' + service_name + ' stop',\n        'rc-update delete ' + service_name + ' default',\n        'rm /etc/init.d/' + service_name\n      ];\n      break;\n    case 'upstart':\n      commands = [\n        'update-rc.d ' + service_name + ' disable',\n        'update-rc.d -f ' + service_name + ' remove',\n        'rm /etc/init.d/' + service_name\n      ];\n      break;\n    case 'launchd':\n      var destination = path.join(process.env.HOME, 'Library/LaunchAgents/' + launchd_service_name + '.plist');\n      commands = [\n        'launchctl remove com.' + launchd_service_name,\n        'rm ' + destination\n      ];\n    };\n\n    shelljs.exec(commands.join('&& '), function(code, stdout, stderr) {\n      console.log(stdout);\n      console.log(stderr);\n      if (code == 0) {\n        Common.printOut(cst.PREFIX_MSG + chalk.bold('Init file disabled.'));\n      } else {\n        Common.printOut(cst.ERROR_MSG + chalk.bold('Return code : ' + code));\n      }\n\n      cb(null, {\n        commands : commands,\n        platform : platform\n      });\n    });\n  };\n\n  /**\n   * Startup script generation\n   * @method startup\n   * @param {string} platform type (centos|redhat|amazon|gentoo|systemd)\n   */\n  CLI.prototype.startup = function(platform, opts, cb) {\n    var that = this;\n    var actual_platform = detectInitSystem();\n    var user = (opts.user || process.env.USER);\n    var service_name = 'pm2-' + user;\n    var launchd_service_name = 'pm2.' + user;\n\n    if (!platform)\n      platform = actual_platform;\n    else if (actual_platform && actual_platform !== platform) {\n      console.log('-----------------------------------------------------------')\n      console.log(' PM2 detected ' + actual_platform + ' but you precised ' + platform)\n      console.log(' Please verify that your choice is indeed your init system')\n      console.log(' If you arent sure, just run : pm2 startup')\n      console.log('-----------------------------------------------------------')\n    }\n    if (platform == null)\n      throw new Error('Init system not found');\n\n    if (!cb) {\n      cb = function(err, data) {\n        if (err)\n          return that.exitCli(cst.ERROR_EXIT);\n        return that.exitCli(cst.SUCCESS_EXIT);\n      }\n    }\n\n    if (process.getuid() != 0) {\n      return isNotRoot(platform, opts, cb);\n    }\n\n    var destination;\n    var commands;\n    var template;\n\n    function getTemplate(type) {\n      return fs.readFileSync(path.join(__dirname, '..', 'templates/init-scripts', type + '.tpl'), {encoding: 'utf8'});\n    }\n\n    switch(platform) {\n    case 'ubuntu':\n    case 'centos':\n    case 'arch':\n    case 'oracle':\n    case 'systemd':\n      template = getTemplate('systemd');\n      destination = '/etc/systemd/system/' + service_name + '.service';\n      commands = [\n        'chmod +x ' + destination,\n        'systemctl enable ' + service_name,\n        'systemctl start ' + service_name,\n        'systemctl daemon-reload',\n        'systemctl status ' + service_name\n      ];\n      break;\n    case 'ubuntu14':\n    case 'ubuntu12':\n    case 'upstart':\n      template = getTemplate('upstart');\n      destination = '/etc/init.d/' + service_name;\n      commands = [\n        'chmod +x ' + destination,\n        'mkdir -p /var/lock/subsys',\n        'touch /var/lock/subsys/' + service_name,\n        'update-rc.d ' + service_name + ' defaults'\n      ];\n      break;\n    case 'systemv':\n    case 'amazon':\n    case 'centos6':\n      template = getTemplate('upstart');\n      destination = '/etc/init.d/' + service_name;\n      commands = [\n        'chmod +x ' + destination,\n        'mkdir -p /var/lock/subsys',\n        'touch /var/lock/subsys/' + service_name,\n        'chkconfig --add ' + service_name,\n        'chkconfig ' + service_name + ' on',\n        'initctl list'\n      ];\n      break;\n    case 'macos':\n    case 'darwin':\n    case 'launchd':\n      template = getTemplate('launchd');\n      destination = path.join(process.env.HOME, 'Library/LaunchAgents/' + launchd_service_name + '.plist');\n      commands = [\n        'launchctl load -w ' + destination\n      ]\n      break;\n    case 'freebsd':\n    case 'rcd':\n      template = getTemplate('rcd');\n      destination = '/etc/rc.d/' + service_name;\n      commands = [\n        'chmod +x ' + destination,\n        'echo \"pm2_enable=YES\" >> /etc/rc.conf'\n      ];\n      break;\n    case 'openrc':\n      template = getTemplate('openrc');\n      destination = '/etc/init.d/' + service_name;\n      commands = [\n        'chmod +x ' + destination,\n\t      'rc-update add ' + service_name + ' default'\n      ];\n      break;\n    default:\n      throw new Error('Unknown platform / init system name');\n    }\n\n    /**\n     * 4# Replace template variable value\n     */\n    template = template.replace(/%PM2_PATH%/g, process.mainModule.filename)\n      .replace(/%NODE_PATH%/g, path.dirname(process.execPath))\n      .replace(/%USER%/g, user)\n      .replace(/%HOME_PATH%/g, opts.hp ? path.resolve(opts.hp, '.pm2') : cst.PM2_ROOT_PATH);\n\n    console.log(chalk.bold('Platform'), platform);\n    console.log(chalk.bold('Template'));\n    console.log(template);\n    console.log(chalk.bold('Target path'));\n    console.log(destination);\n    console.log(chalk.bold('Command list'));\n    console.log(commands);\n\n    Common.printOut(cst.PREFIX_MSG + 'Writing init configuration in ' + destination);\n    try {\n      fs.writeFileSync(destination, template);\n    } catch (e) {\n      console.error(cst.PREFIX_MSG_ERR + 'Failure when trying to write startup script');\n      console.error(e.message || e);\n      return cb(e);\n    }\n\n    Common.printOut(cst.PREFIX_MSG + 'Making script booting at startup...');\n\n    async.forEachLimit(commands, 1, function(command, next) {\n      console.log(chalk.bold('>>> Executing %s'), command);\n      shelljs.exec(command, function(code, stdout, stderr) {\n        if (code === 0) {\n          console.log(chalk.bold('[DONE] '));\n          return next();\n        } else {\n          console.log(chalk.red('[ERROR] Exit code : ' + code))\n          return next(new Error(command + ' failed, see error above.'));\n        }\n      })\n    }, function(err) {\n      if (err) {\n        console.error(cst.PREFIX_MSG_ERR + (err.message || err));\n        return cb(err);\n      }\n      console.log(chalk.bold.blue('+---------------------------------------+'));\n      Common.printOut(chalk.bold.blue((cst.PREFIX_MSG + 'Freeze a process list on reboot via:' )));\n      Common.printOut(chalk.bold('$ pm2 save'));\n      console.log('');\n      Common.printOut(chalk.bold.blue(cst.PREFIX_MSG + 'Remove init script via:'));\n      Common.printOut(chalk.bold('$ pm2 unstartup ' + platform));\n\n      return cb(null, {\n        destination  : destination,\n        template : template\n      });\n    });\n  };\n\n  /**\n   * Dump current processes managed by pm2 into DUMP_FILE_PATH file\n   * @method dump\n   * @param {} cb\n   * @return\n   */\n  CLI.prototype.dump = function(cb) {\n    var env_arr = [];\n    var that = this;\n\n\n    Common.printOut(cst.PREFIX_MSG + 'Saving current process list...');\n\n    that.Client.executeRemote('getMonitorData', {}, function(err, list) {\n      if (err) {\n        Common.printError('Error retrieving process list: ' + err);\n        return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);\n      }\n\n      /**\n       * Description\n       * @method fin\n       * @param {} err\n       * @return\n       */\n      function fin(err) {\n        try {\n          fs.writeFileSync(cst.DUMP_FILE_PATH, JSON.stringify(env_arr, '', 2));\n        } catch (e) {\n          console.error(e.stack || e);\n          Common.printOut(cst.PREFIX_MSG_ERR + 'Failed to save dump file in %s', cst.DUMP_FILE_PATH);\n          return that.exitCli(cst.ERROR_EXIT);\n        }\n        if (cb) return cb(null, {success:true});\n\n        Common.printOut(cst.PREFIX_MSG + 'Successfully saved in %s', cst.DUMP_FILE_PATH);\n        return that.exitCli(cst.SUCCESS_EXIT);\n      }\n\n      (function ex(apps) {\n        if (!apps[0]) return fin(null);\n        delete apps[0].pm2_env.instances;\n        delete apps[0].pm2_env.pm_id;\n        if (!apps[0].pm2_env.pmx_module)\n          env_arr.push(apps[0].pm2_env);\n        apps.shift();\n        return ex(apps);\n      })(list);\n    });\n  };\n\n  /**\n   * Resurrect processes\n   * @method resurrect\n   * @param {} cb\n   * @return\n   */\n  CLI.prototype.resurrect = function(cb) {\n    var apps = {};\n    var that = this;\n\n    Common.printOut(cst.PREFIX_MSG + 'Restoring processes located in %s', cst.DUMP_FILE_PATH);\n\n    try {\n      apps = fs.readFileSync(cst.DUMP_FILE_PATH);\n    } catch(e) {\n      Common.printError(cst.PREFIX_MSG_ERR + 'No processes saved; DUMP file doesn\\'t exist');\n      // if (cb) return cb(Common.retErr(e));\n      // else return that.exitCli(cst.ERROR_EXIT);\n      return that.speedList();\n    }\n\n    var processes = Common.parseConfig(apps, 'none');\n\n    that.Client.executeRemote('getMonitorData', {}, function(err, list) {\n      if (err) {\n        Common.printError(err);\n        return that.exitCli(1);\n      }\n\n      var current = [];\n      var target = [];\n\n      list.forEach(function(app) {\n        if (!current[app.name])\n          current[app.name] = 0;\n        current[app.name]++;\n      });\n\n      processes.forEach(function(app) {\n        if (!target[app.name])\n          target[app.name] = 0;\n        target[app.name]++;\n      });\n\n      var tostart = Object.keys(target).filter(function(i) {\n        return Object.keys(current).indexOf(i) < 0;\n      })\n\n      async.eachLimit(processes, cst.CONCURRENT_ACTIONS, function(app, next) {\n        if (tostart.indexOf(app.name) == -1)\n          return next();\n        that.Client.executeRemote('prepare', app, function(err, dt) {\n          if (err)\n            Common.printError(err);\n          else\n            Common.printOut(cst.PREFIX_MSG + 'Process %s restored', app.pm_exec_path);\n          next();\n        });\n      }, function(err) {\n        return cb ? cb(null, apps) : that.speedList();\n      });\n    });\n  };\n\n}\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/API/LogManagement.js":"var chalk  = require('chalk');\nvar util   = require('util');\nvar fs     = require('fs');\nvar exec   = require('child_process').exec;\nvar path   = require('path');\n\nvar Log    = require('./Log');\nvar cst    = require('../../constants.js');\nvar Common = require('../Common.js');\n\nmodule.exports = function(CLI) {\n\n  /**\n   * Description\n   * @method flush\n   * @return\n   */\n  CLI.prototype.flush = function(cb) {\n    var that = this;\n\n    Common.printOut(cst.PREFIX_MSG + 'Flushing ' + cst.PM2_LOG_FILE_PATH);\n    fs.closeSync(fs.openSync(cst.PM2_LOG_FILE_PATH, 'w'));\n\n    that.Client.executeRemote('getMonitorData', {}, function(err, list) {\n      if (err) {\n        Common.printError(err);\n        return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);\n      }\n      list.forEach(function(l) {\n        Common.printOut(cst.PREFIX_MSG + 'Flushing');\n        Common.printOut(cst.PREFIX_MSG + l.pm2_env.pm_out_log_path);\n        Common.printOut(cst.PREFIX_MSG + l.pm2_env.pm_err_log_path);\n\n        if (l.pm2_env.pm_log_path) {\n          Common.printOut(cst.PREFIX_MSG + l.pm2_env.pm_log_path);\n          fs.closeSync(fs.openSync(l.pm2_env.pm_log_path, 'w'));\n        }\n\n        fs.closeSync(fs.openSync(l.pm2_env.pm_out_log_path, 'w'));\n        fs.closeSync(fs.openSync(l.pm2_env.pm_err_log_path, 'w'));\n      });\n      Common.printOut(cst.PREFIX_MSG + 'Logs flushed');\n      return cb ? cb(null, list) : that.exitCli(cst.SUCCESS_EXIT);\n    });\n  };\n\n  CLI.prototype.logrotate = function(opts, cb) {\n    var that = this;\n\n    if (process.getuid() != 0) {\n      return exec('whoami', function(err, stdout, stderr) {\n        Common.printError(cst.PREFIX_MSG + 'You have to run this command as root. Execute the following command:');\n        Common.printError(cst.PREFIX_MSG + chalk.grey('      sudo env PATH=$PATH:' + path.dirname(process.execPath) + ' pm2 logrotate -u ' + stdout.trim()));\n\n        cb ? cb(Common.retErr('You have to run this with elevated rights')) : that.exitCli(cst.ERROR_EXIT);\n      });\n    }\n\n    if (!fs.existsSync('/etc/logrotate.d')) {\n      Common.printError(cst.PREFIX_MSG + '/etc/logrotate.d does not exist we can not copy the default configuration.');\n      return cb ? cb(Common.retErr('/etc/logrotate.d does not exist')) : that.exitCli(cst.ERROR_EXIT);\n    }\n\n    var templatePath = path.join(cst.TEMPLATE_FOLDER, cst.LOGROTATE_SCRIPT);\n    Common.printOut(cst.PREFIX_MSG + 'Getting logrorate template ' + templatePath);\n    var script = fs.readFileSync(templatePath, {encoding: 'utf8'});\n\n    var user = opts.user || 'root';\n\n    script = script.replace(/%HOME_PATH%/g, cst.PM2_ROOT_PATH)\n      .replace(/%USER%/g, user);\n\n    try {\n      fs.writeFileSync('/etc/logrotate.d/pm2-'+user, script);\n    } catch (e) {\n      console.error(e.stack || e);\n    }\n\n    Common.printOut(cst.PREFIX_MSG + 'Logrotate configuration added to /etc/logrotate.d/pm2');\n    return cb ? cb(null, {success:true}) : that.exitCli(cst.SUCCESS_EXIT);\n  };\n\n  /**\n   * Description\n   * @method reloadLogs\n   * @return\n   */\n  CLI.prototype.reloadLogs = function(cb) {\n    var that = this;\n\n    Common.printOut('Reloading all logs...');\n    that.Client.executeRemote('reloadLogs', {}, function(err, logs) {\n      if (err) {\n        Common.printError(err);\n        return cb ? cb(Common.retErr(err)) : that.exitCli(cst.ERROR_EXIT);\n      }\n      Common.printOut('All logs reloaded');\n      return cb ? cb(null, logs) : that.exitCli(cst.SUCCESS_EXIT);\n    });\n  };\n\n  /**\n   * Description\n   * @method streamLogs\n   * @param {String} id\n   * @param {Number} lines\n   * @param {Boolean} raw\n   * @return\n   */\n  CLI.prototype.streamLogs = function(id, lines, raw, timestamp, exclusive) {\n    var that = this;\n    var files_list = [];\n\n    // If no argument is given, we stream logs for all running apps\n    id = id || 'all';\n    lines = lines !== undefined ? lines : 20;\n    lines = lines < 0 ? -(lines) : lines;\n\n    // Avoid duplicates and check if path is different from '/dev/null'\n    var pushIfUnique = function(entry) {\n      var exists = false;\n\n      if (entry.path.toLowerCase\n          && entry.path.toLowerCase() !== '/dev/null') {\n\n        files_list.some(function(file) {\n          if (file.path === entry.path)\n            exists = true;\n          return exists;\n        });\n\n        if (exists)\n          return;\n\n        files_list.push(entry);\n      }\n    }\n\n    // Get the list of all running apps\n    that.Client.executeRemote('getMonitorData', {}, function(err, list) {\n      if (err) {\n        Common.printError(err);\n        that.exitCli(cst.ERROR_EXIT);\n      }\n\n      if (lines === 0 || raw)\n        return Log.stream(that.Client, id, raw, timestamp, exclusive);\n\n      Common.printOut(chalk.bold.grey(util.format.call(this, '[TAILING] Tailing last %d lines for [%s] process%s (change the value with --lines option)', lines, id, id === 'all' ? 'es' : '')));\n\n      // Populate the array `files_list` with the paths of all files we need to tail\n      list.forEach(function(proc) {\n        if (proc.pm2_env && (id === 'all' ||\n                             proc.pm2_env.name == id ||\n                             proc.pm2_env.pm_id == id)) {\n          if (proc.pm2_env.pm_out_log_path && exclusive !== 'err')\n            pushIfUnique({\n              path     : proc.pm2_env.pm_out_log_path,\n              app_name :proc.pm2_env.pm_id + '|' + proc.pm2_env.name,\n              type     : 'out'});\n          if (proc.pm2_env.pm_err_log_path && exclusive !== 'out')\n            pushIfUnique({\n              path     : proc.pm2_env.pm_err_log_path,\n              app_name : proc.pm2_env.pm_id + '|' + proc.pm2_env.name,\n              type     : 'err'\n            });\n        }\n      });\n\n      if (!raw && (id === 'all' || id === 'PM2') && exclusive === false) {\n        Log.tail([{\n          path     : cst.PM2_LOG_FILE_PATH,\n          app_name : 'PM2',\n          type     : 'PM2'\n        }], lines, raw, function() {\n          Log.tail(files_list, lines, raw, function() {\n            Log.stream(that.Client, id, raw, timestamp, exclusive);\n          });\n        });\n      }\n      else {\n        Log.tail(files_list, lines, raw, function() {\n          Log.stream(that.Client, id, raw, timestamp, exclusive);\n        });\n      }\n    });\n  };\n\n  /**\n   * Description\n   * @method printLogs\n   * @param {String} id\n   * @param {Number} lines\n   * @param {Boolean} raw\n   * @return\n   */\n  CLI.prototype.printLogs = function(id, lines, raw, timestamp, exclusive) {\n    var that = this;\n    var files_list = [];\n\n    // If no argument is given, we stream logs for all running apps\n    id = id || 'all';\n    lines = lines !== undefined ? lines : 20;\n    lines = lines < 0 ? -(lines) : lines;\n\n    // Avoid duplicates and check if path is different from '/dev/null'\n    var pushIfUnique = function(entry) {\n      var exists = false;\n\n      if (entry.path.toLowerCase\n          && entry.path.toLowerCase() !== '/dev/null') {\n\n        files_list.some(function(file) {\n          if (file.path === entry.path)\n            exists = true;\n          return exists;\n        });\n\n        if (exists)\n          return;\n\n        files_list.push(entry);\n      }\n    }\n\n    // Get the list of all running apps\n    that.Client.executeRemote('getMonitorData', {}, function(err, list) {\n      if (err) {\n        Common.printError(err);\n        that.exitCli(cst.ERROR_EXIT);\n      }\n\n      if (lines <= 0) {\n        return that.exitCli(cst.SUCCESS_EXIT)\n      }\n\n      Common.printOut(chalk.bold.grey(util.format.call(this, '[TAILING] Tailing last %d lines for [%s] process%s (change the value with --lines option)', lines, id, id === 'all' ? 'es' : '')));\n\n      // Populate the array `files_list` with the paths of all files we need to tail\n      list.forEach(function(proc) {\n        if (proc.pm2_env && (id === 'all' ||\n                             proc.pm2_env.name == id ||\n                             proc.pm2_env.pm_id == id)) {\n          if (proc.pm2_env.pm_out_log_path && exclusive !== 'err')\n            pushIfUnique({\n              path     : proc.pm2_env.pm_out_log_path,\n              app_name :proc.pm2_env.pm_id + '|' + proc.pm2_env.name,\n              type     : 'out'});\n          if (proc.pm2_env.pm_err_log_path && exclusive !== 'out')\n            pushIfUnique({\n              path     : proc.pm2_env.pm_err_log_path,\n              app_name : proc.pm2_env.pm_id + '|' + proc.pm2_env.name,\n              type     : 'err'\n            });\n        }\n      });\n\n      if (!raw && (id === 'all' || id === 'PM2') && exclusive === false) {\n        Log.tail([{\n          path     : cst.PM2_LOG_FILE_PATH,\n          app_name : 'PM2',\n          type     : 'PM2'\n        }], lines, raw, function() {\n          Log.tail(files_list, lines, raw, function() {\n            that.exitCli(cst.SUCCESS_EXIT);\n          });\n        });\n      }\n      else {\n        Log.tail(files_list, lines, raw, function() {\n          that.exitCli(cst.SUCCESS_EXIT);\n        });\n      }\n    });\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/API/Log.js":"/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\nvar fs     = require('fs'),\n    util   = require('util'),\n    chalk  = require('chalk'),\n    async  = require('async'),\n    moment = require('moment');\n\nvar Log = module.exports = {};\n\nvar DEFAULT_PADDING = '          ';\n\n/**\n * Tail logs from file stream.\n * @param {Object} apps_list\n * @param {Number} lines\n * @param {Boolean} raw\n * @param {Function} callback\n * @return\n */\n\nLog.tail = function(apps_list, lines, raw, callback) {\n  var that = this;\n\n  if (lines === 0 || apps_list.length === 0)\n    return callback && callback();\n\n  var count = 0;\n\n  var getLastLines = function (filename, lines, callback) {\n    var chunk = '';\n    var size = Math.max(0, fs.statSync(filename).size - (lines * 200));\n\n    var fd = fs.createReadStream(filename, {start : size});\n    fd.on('data', function(data) { chunk += data.toString(); });\n    fd.on('end', function() {\n      chunk = chunk.split('\\n').slice(-(lines+1));\n      chunk.pop();\n      callback(chunk);\n    });\n  };\n\n  apps_list.sort(function(a, b) {\n    return (fs.existsSync(a.path) ? fs.statSync(a.path).mtime.valueOf() : 0) -\n      (fs.existsSync(b.path) ? fs.statSync(b.path).mtime.valueOf() : 0);\n  });\n\n  async.forEachLimit(apps_list, 1, function(app, next) {\n    if (!fs.existsSync(app.path || ''))\n      return next();\n\n    getLastLines(app.path, lines, function(output) {\n      console.log(chalk.grey('%s last %d lines:'), app.path, lines);\n      output.forEach(function(out) {\n        if (raw)\n          return console.log(out);\n        if (app.type === 'out')\n          process.stdout.write(chalk.green(pad(DEFAULT_PADDING, app.app_name)  + ' | '));\n        else if (app.type === 'err')\n          process.stdout.write(chalk.red(pad(DEFAULT_PADDING, app.app_name)  + ' | '));\n        else\n          process.stdout.write(chalk.blue(pad(DEFAULT_PADDING, 'PM2') + ' | '));\n        console.log(out);\n      });\n      if (output.length)\n        process.stdout.write('\\n');\n      next();\n    });\n  }, function() {\n    callback && callback();\n  });\n};\n\n/**\n * Stream logs in realtime from the bus eventemitter.\n * @param {String} id\n * @param {Boolean} raw\n * @return\n */\n\nLog.stream = function(Client, id, raw, timestamp, exclusive) {\n  var that = this;\n\n  if (!raw)\n    console.log(chalk.bold.grey(util.format.call(this, '[STREAMING] Now streaming realtime logs for [%s] process%s', id, id === 'all' ? 'es' : '')));\n\n  Client.launchBus(function(err, bus, socket) {\n\n    socket.on('reconnect attempt', function() {\n      if (global._auto_exit === true) {\n        if (timestamp)\n          process.stdout.write(chalk['dim'](chalk.grey(moment().format(timestamp) + ' ')));\n        process.stdout.write(chalk.blue(pad(DEFAULT_PADDING, 'PM2') + ' | ') + '[[[ Target PM2 killed. ]]]');\n        process.exit(0);\n      }\n    });\n\n    bus.on('log:*', function(type, packet) {\n      if (id !== 'all'\n          && packet.process.name != id\n          && packet.process.pm_id != id)\n        return;\n\n      if ((type === 'out' && exclusive === 'err')\n         || (type === 'err' && exclusive === 'out')\n         || (type === 'PM2' && exclusive !== false))\n        return;\n\n      var lines;\n\n      if (typeof(packet.data) === 'string')\n        lines = (packet.data || '').split('\\n');\n      else\n        return;\n\n      lines.forEach(function(line) {\n        if (!line) return;\n\n        if (raw)\n          return process.stdout.write(util.format(line) + '\\n');\n\n        if (timestamp)\n          process.stdout.write(chalk['dim'](chalk.grey(moment().format(timestamp) + ' ')));\n\n        var name = packet.process.pm_id + '|' + packet.process.name;\n\n        if (type === 'out')\n          process.stdout.write(chalk.green(pad(DEFAULT_PADDING, name)  + ' | '));\n        else if (type === 'err')\n          process.stdout.write(chalk.red(pad(DEFAULT_PADDING, name)  + ' | '));\n        else if (!raw && (id === 'all' || id === 'PM2'))\n          process.stdout.write(chalk.blue(pad(DEFAULT_PADDING, 'PM2') + ' | '));\n        process.stdout.write(util.format(line) + '\\n');\n      });\n    });\n  });\n};\n\nLog.devStream = function(Client, id, raw, timestamp, exclusive) {\n  var that = this;\n\n  Client.launchBus(function(err, bus) {\n\n    setTimeout(function() {\n      bus.on('process:event', function(packet) {\n        if (packet.event == 'online')\n          console.log(chalk.green('[rundev] App %s restarted'), packet.process.name);\n      });\n    }, 1000);\n\n    bus.on('log:*', function(type, packet) {\n      if (id !== 'all'\n          && packet.process.name != id\n          && packet.process.pm_id != id)\n        return;\n\n      if ((type === 'out' && exclusive === 'err')\n          || (type === 'err' && exclusive === 'out')\n          || (type === 'PM2' && exclusive !== false))\n        return;\n\n      if (type === 'PM2')\n        return;\n\n      var name = packet.process.pm_id + '|' + packet.process.name;\n\n      var lines;\n\n      if (typeof(packet.data) === 'string')\n        lines = (packet.data || '').split('\\n');\n      else\n        return;\n\n      lines.forEach(function(line) {\n        if (!line) return;\n\n        if (raw)\n          return process.stdout.write(util.format(line) + '\\n');\n\n        if (timestamp)\n          process.stdout.write(chalk['dim'](chalk.grey(moment().format(timestamp) + ' ')));\n\n        var name = packet.process.name + '-' + packet.process.pm_id;\n\n        if (type === 'out')\n          process.stdout.write(chalk.green(pad(DEFAULT_PADDING, name)  + ' | '));\n        else if (type === 'err')\n          process.stdout.write(chalk.red(pad(DEFAULT_PADDING, name)  + ' | '));\n        else if (!raw && (id === 'all' || id === 'PM2'))\n          process.stdout.write(chalk.blue(pad(DEFAULT_PADDING, 'PM2') + ' | '));\n        process.stdout.write(util.format(line) + '\\n');\n      });\n    });\n  });\n};\n\nLog.jsonStream = function(Client, app_name) {\n  var that = this;\n\n  Client.launchBus(function(err, bus) {\n    if (err) console.error(err);\n\n    bus.on('process:event', function(packet) {\n      console.log(JSON.stringify({\n        timestamp : moment(packet.at),\n        type      : 'process_event',\n        status    : packet.event,\n        app_name  : packet.process.name\n      }));\n    });\n\n    bus.on('log:*', function(type, packet) {\n      if (app_name != 'all' && app_name && app_name != packet.process.name) return false;\n\n      if (typeof(packet.data) == 'string')\n        packet.data = packet.data.replace(/(\\r\\n|\\n|\\r)/gm,'');\n\n      console.log(JSON.stringify({\n        message : packet.data,\n        timestamp : moment(packet.at),\n        type : type,\n        process_id : packet.process.pm_id,\n        app_name : packet.process.name\n      }));\n    });\n  });\n};\n\nLog.formatStream = function(Client, id, raw, timestamp, exclusive) {\n  var that = this;\n\n  Client.launchBus(function(err, bus) {\n\n    bus.on('log:*', function(type, packet) {\n      if (id !== 'all'\n          && packet.process.name != id\n          && packet.process.pm_id != id)\n        return;\n\n      if ((type === 'out' && exclusive === 'err')\n          || (type === 'err' && exclusive === 'out')\n          || (type === 'PM2' && exclusive !== false))\n        return;\n\n      if (type === 'PM2' && raw)\n        return;\n\n      var name = packet.process.name + '-' + packet.process.pm_id;\n\n      var lines;\n\n      if (typeof(packet.data) === 'string')\n        lines = (packet.data || '').split('\\n');\n      else\n        return;\n\n      lines.forEach(function(line) {\n        if (!line) {\n          return;\n        }\n\n        if (!raw) {\n          if (timestamp)\n            process.stdout.write('timestamp=' + moment().format(timestamp) + ' ');\n          if (packet.process.name === 'PM2')\n            process.stdout.write('app=pm2 ');\n          if (packet.process.name !== 'PM2')\n            process.stdout.write('app=' + packet.process.name + ' id=' + packet.process.pm_id + ' ');\n          if (type === 'out')\n            process.stdout.write('type=out ');\n          else if (type === 'err')\n            process.stdout.write('type=error ');\n        }\n\n        process.stdout.write('message=');\n        process.stdout.write(util.format(line) + '\\n');\n      });\n    });\n  });\n};\n\nfunction printLines(lines) {\n}\n\nfunction pad(pad, str, padLeft) {\n  if (typeof str === 'undefined')\n    return pad;\n  if (padLeft) {\n    return (pad + str).slice(-pad.length);\n  } else {\n    return (str + pad).substring(0, pad.length);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/API/Interaction.js":"\nvar cst         = require('../../constants.js');\nvar Common      = require('../Common.js');\nvar UX          = require('./CliUx');\nvar chalk       = require('chalk');\nvar async       = require('async');\nvar path        = require('path');\nvar fs          = require('fs');\nvar KMDaemon    = require('../Interactor/InteractorDaemonizer');\n\nmodule.exports = function(CLI) {\n\n  var installServerMonit = function(CLI, cb) {\n    if (process.env.NO_SERVER_MONIT ||\n        process.env.NODE_ENV == 'test' ||\n        cst.IS_WINDOWS == true)\n      return cb();\n\n    CLI.Client.executeRemote('getMonitorData', {}, function(err, list) {\n      var installed = list.some(function(app) {\n        return app.name == 'pm2-server-monit';\n      });\n      if (installed == false)\n        CLI.install('pm2-server-monit', cb);\n      else cb();\n    })\n  };\n\n  /**\n   * Launch interactor\n   * For programmatic interaction\n   * http://pm2.keymetrics.io/docs/usage/use-pm2-with-cloud-providers/\n   * @method interact\n   * @param {string} secret_key\n   * @param {string} public_key\n   * @param {string} machine_name\n   */\n  CLI.prototype.interact = function(secret_key, public_key, machine_name, cb) {\n    var that = this;\n\n    KMDaemon.launchAndInteract(that._conf, {\n      secret_key   : secret_key || null,\n      public_key   : public_key || null,\n      machine_name : machine_name || null\n    }, function(err, dt) {\n      if (err) {\n        return cb ? cb(err) : that.exitCli(cst.ERROR_EXIT);\n      }\n      return cb ? cb(null, dt) : that.exitCli(cst.SUCCESS_EXIT);\n    });\n  };\n\n  CLI.prototype.interactInfos = function(cb) {\n    KMDaemon.getInteractInfo(this._conf, function(err, data) {\n      if (err)\n        return cb(Common.retErr(err));\n      return cb(null, data);\n    });\n  };\n\n  //\n  // Interact\n  //\n  CLI.prototype._pre_interact = function(cmd, public_key, machine, info_node) {\n    var that = this;\n\n    if (cmd == 'stop' || cmd == 'kill') {\n      console.log(chalk.cyan('[Keymetrics.io]') + ' Stopping agent...');\n      that.killInteract(function() {\n        console.log(chalk.cyan('[Keymetrics.io]') + ' Stopped');\n        return process.exit(cst.SUCCESS_EXIT);\n      });\n      return false;\n    }\n\n    if (cmd == 'info') {\n      console.log(chalk.cyan('[Keymetrics.io]') + ' Getting agent information...');\n      that.interactInfos(function(err, infos) {\n        if (err) {\n          console.error(err.message);\n          return that.exitCli(cst.ERROR_EXIT);\n        }\n        console.log(infos);\n        return that.exitCli(cst.SUCCESS_EXIT);\n      });\n      return false;\n    }\n\n    if (cmd == 'delete') {\n      that.killInteract(function() {\n        try {\n          fs.unlinkSync(cst.INTERACTION_CONF);\n        } catch(e) {\n          console.log(chalk.cyan('[Keymetrics.io]') + ' No interaction config file found');\n          return process.exit(cst.SUCCESS_EXIT);\n        }\n        console.log(chalk.cyan('[Keymetrics.io]') + ' Agent interaction ended');\n        return process.exit(cst.SUCCESS_EXIT);\n      });\n      return false;\n    }\n\n    if (cmd == 'start' || cmd == 'restart') {\n      KMDaemon.launchAndInteract(that._conf, {\n        public_key : null,\n        secret_key : null,\n        machine_name : null,\n        info_node : null\n      }, function(err, dt) {\n        if (err) {\n          Common.printError(err);\n          return that.exitCli(cst.ERROR_EXIT);\n        }\n        return that.exitCli(cst.SUCCESS_EXIT);\n      });\n    }\n\n    if (cmd && !public_key) {\n      console.error(chalk.cyan('[Keymetrics.io]') + ' Command [%s] unknown or missing public key', cmd);\n      return process.exit(cst.ERROR_EXIT);\n    }\n\n    var infos;\n\n    if (!cmd) {\n      infos = null;\n    }\n    else\n      infos = {\n        public_key : public_key,\n        secret_key : cmd,\n        machine_name : machine,\n        info_node : info_node.infoNode || null\n      }\n\n    KMDaemon.launchAndInteract(that._conf, infos, function(err, dt) {\n      if (err)\n        return that.exitCli(cst.ERROR_EXIT);\n      return that.exitCli(cst.SUCCESS_EXIT);\n    });\n  };\n\n  /**\n   * Kill interactor\n   * @method killInteract\n   */\n  CLI.prototype.killInteract = function(cb) {\n    var that = this;\n    KMDaemon.killInteractorDaemon(that._conf, function(err) {\n      return cb ? cb(Common.retErr('Interactor not launched')) : that.exitCli(cst.SUCCESS_EXIT);\n    });\n  };\n\n};\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/API/Containerizer.js":"\nvar spawn   = require('child_process').spawn;\nvar exec    = require('child_process').exec;\nvar crypto  = require('crypto');\nvar chalk   = require('chalk');\nvar util    = require('util');\nvar fmt     = require('../tools/fmt.js');\nvar vizion  = require('vizion');\nvar fs      = require('fs');\nvar path    = require('path');\nvar cst     = require('../../constants.js');\nvar Promise = require('../tools/promise.min.js');\n\nfunction pspawn(cmd) {\n  return new Promise(function(resolve, reject) {\n    var p_cmd = cmd.split(' ');\n\n    var install_instance = spawn(p_cmd[0], p_cmd.splice(1, cmd.length), {\n      stdio : 'inherit',\n      env : process.env,\n      shell : true\n    });\n\n    install_instance.on('close', function(code) {\n      if (code != 0) {\n        console.log(chalk.bold.red('Command failed'));\n        return reject(new Error('Bad cmd return'));\n      }\n      return resolve();\n    });\n\n    install_instance.on('error', function (err) {\n      return reject(err);\n    });\n  });\n}\n\nfunction checkDockerSetup() {\n  return new Promise(function(resolve, reject) {\n    exec(\"docker version -f '{{.Client.Version}}'\", function(err, stdout, stderr) {\n      if (err) {\n        console.error(chalk.red.bold('[Docker access] Error while trying to use docker command'));\n        if (err.message && err.message.indexOf('Cannot connect to the Docker') > -1) {\n          console.log();\n          console.log(chalk.blue.bold('[Solution] Setup Docker to be able to be used without sudo rights:'));\n          console.log(chalk.bold('$ sudo groupadd docker'));\n          console.log(chalk.bold('$ sudo usermod -aG docker $USER'));\n          console.log(chalk.bold('Then LOGOUT and LOGIN your Linux session'));\n          console.log('Read more: http://bit.ly/29JGdCE');\n        }\n        return reject(err);\n      }\n      return resolve();\n    });\n  });\n}\n\n/**\n * Switch Dockerfile mode\n * check test/programmatic/containerizer.mocha.js\n */\nfunction parseAndSwitch(file_content, main_file, mode) {\n  var lines = file_content.split('\\n');\n\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i];\n\n    if (['## DISTRIBUTION MODE', '## DEVELOPMENT MODE'].indexOf(line) > -1 ||\n        i == lines.length - 1) {\n      lines.splice(i, lines.length);\n      lines[i] = '## ' + mode.toUpperCase() + ' MODE';\n      lines[i + 1] = 'ENV NODE_ENV=' + (mode == 'distribution' ? 'production' : mode);\n\n      if (mode == 'distribution') {\n        lines[i + 2] = 'COPY . /var/app';\n        lines[i + 3] = 'CMD [\"pm2-docker\", \"start\", \"--auto-exit\", \"' + main_file + '\", \"--env\", \"production\"]';\n      }\n      if (mode == 'development') {\n        lines[i + 2] = 'CMD [\"rundev\", \"start\", \"--auto-exit\", \"' + main_file + '\", \"--env\", \"development\"]';\n      }\n      break;\n    }\n  };\n  lines = lines.join('\\n');\n  return lines;\n};\n\n/**\n * Replace ENV, COPY and CMD depending on the mode\n * @param {String} docker_filepath Dockerfile absolute path\n * @param {String} main_file       Main file to start in container\n * @param {String} mode            Mode to switch the Dockerfile\n */\nfunction switchDockerFile(docker_filepath, main_file, mode) {\n  return new Promise(function(resolve, reject) {\n    var data  = fs.readFileSync(docker_filepath, 'utf8').toString();\n\n    if (['distribution', 'development'].indexOf(mode) == -1)\n      return reject(new Error('Unknown mode'));\n\n    var lines = parseAndSwitch(data, main_file, mode)\n    fs.writeFile(docker_filepath, lines, function(err) {\n      if (err) return reject(err);\n      resolve({\n        Dockerfile_path : docker_filepath,\n        Dockerfile : lines,\n        CMD : ''\n      });\n    })\n  });\n}\n\n/**\n * Generate sample Dockerfile (lib/templates/Dockerfiles)\n * @param {String} docker_filepath Dockerfile absolute path\n * @param {String} main_file       Main file to start in container\n * @param {String} mode            Mode to switch the Dockerfile\n */\nfunction generateDockerfile(docker_filepath, main_file, mode) {\n  return new Promise(function(resolve, reject) {\n    var tpl_file = path.join(cst.TEMPLATE_FOLDER, cst.DOCKERFILE_NODEJS);\n    var template = fs.readFileSync(tpl_file, {encoding: 'utf8'});\n    var CMD;\n\n    template = parseAndSwitch(template, main_file, mode);\n\n    fs.writeFile(docker_filepath, template, function(err) {\n      if (err) return reject(err);\n      resolve({\n        Dockerfile_path : docker_filepath,\n        Dockerfile : template,\n        CMD : CMD\n      });\n    });\n  });\n}\n\nfunction handleExit(CLI, opts, mode) {\n  process.on('SIGINT', function() {\n    CLI.disconnect();\n\n    if (mode != 'distribution')\n      return false;\n\n    exec('docker ps -lq', function(err, stdout, stderr) {\n      if (err) {\n        console.error(err);\n      }\n      vizion.analyze({folder : process.cwd()}, function recur_path(err, meta){\n        if (!err && meta.revision) {\n          var commit_id = util.format('#%s(%s) %s',\n                                      meta.branch,\n                                      meta.revision.slice(0, 5),\n                                      meta.comment);\n          console.log(chalk.bold.cyan('$ docker commit -m \"%s\" %s %s'),\n                      commit_id,\n                      stdout.replace('\\n', ''),\n                      opts.imageName);\n        }\n        else\n          console.log(chalk.bold.cyan('$ docker commit %s %s'), stdout.replace('\\n', ''), opts.imageName);\n\n        console.log(chalk.bold.cyan('$ docker push %s'), opts.imageName);\n      });\n    });\n  });\n}\n\nmodule.exports = function(CLI) {\n  CLI.prototype.generateDockerfile = function(script, opts) {\n    var docker_filepath = path.join(process.cwd(), 'Dockerfile');\n    var that = this;\n\n    fs.stat(docker_filepath, function(err, stat) {\n      if (err || opts.force == true) {\n        generateDockerfile(docker_filepath, script, 'development')\n          .then(function() {\n            console.log(chalk.bold('New Dockerfile generated in current folder'));\n            console.log(chalk.bold('You can now run\\n$ pm2 docker:dev <file|config>'));\n            return that.exitCli(cst.SUCCESS_EXIT);\n          });\n        return false;\n      }\n      console.log(chalk.red.bold('Dockerfile already exists in this folder, use --force if you want to replace it'));\n      that.exitCli(cst.ERROR_EXIT);\n    });\n  };\n\n  CLI.prototype.dockerMode = function(script, opts, mode) {\n    var self = this;\n    handleExit(self, opts, mode);\n\n    if (mode == 'distribution' && !opts.imageName) {\n      return console.error(chalk.bold.red('--image-name [name] option is missing'));\n    }\n\n    var template;\n    var app_path, main_script;\n    var image_name;\n\n    image_name   = opts.imageName || crypto.randomBytes(6).toString('hex');\n\n    if (script.indexOf('/') > -1) {\n      app_path  = path.join(process.cwd(), path.dirname(script));\n      main_script = path.basename(script);\n    }\n    else {\n      app_path  = process.cwd();\n      main_script = script;\n    }\n\n    checkDockerSetup()\n      .then(function() {\n        /////////////////////////\n        // Generate Dockerfile //\n        /////////////////////////\n        return new Promise(function(resolve, reject) {\n          var docker_filepath = path.join(process.cwd(), 'Dockerfile');\n\n          fs.stat(docker_filepath, function(err, stat) {\n            if (err) {\n              // Dockerfile does not exists, generate one\n              console.log(chalk.blue.bold('Generating new Dockerfile'));\n              return resolve(generateDockerfile(docker_filepath, main_script, mode));\n            }\n            return resolve(switchDockerFile(docker_filepath, main_script, mode));\n          });\n        });\n      })\n      .then(function(_template) {\n        template = _template;\n        return Promise.resolve();\n      })\n      .then(function() {\n        //////////////////\n        // Docker build //\n        //////////////////\n\n        var docker_build = util.format('docker build -t %s -f %s',\n                                       image_name,\n                                       template.Dockerfile_path);\n\n        if (opts.fresh == true)\n          docker_build += ' --no-cache';\n        docker_build += ' .';\n\n        console.log();\n        fmt.sep();\n        fmt.title('Building Boot System');\n        fmt.field('Type', chalk.cyan.bold('Docker'));\n        fmt.field('Mode', mode);\n        fmt.field('Image name', image_name);\n        fmt.field('Docker build command', docker_build);\n        fmt.field('Dockerfile path', template.Dockerfile_path);\n        fmt.sep();\n\n        return pspawn(docker_build);\n      })\n      .then(function() {\n        ////////////////\n        // Docker run //\n        ////////////////\n\n        var docker_run = 'docker run --net host';\n\n        if (opts.daemon == true)\n          docker_run += ' -d';\n        if (mode != 'distribution')\n          docker_run += util.format(' -v %s:/var/app -v /var/app/node_modules', app_path);\n        docker_run += ' ' + image_name;\n\n        console.log();\n        fmt.sep();\n        fmt.title('Booting');\n        fmt.field('Type', chalk.cyan.bold('Docker'));\n        fmt.field('Mode', mode);\n        fmt.field('Image name', image_name);\n        fmt.field('Docker run command', docker_run);\n        fmt.field('Docker main CMD', template.CMD);\n        fmt.field('CWD', app_path);\n        fmt.sep();\n        return pspawn(docker_run);\n      })\n      .then(function() {\n        console.log(chalk.blue.bold('>>> Leaving Docker instance uuid=%s'), image_name);\n        self.disconnect();\n        return Promise.resolve();\n      })\n      .catch(function(err) {\n        console.log();\n        console.log(chalk.grey('Raw error=', err.message));\n        self.disconnect();\n      });\n\n  };\n\n};\n\nmodule.exports.generateDockerfile = generateDockerfile;\nmodule.exports.parseAndSwitch     = parseAndSwitch;\nmodule.exports.switchDockerFile   = switchDockerFile;\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/tools/fmt.js":"// --------------------------------------------------------------------------------------------------------------------\n//\n// fmt.js - Command line output formatting.\n//\n// Copyright (c) 2012 Andrew Chilton - http://chilts.org/\n// Written by Andrew Chilton <andychilton@gmail.com>\n//\n// License: http://opensource.org/licenses/MIT\n//\n// --------------------------------------------------------------------------------------------------------------------\n\nvar util = require('util');\n\n// --------------------------------------------------------------------------------------------------------------------\n\nvar sep  = '===============================================================================';\nvar line = '-------------------------------------------------------------------------------';\nvar field = '                    ';\n\n// --------------------------------------------------------------------------------------------------------------------\n\n// separator\nmodule.exports.separator = function() {\n    console.log(sep);\n};\n\n// alias the above\nmodule.exports.sep = module.exports.separator;\n\n// line\nmodule.exports.line = function() {\n    console.log(line);\n};\n\n// title\nmodule.exports.title = function(title) {\n    var out = '--- ' + title + ' ';\n    out += line.substr(out.length);\n    console.log(out);\n};\n\n// field\nmodule.exports.field = function(key, value) {\n    console.log('' + key + field.substr(key.length) + ' : ' + value);\n};\n\n// subfield\nmodule.exports.subfield = function(key, value) {\n    console.log('- ' + key + field.substr(key.length + 2) + ' : ' + value);\n};\n\n// list item\nmodule.exports.li = function(msg) {\n    console.log('* ' + msg);\n};\n\n// dump\nmodule.exports.dump = function(data, name) {\n    if ( name ) {\n        console.log(name + ' :', util.inspect(data, false, null, true));\n    }\n    else {\n        console.log(util.inspect(data, false, null, true));\n    }\n};\n\n// msg\nmodule.exports.msg = function(msg) {\n    console.log(msg);\n};\n\n// --------------------------------------------------------------------------------------------------------------------\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/tools/promise.min.js":"!function(e){function n(){}function t(e,n){return function(){e.apply(n,arguments)}}function o(e){if(\"object\"!=typeof this)throw new TypeError(\"Promises must be constructed via new\");if(\"function\"!=typeof e)throw new TypeError(\"not a function\");this._state=0,this._handled=!1,this._value=void 0,this._deferreds=[],s(e,this)}function i(e,n){for(;3===e._state;)e=e._value;return 0===e._state?void e._deferreds.push(n):(e._handled=!0,void o._immediateFn(function(){var t=1===e._state?n.onFulfilled:n.onRejected;if(null===t)return void(1===e._state?r:u)(n.promise,e._value);var o;try{o=t(e._value)}catch(e){return void u(n.promise,e)}r(n.promise,o)}))}function r(e,n){try{if(n===e)throw new TypeError(\"A promise cannot be resolved with itself.\");if(n&&(\"object\"==typeof n||\"function\"==typeof n)){var i=n.then;if(n instanceof o)return e._state=3,e._value=n,void f(e);if(\"function\"==typeof i)return void s(t(i,n),e)}e._state=1,e._value=n,f(e)}catch(n){u(e,n)}}function u(e,n){e._state=2,e._value=n,f(e)}function f(e){2===e._state&&0===e._deferreds.length&&o._immediateFn(function(){e._handled||o._unhandledRejectionFn(e._value)});for(var n=0,t=e._deferreds.length;n<t;n++)i(e,e._deferreds[n]);e._deferreds=null}function c(e,n,t){this.onFulfilled=\"function\"==typeof e?e:null,this.onRejected=\"function\"==typeof n?n:null,this.promise=t}function s(e,n){var t=!1;try{e(function(e){t||(t=!0,r(n,e))},function(e){t||(t=!0,u(n,e))})}catch(e){if(t)return;t=!0,u(n,e)}}var a=setTimeout;o.prototype.catch=function(e){return this.then(null,e)},o.prototype.then=function(e,t){var o=new this.constructor(n);return i(this,new c(e,t,o)),o},o.all=function(e){var n=Array.prototype.slice.call(e);return new o(function(e,t){function o(r,u){try{if(u&&(\"object\"==typeof u||\"function\"==typeof u)){var f=u.then;if(\"function\"==typeof f)return void f.call(u,function(e){o(r,e)},t)}n[r]=u,0===--i&&e(n)}catch(e){t(e)}}if(0===n.length)return e([]);for(var i=n.length,r=0;r<n.length;r++)o(r,n[r])})},o.resolve=function(e){return e&&\"object\"==typeof e&&e.constructor===o?e:new o(function(n){n(e)})},o.reject=function(e){return new o(function(n,t){t(e)})},o.race=function(e){return new o(function(n,t){for(var o=0,i=e.length;o<i;o++)e[o].then(n,t)})},o._immediateFn=\"function\"==typeof setImmediate&&function(e){setImmediate(e)}||function(e){a(e,0)},o._unhandledRejectionFn=function(e){\"undefined\"!=typeof console&&console&&console.warn(\"Possible Unhandled Promise Rejection:\",e)},o._setImmediateFn=function(e){o._immediateFn=e},o._setUnhandledRejectionFn=function(e){o._unhandledRejectionFn=e},\"undefined\"!=typeof module&&module.exports?module.exports=o:e.Promise||(e.Promise=o)}(this);","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/Daemon.js":"/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\n\nvar debug        = require('debug')('pm2:daemon');\nvar pkg          = require('../package.json');\nvar cst          = require('../constants.js');\nvar rpc          = require('pm2-axon-rpc');\nvar axon         = require('pm2-axon');\nvar domain       = require('domain');\nvar Utility      = require('./Utility.js');\nvar util         = require('util');\nvar fs           = require('fs');\nvar God          = require('./God');\nvar async        = require('async');\nvar fmt          = require('./tools/fmt.js');\n\nvar Daemon = module.exports = function(opts) {\n  if (!opts) opts = {};\n\n  this.rpc_socket_ready = false;\n  this.pub_socket_ready = false;\n\n  this.pub_socket_file = opts.pub_socket_file || cst.DAEMON_PUB_PORT;\n  this.rpc_socket_file = opts.rpc_socket_file || cst.DAEMON_RPC_PORT;\n\n  this.pid_path        = opts.pid_file || cst.PM2_PID_FILE_PATH;\n};\n\nDaemon.prototype.start = function() {\n  var that = this;\n  var d = domain.create();\n\n  d.once('error', function(err) {\n    fmt.sep();\n    fmt.title('PM2 global error caught');\n    fmt.field('Time', new Date());\n    console.error(err.message);\n    console.error(err.stack);\n    fmt.sep();\n\n    console.error('[PM2] Resurrecting PM2');\n\n\t\tvar path = cst.IS_WINDOWS ? process.cwd() + '/bin/pm2' : process.env['_'];\n    var fork_new_pm2 = require('child_process').spawn('node', [path, 'update'], {\n      detached: true,\n      stdio: 'inherit'\n    });\n\n    fork_new_pm2.on('close', function() {\n      console.log('PM2 successfully forked');\n      process.exit(0);\n    })\n\n  });\n\n  d.run(function() {\n    that.innerStart();\n  });\n}\n\nDaemon.prototype.innerStart = function(cb) {\n  var that = this;\n\n  if (!cb) cb = function() {\n    fmt.sep();\n    fmt.title('New PM2 Daemon started');\n    fmt.field('Time', new Date());\n    fmt.field('PM2 version', pkg.version);\n    fmt.field('Node.js version', process.versions.node);\n    fmt.field('Current arch', process.arch);\n    fmt.field('PM2 home', cst.PM2_HOME);\n    fmt.field('PM2 PID file', that.pid_path);\n    fmt.field('RPC socket file', that.rpc_socket_file);\n    fmt.field('BUS socket file', that.pub_socket_file);\n    fmt.field('Application log path', cst.DEFAULT_LOG_PATH);\n    fmt.field('Process dump file', cst.DUMP_FILE_PATH);\n    fmt.field('Concurrent actions', cst.CONCURRENT_ACTIONS);\n    fmt.field('SIGTERM timeout', cst.KILL_TIMEOUT);\n    fmt.sep();\n  };\n\n  // Write Daemon PID into file\n  try {\n    fs.writeFileSync(that.pid_path, process.pid);\n  } catch (e) {\n    console.error(e.stack || e);\n  }\n\n  this.handleSignals();\n\n  /**\n   * Pub system for real time notifications\n   */\n  this.pub    = axon.socket('pub-emitter');\n\n  this.pub_socket = this.pub.bind(this.pub_socket_file);\n\n  this.pub_socket.once('bind', function() {\n    that.pub_socket_ready = true;\n    that.sendReady(cb);\n  });\n\n  /**\n   * Rep/Req - RPC system to interact with God\n   */\n  this.rep    = axon.socket('rep');\n\n  var server = new rpc.Server(this.rep);\n\n  this.rpc_socket = this.rep.bind(this.rpc_socket_file);\n\n  this.rpc_socket.once('bind', function() {\n    that.rpc_socket_ready = true;\n    that.sendReady(cb);\n  });\n\n  var profiler;\n\n  try {\n    profiler = require('v8-profiler');\n  } catch(e) {\n    profiler = null;\n  }\n\n  /**\n   * Memory Snapshot\n   */\n  function snapshotPM2(msg, cb) {\n    if (profiler == null) {\n      console.log('v8-profiler is not available');\n      return cb(new Error('v8-profiler is not available'));\n    }\n\n    var snapshot1 = profiler.takeSnapshot();\n    var path = require('path');\n    snapshot1.export(function(error, result) {\n      fs.writeFile(msg.pwd, result, function() {\n        snapshot1.delete();\n        return cb(null, {file : msg.pwd});\n      });\n    });\n  }\n\n  function startProfilingPM2(msg, cb) {\n    if (profiler == null) {\n      console.log('v8-profiler is not available');\n      return cb(new Error('v8-profiler is not available'));\n    }\n\n    profiler.startProfiling('cpu');\n\n    process.nextTick(function() {\n      return cb(null, {msg : 'profiling started'});\n    });\n  }\n\n  function stopProfilingPM2(msg, cb) {\n    if (profiler == null) {\n      console.log('v8-profiler is not available');\n      return cb(new Error('v8-profiler is not available'));\n    }\n\n    var profile1 = profiler.stopProfiling('cpu');\n\n    profile1.export()\n      .pipe(fs.createWriteStream(msg.pwd))\n      .on('finish', function() {\n        profile1.delete();\n        return cb(null, {file : msg.pwd});\n      });\n  }\n\n  server.expose({\n    killMe                  : that.close.bind(this),\n    snapshotPM2             : snapshotPM2,\n    profileStart            : startProfilingPM2,\n    profileStop             : stopProfilingPM2,\n    prepare                 : God.prepare,\n    getMonitorData          : God.getMonitorData,\n    getSystemData           : God.getSystemData,\n\n    startProcessId          : God.startProcessId,\n    stopProcessId           : God.stopProcessId,\n    restartProcessId        : God.restartProcessId,\n    deleteProcessId         : God.deleteProcessId,\n\n    softReloadProcessId     : God.softReloadProcessId,\n    reloadProcessId         : God.reloadProcessId,\n    duplicateProcessId      : God.duplicateProcessId,\n    resetMetaProcessId      : God.resetMetaProcessId,\n    stopWatch               : God.stopWatch,\n    startWatch              : God.startWatch,\n    toggleWatch             : God.toggleWatch,\n    notifyByProcessId       : God.notifyByProcessId,\n\n    notifyKillPM2           : God.notifyKillPM2,\n    forceGc                 : God.forceGc,\n\n    msgProcess              : God.msgProcess,\n    sendDataToProcessId     : God.sendDataToProcessId,\n    sendSignalToProcessId   : God.sendSignalToProcessId,\n    sendSignalToProcessName : God.sendSignalToProcessName,\n\n    ping                    : God.ping,\n    getVersion              : God.getVersion,\n    reloadLogs              : God.reloadLogs\n  });\n\n  this.startLogic();\n}\n\nDaemon.prototype.close = function(opts, cb) {\n  var that = this;\n\n  God.bus.emit('pm2:kill', {\n    status : 'killed',\n    msg    : 'pm2 has been killed via CLI'\n  });\n\n  fmt.sep();\n  fmt.title('Stopping PM2');\n  fmt.field('Time', new Date());\n  fmt.sep();\n\n  /**\n   * Cleanly kill pm2\n   */\n  that.rpc_socket.close(function() {\n    console.log('RPC closed');\n    that.pub_socket.close(function() {\n      console.log('PUB closed');\n\n      // notify cli that the daemon is shuting down (only under unix since windows doesnt handle signals)\n      if (cst.IS_WINDOWS === false) {\n        try {\n          process.kill(parseInt(opts.pid), 'SIGQUIT');\n        } catch(e) {\n          console.error('Could not send SIGQUIT to CLI');\n        }\n      }\n\n      console.log('PM2 successfully stopped');\n      setTimeout(function() {\n        process.exit(cst.SUCCESS_EXIT);\n      }, 2);\n    });\n  });\n}\n\nDaemon.prototype.handleSignals = function() {\n  var that = this;\n\n  process.on('SIGTERM', that.gracefullExit);\n  process.on('SIGINT', that.gracefullExit);\n  process.on('SIGHUP', function() {});\n  process.on('SIGQUIT', that.gracefullExit);\n  process.on('SIGUSR2', function() {\n    God.reloadLogs({}, function() {});\n  });\n}\n\nDaemon.prototype.sendReady = function(cb) {\n  // Send ready message to Client\n  if (this.rpc_socket_ready == true && this.pub_socket_ready == true) {\n    cb(null, {\n      pid         : process.pid,\n      pm2_version : pkg.version\n    });\n    if (typeof(process.send) != 'function')\n      return false;\n\n    process.send({\n      online      : true,\n      success     : true,\n      pid         : process.pid,\n      pm2_version : pkg.version\n    });\n  };\n}\n\nDaemon.prototype.gracefullExit = function() {\n  var that = this;\n\n  console.log('pm2 has been killed by signal, dumping process list before exit...');\n\n  God.dumpProcessList(function() {\n\n    var processes = God.getFormatedProcesses();\n\n    async.eachLimit(processes, 1, function(proc, next) {\n      console.log('Deleting process %s', proc.pm2_env.pm_id);\n      God.deleteProcessId(proc.pm2_env.pm_id, function() {\n        return next();\n      });\n      return false;\n    }, function(err) {\n      try {\n        fs.unlinkSync(that.pid_path);\n      } catch(e) {}\n      console.log('[PM2] Exited peacefully');\n      process.exit(0);\n    });\n  });\n}\n\nDaemon.prototype.startLogic = function() {\n  var that = this;\n\n  /**\n   * Action treatment specifics\n   * Attach actions to pm2_env.axm_actions variables (name + options)\n   */\n  God.bus.on('axm:action', function axmActions(msg) {\n    var pm2_env = msg.process;\n    var exists  = false;\n    var axm_action = msg.data;\n\n    if (!pm2_env || !God.clusters_db[pm2_env.pm_id])\n      return console.error('Unknown id %s', pm2_env.pm_id);\n\n    if (!God.clusters_db[pm2_env.pm_id].pm2_env.axm_actions)\n      God.clusters_db[pm2_env.pm_id].pm2_env.axm_actions = [];\n\n    God.clusters_db[pm2_env.pm_id].pm2_env.axm_actions.forEach(function(actions) {\n      if (actions.action_name == axm_action.action_name)\n        exists = true;\n    });\n\n    if (exists === false) {\n      debug('Adding action', axm_action);\n      God.clusters_db[pm2_env.pm_id].pm2_env.axm_actions.push(axm_action);\n    }\n    msg = null;\n  });\n\n  /**\n   * Configure module\n   */\n  God.bus.on('axm:option:configuration', function axmMonitor(msg) {\n    if (!msg.process)\n      return console.error('[axm:option:configuration] no process defined');\n\n    if (!God.clusters_db[msg.process.pm_id])\n      return console.error('[axm:option:configuration] Unknown id %s', msg.process.pm_id);\n\n    try {\n      // Application Name nverride\n      if (msg.data.name)\n        God.clusters_db[msg.process.pm_id].pm2_env.name = msg.data.name;\n\n      Object.keys(msg.data).forEach(function(conf_key) {\n        God.clusters_db[msg.process.pm_id].pm2_env.axm_options[conf_key] = Utility.clone(msg.data[conf_key]);\n      });\n    } catch(e) {\n      console.error(e.stack || e);\n    }\n    msg = null;\n  });\n\n  /**\n   * Process monitoring data (probes)\n   */\n  God.bus.on('axm:monitor', function axmMonitor(msg) {\n    if (!msg.process)\n      return console.error('[axm:monitor] no process defined');\n\n    if (!msg.process || !God.clusters_db[msg.process.pm_id])\n      return console.error('Unknown id %s', msg.process.pm_id);\n\n    util._extend(God.clusters_db[msg.process.pm_id].pm2_env.axm_monitor, Utility.clone(msg.data));\n    msg = null;\n  });\n\n  /**\n   * Broadcast messages\n   */\n  God.bus.onAny(function(event, data_v) {\n    if (['axm:action',\n         'axm:monitor',\n         'axm:option:setPID',\n         'axm:option:configuration'].indexOf(event) > -1) {\n      data_v = null;\n      return false;\n    }\n    that.pub.emit(event, Utility.clone(data_v));\n    data_v = null;\n  });\n};\n\nif (require.main === module) {\n  process.title = 'PM2 v' + pkg.version + ': God Daemon (' + process.env.PM2_HOME + ')';\n\n  var daemon = new Daemon();\n\n  daemon.start();\n}\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/God.js":"/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\n\n/******************************\n *    ______ _______ ______\n *   |   __ \\   |   |__    |\n *   |    __/       |    __|\n *   |___|  |__|_|__|______|\n *\n *    Main Daemon side file\n *\n ******************************/\n\nvar semver        = require('semver');\nvar cluster       = require('cluster');\nvar numCPUs       = require('os').cpus() ? require('os').cpus().length : 1;\nvar path          = require('path');\nvar EventEmitter2 = require('eventemitter2').EventEmitter2;\nvar fs            = require('fs');\nvar pidusage      = require('pidusage');\nvar vizion        = require('vizion');\nvar debug         = require('debug')('pm2:god');\nvar Utility       = require('./Utility');\nvar cst           = require('../constants.js');\n\n/**\n * Override cluster module configuration\n */\ncluster.setupMaster({\n  exec : path.resolve(path.dirname(module.filename), 'ProcessContainer.js')\n});\n\n/**\n * Expose God\n */\nvar God = module.exports = {\n  next_id : 0,\n  clusters_db : {},\n  bus : new EventEmitter2({\n    wildcard: true,\n    delimiter: ':',\n    maxListeners: 1000\n  })\n};\n\nUtility.overrideConsole(God.bus);\n\n/**\n * Populate God namespace\n */\nrequire('./Event.js')(God);\nrequire('./God/Methods.js')(God);\nrequire('./God/ForkMode.js')(God);\nrequire('./God/ClusterMode.js')(God);\nrequire('./God/Reload')(God);\nrequire('./God/ActionMethods')(God);\nrequire('./Watcher')(God);\n\n/**\n * Launch the specified script (present in env)\n * @api private\n * @method executeApp\n * @param {Mixed} env\n * @param {Function} cb\n * @return Literal\n */\nGod.executeApp = function executeApp(env, cb) {\n  var env_copy = Utility.clone(env);\n\n  Utility.extend(env_copy, env_copy.env);\n\n  env_copy['status']         = cst.LAUNCHING_STATUS;\n  env_copy['pm_uptime']      = Date.now();\n  env_copy['axm_actions']    = [];\n  env_copy['axm_monitor']    = {};\n  env_copy['axm_options']    = {};\n  env_copy['axm_dynamic']    = {};\n  env_copy['vizion_running'] =\n    env_copy['vizion_running'] !== undefined ? env_copy['vizion_running'] : false;\n\n  if (!env_copy.created_at)\n    env_copy['created_at'] = Date.now();\n\n  /**\n   * Enter here when it's the first time that the process is created\n   * 1 - Assign a new id\n   * 2 - Reset restart time and unstable_restarts\n   * 3 - Assign a log file name depending on the id\n   * 4 - If watch option is set, look for changes\n   */\n  if (env_copy['pm_id'] === undefined) {\n    env_copy['pm_id']             = God.getNewId();\n    env_copy['restart_time']      = 0;\n    env_copy['unstable_restarts'] = 0;\n\n    // add -pm_id to pid file\n    env_copy.pm_pid_path = env_copy.pm_pid_path.replace(/-[0-9]+\\.pid$|\\.pid$/g, '-' + env_copy['pm_id'] + '.pid');\n\n    // If merge option, dont separate the logs\n    if (!env_copy['merge_logs']) {\n      ['', '_out', '_err'].forEach(function(k){\n        var key = 'pm' + k + '_log_path';\n        env_copy[key] && (env_copy[key] = env_copy[key].replace(/-[0-9]+\\.log$|\\.log$/g, '-' + env_copy['pm_id'] + '.log'));\n      });\n    }\n\n    // Initiate watch file\n    if (env_copy['watch']) {\n      God.watch.enable(env_copy);\n    }\n  }\n\n  /**\n   * Avoid `Resource leak error` due to 'disconnect' event\n   * not being fired sometimes\n   */\n  var workAround = function(worker) {\n    var listeners = null;\n\n    listeners = worker.process.listeners('exit')[0];\n    var exit = listeners[Object.keys(listeners)[0]];\n\n    listeners = worker.process.listeners('disconnect')[0];\n    var disconnect = listeners[Object.keys(listeners)[0]];\n\n    worker.process.removeListener('exit', exit);\n    worker.process.once('exit', function(exitCode, signalCode) {\n      // If disconnect() has not been called\n      // earlier, we call it here.\n      if (worker.state != 'disconnected')\n        disconnect();\n      // Call the original 'exit' callback\n      exit(exitCode, signalCode);\n    });\n  };\n\n  /** Callback when application is launched */\n  var readyCb = function ready(proc) {\n      if (proc.pm2_env.vizion !== false && proc.pm2_env.vizion !== \"false\")\n        God.finalizeProcedure(proc);\n      else\n        God.notify('online', proc);\n\n      proc.pm2_env.status = cst.ONLINE_STATUS;\n      console.log('App name:%s id:%s online', proc.pm2_env.name, proc.pm2_env.pm_id);\n      if (cb) cb(null, proc);\n  }\n\n  if (env_copy.exec_mode === 'cluster_mode') {\n    /**\n     * Cluster mode logic (for NodeJS apps)\n     */\n    God.nodeApp(env_copy, function nodeApp(err, clu) {\n      if (cb && err) return cb(err);\n      if (err) return false;\n\n      var old_env = God.clusters_db[clu.pm2_env.pm_id];\n\n      if (old_env) {\n        old_env = null;\n        God.clusters_db[clu.pm2_env.pm_id] = null;\n      }\n\n      God.clusters_db[clu.pm2_env.pm_id] = clu;\n\n      if (semver.lt(process.version, '7.0.0') === true) {\n        // Temporary\n        workAround(clu);\n      }\n\n      clu.once('error', function(err) {\n        console.error(err.stack || err);\n        clu.pm2_env.status = cst.ERRORED_STATUS;\n        try {\n          clu.destroy && clu.destroy();\n        }\n        catch (e) {\n          console.error(e.stack || e);\n          God.handleExit(clu, cst.ERROR_EXIT);\n        }\n      });\n\n      clu.once('disconnect', function() {\n        console.log('App name:%s id:%s disconnected', clu.pm2_env.name, clu.pm2_env.pm_id);\n      });\n\n      clu.once('exit', function cluExit(code, signal) {\n        God.handleExit(clu, code || 0, signal || 'SIGINT');\n      });\n\n      return clu.once('online', function () {\n        return readyCb(clu);\n      });\n    });\n  }\n  else {\n    /**\n     * Fork mode logic\n     */\n    God.forkMode(env_copy, function forkMode(err, clu) {\n      if (cb && err) return cb(err);\n      if (err) return false;\n\n      var old_env = God.clusters_db[clu.pm2_env.pm_id];\n      if (old_env) old_env = null;\n\n      var proc = God.clusters_db[env_copy.pm_id] = clu;\n\n      clu.once('error', function cluError(err) {\n        console.error(err.stack || err);\n        proc.pm2_env.status = cst.ERRORED_STATUS;\n        try {\n          clu.kill && clu.kill();\n        }\n        catch (e) {\n          console.error(e.stack || e);\n          God.handleExit(clu, cst.ERROR_EXIT);\n        }\n      });\n\n      clu.once('exit', function cluClose(code, signal) {\n        if (clu.connected === true)\n          clu.disconnect && clu.disconnect();\n        clu._reloadLogs = null;\n        return God.handleExit(proc, code || 0, signal);\n      });\n\n      if (!clu.pm2_env.wait_ready)\n        return readyCb(clu);\n\n      var listener = function (packet) {\n        if (packet.raw === 'ready' && packet.process.name === proc.pm2_env.name && packet.process.pm_id === proc.pm2_env.pm_id) {\n          God.bus.removeListener('process:msg', listener)\n          return readyCb(clu)\n        }\n      }\n      God.bus.on('process:msg', listener);\n    });\n  }\n  return false;\n};\n\n/**\n * Handle logic when a process exit (Node or Fork)\n * @method handleExit\n * @param {} clu\n * @param {} exit_code\n * @return\n */\nGod.handleExit = function handleExit(clu, exit_code, kill_signal) {\n  console.log('App [%s] with id [%s] and pid [%s], exited with code [%s] via signal [%s]', clu.pm2_env.name, clu.pm2_env.pm_id, clu.process.pid, exit_code, kill_signal || 'SIGINT');\n\n  var proc = this.clusters_db[clu.pm2_env.pm_id];\n\n  if (!proc) {\n    console.error('Process undefined ? with process id ', clu.pm2_env.pm_id);\n    return false;\n  }\n\n  if (proc.process.pid)\n    pidusage.unmonitor(proc.process.pid);\n\n  var stopping    = (proc.pm2_env.status == cst.STOPPING_STATUS\n                     || proc.pm2_env.status == cst.STOPPED_STATUS\n                     || proc.pm2_env.status == cst.ERRORED_STATUS) || (proc.pm2_env.autorestart === false ||\n                                                                       proc.pm2_env.autorestart === \"false\");\n\n  var overlimit   = false;\n\n  if (stopping) proc.process.pid = 0;\n\n  // Reset probes and actions\n  if (proc.pm2_env.axm_actions) proc.pm2_env.axm_actions = [];\n  if (proc.pm2_env.axm_monitor) proc.pm2_env.axm_monitor = {};\n\n  if (proc.pm2_env.status != cst.ERRORED_STATUS &&\n      proc.pm2_env.status != cst.STOPPING_STATUS)\n    proc.pm2_env.status = cst.STOPPED_STATUS;\n\n  if (proc.pm2_env.pm_id.toString().indexOf('_old_') !== 0) {\n    try {\n      fs.unlinkSync(proc.pm2_env.pm_pid_path);\n    } catch (e) {\n      debug('Error when unlinking pid file', e);\n    }\n  }\n\n  /**\n   * Avoid infinite reloop if an error is present\n   */\n  // If the process has been created less than 15seconds ago\n\n  // And if the process has an uptime less than a second\n  var min_uptime = typeof(proc.pm2_env.min_uptime) !== 'undefined' ? proc.pm2_env.min_uptime : 1000;\n  var max_restarts = typeof(proc.pm2_env.max_restarts) !== 'undefined' ? proc.pm2_env.max_restarts : 16;\n\n  if ((Date.now() - proc.pm2_env.created_at) < (min_uptime * max_restarts)) {\n    if ((Date.now() - proc.pm2_env.pm_uptime) < min_uptime) {\n      // Increment unstable restart\n      proc.pm2_env.unstable_restarts += 1;\n    }\n\n    if (proc.pm2_env.unstable_restarts >= max_restarts) {\n      // Too many unstable restart in less than 15 seconds\n      // Set the process as 'ERRORED'\n      // And stop restarting it\n      proc.pm2_env.status = cst.ERRORED_STATUS;\n      proc.process.pid = 0;\n\n      console.log('Script %s had too many unstable restarts (%d). Stopped. %j',\n                  proc.pm2_env.pm_exec_path,\n                  proc.pm2_env.unstable_restarts,\n                  proc.pm2_env.status);\n\n      God.notify('restart overlimit', proc);\n\n      proc.pm2_env.unstable_restarts = 0;\n      proc.pm2_env.created_at = null;\n      overlimit = true;\n    }\n  }\n\n  if (typeof(exit_code) !== 'undefined') proc.pm2_env.exit_code = exit_code;\n\n  God.notify('exit', proc);\n\n  if (God.pm2_being_killed) {\n    console.log('[HandleExit] PM2 is being killed, stopping restart procedure...');\n    return false;\n  }\n\n  var restart_delay = 0;\n  if (proc.pm2_env.restart_delay !== undefined && !isNaN(parseInt(proc.pm2_env.restart_delay))) {\n    restart_delay = parseInt(proc.pm2_env.restart_delay);\n  }\n\n  if (!stopping && !overlimit) {\n    //make this property unenumerable\n    Object.defineProperty(proc.pm2_env, 'restart_task', {configurable: true, writable: true});\n    proc.pm2_env.restart_task = setTimeout(function() {\n      proc.pm2_env.restart_time += 1;\n      God.executeApp(proc.pm2_env);\n    }, restart_delay);\n  }\n\n  return false;\n};\n\n/**\n * Init new process\n */\nGod.prepare = function prepare(env, cb) {\n  // If instances option is set (-i [arg])\n  if (typeof env.instances != 'undefined') {\n    if (env.instances == 0) env.instances = numCPUs;\n    env.instances = parseInt(env.instances);\n    if (env.instances < 0) env.instances += numCPUs;\n    if (env.instances <= 0) env.instances = 1;\n    // multi fork depending on number of cpus\n    var arr = [];\n    var instance_id = 0;\n\n    (function ex(i) {\n      if (i <= 0) {\n        if (cb) return cb(null, arr);\n        return false;\n      }\n\n      env.NODE_APP_INSTANCE = instance_id++;\n      env.vizion_running = false;\n\n      if (env.env && env.env.vizion_running)\n        env.env.vizion_running = false;\n\n      return God.executeApp(Utility.clone(env), function(err, clu) {\n        if (err) return ex(i - 1);\n        arr.push(Utility.clone(clu));\n        God.notify('start', clu, true);\n        return ex(i - 1);\n      });\n    })(env.instances);\n  }\n  else {\n    env.vizion_running = false;\n    if (env.env && env.env.vizion_running) env.env.vizion_running = false;\n\n    return God.executeApp(env, function(err, clu) {\n      God.notify('start', clu, true);\n      cb(err, [Utility.clone(clu)]);\n    });\n  }\n  return false;\n};\n\n/**\n * @method finalizeProcedure\n * @param proc {Object}\n * @return\n */\nGod.finalizeProcedure = function finalizeProcedure(proc) {\n  var last_path    = '';\n  var current_path = proc.pm2_env.cwd || path.dirname(proc.pm2_env.pm_exec_path);\n  var proc_id      = proc.pm2_env.pm_id;\n\n  if (proc.pm2_env.vizion_running === true) {\n    debug('Vizion is already running for proc id: %d, skipping this round', proc_id);\n    return God.notify('online', proc);\n  }\n\n  proc.pm2_env.vizion_running = true;\n  vizion.analyze({folder : current_path}, function recur_path(err, meta){\n    var proc = God.clusters_db[proc_id];\n\n    if (err)\n      debug(err.stack || err);\n\n    if (!proc ||\n        !proc.pm2_env ||\n        proc.pm2_env.status == cst.STOPPED_STATUS ||\n        proc.pm2_env.status == cst.STOPPING_STATUS) {\n      return console.error('Proc is not defined anymore or is being killed');\n    }\n\n    proc.pm2_env.vizion_running = false;\n\n    if (!err) {\n      proc.pm2_env.versioning = meta;\n      proc.pm2_env.versioning.repo_path = current_path;\n      God.notify('online', proc);\n    }\n    else if (err && current_path === last_path) {\n      proc.pm2_env.versioning = null;\n      God.notify('online', proc);\n    }\n    else {\n      last_path = current_path;\n      current_path = path.dirname(current_path);\n      proc.pm2_env.vizion_running = true;\n      vizion.analyze({folder : current_path}, recur_path);\n    }\n    return false;\n  });\n};\n\n/**\n * Worker\n */\nrequire('./Worker.js')(God);\nsetTimeout(function() {\n  God.Worker.start();\n}, 500);\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/Event.js":"/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\n\nvar Utility       = require('./Utility.js');\n\nmodule.exports = function(God) {\n\n  God.notify = function(action_name, data, manually) {\n    God.bus.emit('process:event', {\n      event      : action_name,\n      manually   : typeof(manually) == 'undefined' ? false : true,\n      process    : Utility.formatCLU(data),\n      at         : Utility.getDate()\n    });\n  };\n\n  God.notifyByProcessId = function(opts, cb) {\n    if (typeof(opts.id) === 'undefined') { return cb(new Error('process id missing')); }\n    var proc = God.clusters_db[opts.id];\n    if (!proc) { return cb(new Error('process id doesnt exists')); }\n\n    God.bus.emit('process:event', {\n      event      : opts.action_name,\n      manually   : typeof(opts.manually) == 'undefined' ? false : true,\n      process    : Utility.formatCLU(proc),\n      at         : Utility.getDate()\n    });\n\n    process.nextTick(function() {\n      return cb ? cb(null) : false;\n    });\n    return false;\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/God/Methods.js":"/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\n'use strict';\n\n/**\n * @file Utilities for PM2\n * @author Alexandre Strzelewicz <as@unitech.io>\n * @project PM2\n */\nvar p             = require('path');\nvar Utility       = require('../Utility');\nvar treekill      = require('../TreeKill');\nvar cst           = require('../../constants.js');\nvar debug         = require('debug')('pm2:methods');\n\n/**\n * Description\n * @method exports\n * @param {} God\n * @return\n */\nmodule.exports = function(God) {\n\n  /**\n   * Description\n   * @method logAndGenerateError\n   * @param {} err\n   * @return NewExpression\n   */\n  God.logAndGenerateError = function(err) {\n    // Is an Error object\n    if (err instanceof Error) {\n      console.trace(err);\n      return err;\n    }\n    // Is a JSON or simple string\n    console.error(err);\n    return new Error(err);\n  };\n\n  /**\n   * Utility functions\n   * @method getProcesses\n   * @return MemberExpression\n   */\n  God.getProcesses = function() {\n    return God.clusters_db;\n  };\n\n  God.getFormatedProcess = function getFormatedProcesses(id) {\n    if (God.clusters_db[id])\n      return {\n        pid     : God.clusters_db[id].process.pid,\n        name    : God.clusters_db[id].pm2_env.name,\n        pm2_env : God.clusters_db[id].pm2_env,\n        pm_id   : God.clusters_db[id].pm2_env.pm_id\n      };\n    return {};\n  };\n\n  /**\n   * Get formated processes\n   * @method getFormatedProcesses\n   * @return {Array} formated processes\n   */\n  God.getFormatedProcesses = function getFormatedProcesses() {\n    var keys = Object.keys(God.clusters_db);\n    var arr  = new Array();\n    var kl   = keys.length;\n\n    for (var i = 0; i < kl; i++) {\n      var key = keys[i];\n\n      if (!God.clusters_db[key]) continue;\n      // Avoid _old type pm_ids\n      if (isNaN(God.clusters_db[key].pm2_env.pm_id)) continue;\n\n      arr.push({\n        pid     : God.clusters_db[key].process.pid,\n        name    : God.clusters_db[key].pm2_env.name,\n        pm2_env : God.clusters_db[key].pm2_env,\n        pm_id   : God.clusters_db[key].pm2_env.pm_id\n      })\n    }\n    return arr;\n  };\n\n  /**\n   * Description\n   * @method findProcessById\n   * @param {} id\n   * @return ConditionalExpression\n   */\n  God.findProcessById = function findProcessById(id) {\n    return God.clusters_db[id] ? God.clusters_db[id] : null;\n  };\n\n  /**\n   * Description\n   * @method findByName\n   * @param {} name\n   * @return arr\n   */\n  God.findByName = function(name) {\n    var db = God.clusters_db;\n    var arr = [];\n\n    if (name == 'all') {\n      for (var key in db) {\n        // Avoid _old_proc process style\n        if (typeof(God.clusters_db[key].pm2_env.pm_id) === 'number')\n          arr.push(db[key]);\n      }\n      return arr;\n    }\n\n    for (var key in db) {\n      if (God.clusters_db[key].pm2_env.name == name ||\n          God.clusters_db[key].pm2_env.pm_exec_path == p.resolve(name)) {\n        arr.push(db[key]);\n      }\n    }\n    return arr;\n  };\n\n  /**\n   * Check if a process is alive in system processes\n   * Return TRUE if process online\n   * @method checkProcess\n   * @param {} pid\n   * @return\n   */\n  God.checkProcess = function(pid) {\n    if (!pid) return false;\n\n    try {\n      // Sending 0 signal do not kill the process\n      process.kill(pid, 0);\n      return true;\n    }\n    catch (err) {\n      return false;\n    }\n  };\n\n  /**\n   * Description\n   * @method processIsDead\n   * @param {} pid\n   * @param {} cb\n   * @return Literal\n   */\n  God.processIsDead = function(pid, pm2_env, cb, sigkill) {\n    if (!pid) return cb({type : 'param:missing', msg : 'no pid passed'});\n\n    var timeout      = null;\n    var kill_timeout = (pm2_env && pm2_env.kill_timeout) ? pm2_env.kill_timeout : cst.KILL_TIMEOUT;\n    var mode         = pm2_env.exec_mode;\n\n    var timer = setInterval(function() {\n      if (God.checkProcess(pid) === false) {\n        console.log('pid=%d msg=process killed', pid);\n        clearTimeout(timeout);\n        clearInterval(timer);\n        return cb(null, true);\n      }\n      console.log('pid=%d msg=failed to kill - retrying in 100ms', pid);\n      return false;\n    }, 100);\n\n    timeout = setTimeout(function() {\n      clearInterval(timer);\n      if (sigkill) {\n        console.log('Process with pid %d could not be killed', pid);\n        return cb({type : 'timeout', msg : 'timeout'});\n      }\n      else {\n        console.log('Process with pid %d still alive after %sms, sending it SIGKILL now...', pid, kill_timeout);\n\n        if (pm2_env.treekill !== true) {\n          try {\n            process.kill(parseInt(pid), 'SIGKILL');\n          } catch(e) {\n            console.error('[SimpleKill][SIGKILL] %s pid can not be killed', pid, e.stack, e.message);\n          }\n          return God.processIsDead(pid, pm2_env, cb, true);\n        }\n        else {\n          treekill(parseInt(pid), 'SIGKILL', function(err) {\n            return God.processIsDead(pid, pm2_env, cb, true);\n          });\n        }\n      }\n    }, kill_timeout);\n    return false;\n  };\n\n  /**\n   * Description\n   * @method killProcess\n   * @param int pid\n   * @param Object pm2_env\n   * @param function cb\n   * @return CallExpression\n   */\n  God.killProcess = function(pid, pm2_env, cb) {\n    if (!pid) return cb({msg : 'no pid passed or null'});\n\n    var mode = pm2_env.exec_mode;\n\n    if (pm2_env.treekill !== true) {\n      try {\n        process.kill(parseInt(pid), 'SIGINT');\n      } catch(e) {\n        console.error('[SimpleKill] %s pid can not be killed', pid, e.stack, e.message);\n      }\n      return God.processIsDead(pid, pm2_env, cb);\n    }\n    else {\n      treekill(parseInt(pid), 'SIGINT', function(err) {\n        return God.processIsDead(pid, pm2_env, cb);\n      });\n    }\n  };\n\n  /**\n   * Description\n   * @method getNewId\n   * @return UpdateExpression\n   */\n  God.getNewId = function() {\n    return God.next_id++;\n  };\n\n  /**\n   * When a process is restarted or reloaded reset fields\n   * to monitor unstable starts\n   * @method resetState\n   * @param {} pm2_env\n   * @return\n   */\n  God.resetState = function(pm2_env) {\n    pm2_env.created_at = Date.now();\n    pm2_env.unstable_restarts = 0;\n  };\n\n  /**\n   * Description\n   * @method forcegc\n   * @return\n   */\n  God.forceGc = function(opts, cb) {\n    if (global.gc) {\n      global.gc();\n      debug('Garbage collection triggered successfully');\n      if (cb) cb(null, {success: true});\n    }\n    else {\n      debug('Garbage collection failed');\n      if (cb) cb(null, {success: false});\n    }\n  };\n\n};\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/TreeKill.js":"'use strict';\n\n// From https://raw.githubusercontent.com/pkrumins/node-tree-kill/master/index.js\n\nvar childProcess = require('child_process');\nvar spawn = childProcess.spawn;\nvar exec = childProcess.exec;\n\nmodule.exports = function (pid, signal, callback) {\n  var tree = {};\n  var pidsToProcess = {};\n  tree[pid] = [];\n  pidsToProcess[pid] = 1;\n\n  switch (process.platform) {\n  case 'win32':\n    exec('taskkill /pid ' + pid + ' /T /F', callback);\n    break;\n  case 'darwin':\n    buildProcessTree(pid, tree, pidsToProcess, function (parentPid) {\n      return spawn('pgrep', ['-P', parentPid]);\n    }, function () {\n      killAll(tree, signal, callback);\n    });\n    break;\n    // case 'sunos':\n    //     buildProcessTreeSunOS(pid, tree, pidsToProcess, function () {\n    //         killAll(tree, signal, callback);\n    //     });\n    //     break;\n  default: // Linux\n    buildProcessTree(pid, tree, pidsToProcess, function (parentPid) {\n      return spawn('ps', ['-o', 'pid', '--no-headers', '--ppid', parentPid]);\n    }, function () {\n      killAll(tree, signal, callback);\n    });\n    break;\n  }\n};\n\nfunction killAll (tree, signal, callback) {\n  var killed = {};\n  try {\n    Object.keys(tree).forEach(function (pid) {\n      tree[pid].forEach(function (pidpid) {\n        if (!killed[pidpid]) {\n          killPid(pidpid, signal);\n          killed[pidpid] = 1;\n        }\n      });\n      if (!killed[pid]) {\n        killPid(pid, signal);\n        killed[pid] = 1;\n      }\n    });\n  } catch (err) {\n    if (callback) {\n      return callback(err);\n    } else {\n      console.error(err);\n    }\n  }\n  if (callback) {\n    return callback();\n  }\n}\n\nfunction killPid(pid, signal) {\n  try {\n    process.kill(parseInt(pid, 10), signal);\n  }\n  catch (err) {\n    if (err.code !== 'ESRCH')\n      console.error(err);\n  }\n}\n\nfunction buildProcessTree (parentPid, tree, pidsToProcess, spawnChildProcessesList, cb) {\n  var ps = spawnChildProcessesList(parentPid);\n  var allData = '';\n\n  ps.on('error', function(err) {\n    console.error(err);\n  });\n\n  if (ps.stdout) {\n    ps.stdout.on('data', function (data) {\n      data = data.toString('ascii');\n      allData += data;\n    });\n  }\n\n  var onClose = function (code) {\n    delete pidsToProcess[parentPid];\n\n    if (code !== 0) {\n      // no more parent processes\n      if (Object.keys(pidsToProcess).length == 0) {\n        cb();\n      }\n      return;\n    }\n    var pids = allData.match(/\\d+/g) || [];\n    if (pids.length === 0)\n      return cb();\n\n    pids.forEach(function (pid) {\n      pid = parseInt(pid, 10);\n      tree[parentPid].push(pid);\n      tree[pid] = [];\n      pidsToProcess[pid] = 1;\n      buildProcessTree(pid, tree, pidsToProcess, spawnChildProcessesList, cb);\n    });\n  };\n\n  ps.on('close', onClose);\n}\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/God/ForkMode.js":"/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\n'use strict';\n\n/**\n * @file Fork execution related functions\n * @author Alexandre Strzelewicz <as@unitech.io>\n * @project PM2\n */\nvar log           = require('debug')('pm2:fork_mode');\nvar fs            = require('fs');\nvar cst           = require('../../constants.js');\nvar moment        = require('moment');\nvar Utility       = require('../Utility.js');\nvar path          = require('path');\n\n/**\n * Description\n * @method exports\n * @param {} God\n * @return\n */\nmodule.exports = function ForkMode(God) {\n  /**\n   * For all apps - FORK MODE\n   * fork the app\n   * @method forkMode\n   * @param {} pm2_env\n   * @param {} cb\n   * @return\n   */\n  God.forkMode = function forkMode(pm2_env, cb) {\n    var command = '';\n    var args    = [];\n\n    console.log('Starting execution sequence in -fork mode- for app name:%s id:%s',\n                pm2_env.name,\n                pm2_env.pm_id);\n    var spawn = require('child_process').spawn;\n\n    var interpreter = pm2_env.exec_interpreter || 'node';\n    var pidFile     = pm2_env.pm_pid_path;\n\n    if (interpreter !== 'none') {\n      command = interpreter;\n\n      if (pm2_env.node_args && Array.isArray(pm2_env.node_args)) {\n        args = args.concat(pm2_env.node_args);\n      }\n\n      // Deprecated - to remove at some point\n      if (process.env.PM2_NODE_OPTIONS) {\n        args = args.concat(process.env.PM2_NODE_OPTIONS.split(' '));\n      }\n\n      if (interpreter === 'node' || RegExp('node$').test(interpreter)) {\n        args.push(path.resolve(path.dirname(module.filename), '..', 'ProcessContainerFork.js'));\n      }\n      else\n        args.push(pm2_env.pm_exec_path);\n    }\n    else {\n      command = pm2_env.pm_exec_path;\n      args = [ ];\n    }\n\n    if (pm2_env.args) {\n      args = args.concat(pm2_env.args);\n    }\n\n    // piping stream o file\n    var stds = {\n      out: pm2_env.pm_out_log_path,\n      err: pm2_env.pm_err_log_path\n    };\n\n    // entire log std if necessary.\n    if ('pm_log_path' in pm2_env){\n      stds.std = pm2_env.pm_log_path;\n    }\n\n    log(\"stds: %j\", stds);\n\n    Utility.startLogging(stds, function(err, result) {\n      if (err) {\n        God.logAndGenerateError(err);\n        return cb(err);\n      };\n\n      try {\n        var cspr = spawn(command, args, {\n          env      : pm2_env,\n          detached : true,\n          cwd      : pm2_env.pm_cwd || process.cwd(),\n          stdio    : ['pipe', 'pipe', 'pipe', 'ipc'] //Same as fork() in node core\n        });\n      } catch(e) {\n        God.logAndGenerateError(e);\n        return cb(e);\n      }\n\n      cspr.process = {};\n      cspr.process.pid = cspr.pid;\n      cspr.pm2_env = pm2_env;\n\n      cspr.stderr.on('data', function forkErrData(data) {\n        var log_data = null;\n\n        if (pm2_env.log_type && pm2_env.log_type === 'json') {\n          log_data = JSON.stringify({\n            message : data.toString(),\n          timestamp : pm2_env.log_date_format ? moment().format(pm2_env.log_date_format) : new Date().toISOString(),\n            type : 'err',\n            process_id : cspr.pm2_env.pm_id,\n            app_name : cspr.pm2_env.name\n          }) + '\\n';\n        }\n        else if (pm2_env.log_date_format)\n          log_data = moment().format(pm2_env.log_date_format) + ': ' + data.toString();\n        else\n          log_data = data.toString();\n\n        stds.std && stds.std.write && stds.std.write(log_data);\n\n        // hardcoded values of special log path to not write on disk\n        if (pm2_env.pm_err_log_path !== 'NULL' && pm2_env.pm_err_log_path !== '/dev/null') {\n          stds.err.write && stds.err.write(log_data);\n        }\n\n        God.bus.emit('log:err', {\n          process : {\n            pm_id      : cspr.pm2_env.pm_id,\n            name       : cspr.pm2_env.name,\n            rev        : (cspr.pm2_env.versioning && cspr.pm2_env.versioning.revision) ? cspr.pm2_env.versioning.revision : null\n          },\n          at  : Utility.getDate(),\n          data : log_data\n        });\n      });\n\n      cspr.stdout.on('data', function forkOutData(data) {\n        var log_data = null;\n\n        if (pm2_env.log_type && pm2_env.log_type === 'json') {\n          log_data = JSON.stringify({\n            message : data.toString(),\n            timestamp : pm2_env.log_date_format ? moment().format(pm2_env.log_date_format) : new Date().toISOString(),\n            type : 'out',\n            process_id : cspr.pm2_env.pm_id,\n            app_name : cspr.pm2_env.name\n          }) + '\\n';\n        }\n        else if (pm2_env.log_date_format)\n          log_data = moment().format(pm2_env.log_date_format) + ': ' + data.toString();\n        else\n          log_data = data.toString();\n\n        stds.std && stds.std.write && stds.std.write(log_data);\n\n        // hardcoded values of special log path to not write on disk\n        if (pm2_env.pm_out_log_path !== 'NULL' && pm2_env.pm_out_log_path !== '/dev/null') {\n          stds.out.write && stds.out.write(log_data);\n        }\n\n        God.bus.emit('log:out', {\n          process : {\n            pm_id      : cspr.pm2_env.pm_id,\n            name       : cspr.pm2_env.name,\n            rev        : (cspr.pm2_env.versioning && cspr.pm2_env.versioning.revision) ? cspr.pm2_env.versioning.revision : null\n          },\n          at  : Utility.getDate(),\n          data : log_data\n        });\n      });\n\n      /**\n       * Broadcast message to God\n       */\n      cspr.on('message', function forkMessage(msg) {\n        /*********************************\n         * If you edit this function\n         * Do the same in ClusterMode.js !\n         *********************************/\n        if (msg.data && msg.type) {\n          process.nextTick(function() {\n            return God.bus.emit(msg.type ? msg.type : 'process:msg', {\n              at      : Utility.getDate(),\n              data    : msg.data,\n              process : {\n                pm_id      : cspr.pm2_env.pm_id,\n                name       : cspr.pm2_env.name,\n                versioning : cspr.pm2_env.versioning\n              }\n            });\n          });\n        }\n        else {\n\n          if (typeof msg == 'object' && 'node_version' in msg) {\n            cspr.pm2_env.node_version = msg.node_version;\n            return false;\n          } else if (typeof msg == 'object' && 'cron_restart' in msg) {\n            // cron onTick is invoked in the process\n            return God.restartProcessId({\n              id : cspr.pm2_env.pm_id\n            }, function() {\n              console.log('Application %s has been restarted via CRON', cspr.pm2_env.name);\n            });\n          }\n\n          return God.bus.emit('process:msg', {\n            at      : Utility.getDate(),\n            raw     : msg,\n            process :  {\n              pm_id      : cspr.pm2_env.pm_id,\n              name       : cspr.pm2_env.name\n            }\n          });\n        }\n      });\n\n      try {\n        fs.writeFileSync(pidFile, cspr.pid);\n      } catch (e) {\n        console.error(e.stack || e);\n      }\n\n      cspr.once('exit', function forkClose(status) {\n        try {\n          for(var k in stds){\n            if (stds[k].destroy) stds[k].destroy();\n            else if (stds[k].end) stds[k].end();\n            else if (stds[k].close) stds[k].close();\n            stds[k] = stds[k]._file;\n          }\n        } catch(e) { God.logAndGenerateError(e);}\n      });\n\n      cspr._reloadLogs = function(cb) {\n        for (var k in stds){\n          if (stds[k].destroy) stds[k].destroy();\n          else if (stds[k].end) stds[k].end();\n          else if (stds[k].close) stds[k].close();\n          stds[k] = stds[k]._file;\n        }\n        //cspr.removeAllListeners();\n        Utility.startLogging(stds, cb);\n      };\n\n      cspr.unref();\n\n      return cb(null, cspr);\n    });\n\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/God/ClusterMode.js":"/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\n'use strict';\n\n/**\n * @file Cluster execution functions related\n * @author Alexandre Strzelewicz <as@unitech.io>\n * @project PM2\n */\nvar cluster       = require('cluster');\nvar cst           = require('../../constants.js');\nvar Utility       = require('../Utility.js');\nvar pkg           = require('../../package.json');\n\n/**\n * Description\n * @method exports\n * @param {} God\n * @return\n */\nmodule.exports = function ClusterMode(God) {\n\n  /**\n   * For Node apps - Cluster mode\n   * It will wrap the code and enable load-balancing mode\n   * @method nodeApp\n   * @param {} env_copy\n   * @param {} cb\n   * @return Literal\n   */\n  God.nodeApp = function nodeApp(env_copy, cb){\n    var clu = null;\n\n    console.log('Starting execution sequence in -cluster mode- for app name:%s id:%s',\n                env_copy.name,\n                env_copy.pm_id);\n\n    if (env_copy.node_args && Array.isArray(env_copy.node_args)) {\n      cluster.settings.execArgv = env_copy.node_args;\n    }\n\n    env_copy._pm2_version = pkg.version;\n\n    try {\n      // node.js cluster clients can not receive deep-level objects or arrays in the forked process, e.g.:\n      // { \"args\": [\"foo\", \"bar\"], \"env\": { \"foo1\": \"bar1\" }} will be parsed to\n      // { \"args\": \"foo, bar\", \"env\": \"[object Object]\"}\n      // So we passing a stringified JSON here.\n      clu = cluster.fork({pm2_env: JSON.stringify(env_copy)});\n    } catch(e) {\n      God.logAndGenerateError(e);\n      return cb(e);\n    }\n\n    clu.pm2_env = env_copy;\n\n    /**\n     * Broadcast message to God\n     */\n    clu.on('message', function cluMessage(msg) {\n      /*********************************\n       * If you edit this function\n       * Do the same in ForkMode.js !\n       *********************************/\n      if (msg.data && msg.type) {\n        return God.bus.emit(msg.type ? msg.type : 'process:msg', {\n          at      : Utility.getDate(),\n          data    : msg.data,\n          process :  {\n            pm_id      : clu.pm2_env.pm_id,\n            name       : clu.pm2_env.name,\n            rev        : (clu.pm2_env.versioning && clu.pm2_env.versioning.revision) ? clu.pm2_env.versioning.revision : null\n          }\n        });\n      }\n      else {\n\n        if (typeof msg == 'object' && 'node_version' in msg) {\n          clu.pm2_env.node_version = msg.node_version;\n          return false;\n        } else if (typeof msg == 'object' && 'cron_restart' in msg) {\n          return God.restartProcessId({\n            id : clu.pm2_env.pm_id\n          }, function() {\n            console.log('Application %s has been restarted via CRON', clu.pm2_env.name);\n          });\n        }\n\n        return God.bus.emit('process:msg', {\n          at      : Utility.getDate(),\n          raw     : msg,\n          process :  {\n            pm_id      : clu.pm2_env.pm_id,\n            name       : clu.pm2_env.name\n          }\n        });\n      }\n    });\n\n    return cb(null, clu);\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/God/Reload.js":"/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\n'use strict';\n\n/**\n * @file Reload functions related\n * @author Alexandre Strzelewicz <as@unitech.io>\n * @project PM2\n */\n\nvar async         = require('async');\nvar cst           = require('../../constants.js');\nvar Utility       = require('../Utility.js');\n\n/**\n * softReload will wait permission from process to exit\n * @method softReload\n * @param {} God\n * @param {} id\n * @param {} cb\n * @return Literal\n */\nfunction softReload(God, id, cb) {\n  var t_key = '_old_' + id;\n\n  // Move old worker to tmp id\n  God.clusters_db[t_key] = God.clusters_db[id];\n\n  delete God.clusters_db[id];\n\n  var old_worker = God.clusters_db[t_key];\n\n  // Deep copy\n  var new_env = Utility.clone(old_worker.pm2_env);\n  new_env.restart_time += 1;\n\n  // Reset created_at and unstable_restarts\n  God.resetState(new_env);\n\n  old_worker.pm2_env.pm_id = t_key;\n  old_worker.pm_id = t_key;\n\n  God.executeApp(new_env, function(err, new_worker) {\n    if (err) return cb(err);\n\n    var timer = null;\n\n    var onListen = function () {\n      clearTimeout(timer);\n      softCleanDeleteProcess();\n      console.log('-softReload- New worker listening');\n    };\n\n    // Bind to know when the new process is up\n    new_worker.once('listening', onListen);\n\n    timer = setTimeout(function() {\n      new_worker.removeListener('listening', onListen);\n      softCleanDeleteProcess();\n    }, new_env.listen_timeout || cst.GRACEFUL_LISTEN_TIMEOUT);\n\n    // Remove old worker properly\n    var softCleanDeleteProcess = function () {\n      var cleanUp = function () {\n        clearTimeout(timer);\n        console.log('-softReload- Old worker disconnected');\n        return God.deleteProcessId(t_key, cb);\n      };\n\n      old_worker.once('disconnect', cleanUp);\n\n      try {\n        if (old_worker.state != 'dead' && old_worker.state != 'disconnected')\n          old_worker.send && old_worker.send('shutdown');\n        else {\n          clearTimeout(timer);\n          console.error('Worker %d is already disconnected', old_worker.pm2_env.pm_id);\n          return God.deleteProcessId(t_key, cb);\n        }\n      } catch(e) {\n        clearTimeout(timer);\n        console.error('Worker %d is already disconnected', old_worker.pm2_env.pm_id);\n        return God.deleteProcessId(t_key, cb);\n      }\n\n      timer = setTimeout(function () {\n        old_worker.removeListener('disconnect', cleanUp);\n        return God.deleteProcessId(t_key, cb);\n      }, cst.GRACEFUL_TIMEOUT);\n      return false;\n    };\n    return false;\n  });\n  return false;\n};\n\n/**\n * hardReload will reload without waiting permission from process\n * @method hardReload\n * @param {} God\n * @param {} id\n * @param {} cb\n * @return Literal\n */\nfunction hardReload(God, id, wait_msg, cb) {\n  var t_key = '_old_' + id;\n\n  // Move old worker to tmp id\n  God.clusters_db[t_key] = God.clusters_db[id];\n  delete God.clusters_db[id];\n\n  var old_worker = God.clusters_db[t_key];\n  // Deep copy\n  var new_env = Utility.clone(old_worker.pm2_env);\n  new_env.restart_time += 1;\n\n  // Reset created_at and unstable_restarts\n  God.resetState(new_env);\n\n  old_worker.pm2_env.pm_id = t_key;\n  old_worker.pm_id = t_key;\n\n  God.executeApp(new_env, function(err, new_worker) {\n    if (err) return cb(err);\n\n    var timer = null;\n\n    var onListen = function () {\n      clearTimeout(timer);\n      console.log('-reload- New worker listening');\n      return God.deleteProcessId(t_key, cb);\n    };\n\n    // Bind to know when the new process is up\n    if (wait_msg == 'listening')\n      new_worker.once('listening', onListen);\n    else {\n      var listener = function (packet) {\n        if (packet.raw === 'ready' &&\n            packet.process.name === new_worker.pm2_env.name &&\n            packet.process.pm_id === new_worker.pm2_env.pm_id) {\n          God.bus.removeListener('process:msg', listener)\n          return onListen();\n        }\n      }\n      God.bus.on('process:msg', listener);\n    }\n\n    timer = setTimeout(function() {\n      if (wait_msg == 'listening')\n        new_worker.removeListener(wait_msg, onListen);\n      else\n        God.bus.removeListener('process:msg', listener)\n\n      return God.deleteProcessId(t_key, cb);\n    }, new_env.listen_timeout || cst.GRACEFUL_LISTEN_TIMEOUT);\n\n    return false;\n  });\n  return false;\n};\n\n/**\n * Description\n * @method exports\n * @param {} God\n * @return\n */\nmodule.exports = function(God) {\n\n  /**\n   * GracefulReload\n   * @method softReloadProcessId\n   * @param {} id\n   * @param {} cb\n   * @return CallExpression\n   */\n  God.softReloadProcessId = function(opts, cb) {\n    var id  = opts.id;\n    var env = opts.env || {};\n\n    if (!(id in God.clusters_db))\n      return cb(new Error('PM ID unknown'));\n\n    if (God.clusters_db[id].pm2_env.status == cst.ONLINE_STATUS &&\n        God.clusters_db[id].pm2_env.exec_mode == 'cluster_mode' &&\n        !God.clusters_db[id].pm2_env.wait_ready) {\n\n      Utility.extendExtraConfig(God.clusters_db[id], opts);\n      Utility.extend(God.clusters_db[id].pm2_env.env, opts.env);\n\n      return softReload(God, id, cb);\n    }\n    else {\n      console.log('Process %s in a stopped status, starting it', id);\n      return God.restartProcessId(opts, cb);\n    }\n  };\n\n  /**\n   * Reload\n   * @method reloadProcessId\n   * @param {} id\n   * @param {} cb\n   * @return CallExpression\n   */\n  God.reloadProcessId = function(opts, cb) {\n    var id  = opts.id;\n    var env = opts.env || {};\n\n    if (!(id in God.clusters_db))\n      return cb(new Error('PM2 ID unknown'));\n\n    if (God.clusters_db[id].pm2_env.status == cst.ONLINE_STATUS &&\n        God.clusters_db[id].pm2_env.exec_mode == 'cluster_mode') {\n\n      Utility.extendExtraConfig(God.clusters_db[id], opts);\n      Utility.extend(God.clusters_db[id].pm2_env.env, opts.env);\n\n      var wait_msg = God.clusters_db[id].pm2_env.wait_ready ? 'ready' : 'listening';\n      return hardReload(God, id, wait_msg, cb);\n    }\n    else {\n      console.log('Process %s in a stopped status, starting it', id);\n      return God.restartProcessId(opts, cb);\n    }\n  };\n\n};\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/God/ActionMethods.js":"/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\n'use strict';\n\n/**\n * @file ActionMethod like restart, stop, monitor... are here\n * @author Alexandre Strzelewicz <as@unitech.io>\n * @project PM2\n */\n\nvar fs            = require('fs');\nvar path          = require('path');\nvar async         = require('async');\nvar os            = require('os');\nvar p             = path;\nvar cst           = require('../../constants.js');\nvar pkg           = require('../../package.json');\nvar pidusage      = require('pidusage');\nvar util          = require('util');\nvar debug         = require('debug')('pm2:ActionMethod');\nvar Utility       = require('../Utility');\nvar semver        = require('semver');\n\n/**\n * Description\n * @method exports\n * @param {} God\n * @return\n */\nmodule.exports = function(God) {\n  /**\n   * Description\n   * @method getMonitorData\n   * @param {} env\n   * @param {} cb\n   * @return\n   */\n  God.getMonitorData = function getMonitorData(env, cb) {\n    var processes = God.getFormatedProcesses();\n\n    async.eachSeries(processes, function computeMonitor(pro, next) {\n      if (pro.pm2_env.status == cst.ONLINE_STATUS) {\n        var pid = pro.pid;\n\n        if (pro.pm2_env.axm_options && pro.pm2_env.axm_options.pid) {\n          if (isNaN(pro.pm2_env.axm_options.pid)) {\n            pro['monit'] = {\n              memory : 0,\n              cpu : 0\n            };\n            return process.nextTick(next);\n          }\n          pid = pro.pm2_env.axm_options.pid;\n        }\n\n        pidusage.stat(pid, function retPidUsage(err, res) {\n          if (err) {\n            // Do not log, some time modules does not retrieve PID\n            // console.error('Error caught while calling pidusage');\n            // console.error(err);\n            pro['monit'] = {\n              memory : 0,\n              cpu : 0\n            };\n            return next();\n          }\n\n          pro['monit'] = {\n            memory : Math.floor(res.memory),\n            cpu    : Math.floor(res.cpu)\n          };\n          res = null;\n          pid = null;\n          return next();\n        });\n      }\n      else {\n        pro['monit'] = {\n          memory : 0,\n          cpu : 0\n        };\n        return next();\n      }\n    }, function retMonitor(err, res) {\n      if (err) return cb(God.logAndGenerateError(err), null);\n      return cb(null, processes);\n    });\n\n  };\n\n  /**\n   * Description\n   * @method getSystemData\n   * @param {} env\n   * @param {} cb\n   * @return\n   */\n  God.getSystemData = function getSystemData(env, cb) {\n    God.getMonitorData(env, function(err, processes) {\n      cb(err, {\n        system: {\n          hostname: os.hostname(),\n          uptime: os.uptime(),\n          cpus: os.cpus(),\n          load: os.loadavg(),\n          memory: {\n            free: os.freemem(),\n            total: os.totalmem()\n          },\n          time: Utility.getDate()\n        },\n        processes: processes\n      });\n    });\n  };\n\n  /**\n   * Description\n   * @method dumpProcessList\n   * @param {} cb\n   * @return\n   */\n  God.dumpProcessList = function(cb) {\n    var process_list = [];\n    var apps         = Utility.clone(God.getFormatedProcesses());\n\n    // Don't override the actual dump file if process list is empty\n    // unless user explicitely did `pm2 dump`.\n    // This often happens when PM2 crashed, we don't want to override\n    // the dump file with an empty list of process.\n    if (!apps[0]) {\n      debug('[PM2] Did not override dump file because list of processes is empty');\n      return cb(null, {success:true, process_list: process_list});\n    }\n\n    function fin(err) {\n      try {\n        fs.writeFileSync(cst.DUMP_FILE_PATH, JSON.stringify(process_list));\n      } catch (e) {\n        console.error(e.stack || e);\n      }\n      return cb(null, {success:true, process_list: process_list});\n    }\n\n    function saveProc(apps) {\n      if (!apps[0])\n        return fin(null);\n      delete apps[0].pm2_env.instances;\n      delete apps[0].pm2_env.pm_id;\n      // Do not dump modules\n      if (!apps[0].pm2_env.pmx_module)\n        process_list.push(apps[0].pm2_env);\n      apps.shift();\n      return saveProc(apps);\n    }\n    saveProc(apps);\n  };\n\n  /**\n   * Description\n   * @method ping\n   * @param {} env\n   * @param {} cb\n   * @return CallExpression\n   */\n  God.ping = function(env, cb) {\n    return cb(null, {msg : 'pong'});\n  };\n\n  /**\n   * Description\n   * @method notifyKillPM2\n   */\n  God.notifyKillPM2 = function() {\n    God.pm2_being_killed = true;\n  };\n\n  /**\n   * Duplicate a process\n   * @method duplicateProcessId\n   * @param {} id\n   * @param {} cb\n   * @return CallExpression\n   */\n  God.duplicateProcessId = function(id, cb) {\n    if (!(id in God.clusters_db))\n      return cb(God.logAndGenerateError(id + ' id unknown'), {});\n\n    if (!God.clusters_db[id] || !God.clusters_db[id].pm2_env)\n      return cb(God.logAndGenerateError('Error when getting proc || proc.pm2_env'), {});\n\n    var proc = Utility.clone(God.clusters_db[id].pm2_env);\n\n    delete proc.created_at;\n    delete proc.pm_id;\n\n    God.executeApp(proc, function(err, clu) {\n      God.notify('start', clu, true);\n      cb(err, [Utility.clone(clu)]);\n    });\n  };\n\n  /**\n   * Start a stopped process by ID\n   * @method startProcessId\n   * @param {} id\n   * @param {} cb\n   * @return CallExpression\n   */\n  God.startProcessId = function(id, cb) {\n    if (!(id in God.clusters_db))\n      return cb(God.logAndGenerateError(id + ' id unknown'), {});\n\n    var proc = God.clusters_db[id];\n    if (proc.pm2_env.status == cst.ONLINE_STATUS)\n      return cb(God.logAndGenerateError('process already online'), {});\n    if (proc.pm2_env.status == cst.LAUNCHING_STATUS)\n      return cb(God.logAndGenerateError('process already started'), {});\n    if (proc.process && proc.process.pid)\n      return cb(God.logAndGenerateError('Process with pid ' + proc.process.pid + ' already exists'), {});\n\n    return God.executeApp(God.clusters_db[id].pm2_env, function(err, proc) {\n      return cb(err, Utility.clone(proc));\n    });\n  };\n\n\n  /**\n   * Stop a process and set it on state 'stopped'\n   * @method stopProcessId\n   * @param {} id\n   * @param {} cb\n   * @return Literal\n   */\n  God.stopProcessId = function(id, cb) {\n    if (typeof id == 'object' && 'id' in id)\n      id = id.id;\n\n    if (!(id in God.clusters_db))\n      return cb(God.logAndGenerateError(id + ' : id unknown'), {});\n\n    //clear time-out restart task\n    clearTimeout(God.clusters_db[id].pm2_env.restart_task);\n\n    if (God.clusters_db[id].pm2_env.status == cst.STOPPED_STATUS)\n      return cb(null, God.getFormatedProcess(id));\n    // state == 'none' means that the process is not online yet\n    if (God.clusters_db[id].state && God.clusters_db[id].state === 'none')\n      return setTimeout(function() { God.stopProcessId(id, cb); }, 250);\n\n    var proc     = God.clusters_db[id];\n\n    console.log('Stopping app:%s id:%s', proc.pm2_env.name, proc.pm2_env.pm_id);\n    proc.pm2_env.status = cst.STOPPING_STATUS;\n\n    if (!proc.process.pid) {\n      console.error('app=%s id=%d does not have a pid', proc.pm2_env.name, proc.pm2_env.pm_id);\n      proc.pm2_env.status = cst.STOPPED_STATUS;\n      return cb(null, { error : true, message : 'could not kill process w/o pid'});\n    }\n\n    God.killProcess(proc.process.pid, proc.pm2_env, function(err) {\n      proc.pm2_env.status = cst.STOPPED_STATUS;\n      pidusage.unmonitor(proc.process.pid);\n\n      God.notify('exit', proc);\n\n      if (err && err.type && err.type === 'timeout') {\n        console.error('app=%s id=%d pid=%s could not be stopped',\n                      proc.pm2_env.name,\n                      proc.pm2_env.pm_id,\n                      proc.process.pid);\n        proc.pm2_env.status = cst.ERRORED_STATUS;\n        return cb(null, God.getFormatedProcess(id));\n      }\n\n      if (proc.pm2_env.pm_id.toString().indexOf('_old_') !== 0) {\n        try {\n          fs.unlinkSync(proc.pm2_env.pm_pid_path);\n        } catch (e) {}\n      }\n\n      if (proc.pm2_env.axm_actions) proc.pm2_env.axm_actions = [];\n      if (proc.pm2_env.axm_monitor) proc.pm2_env.axm_monitor = {};\n\n      proc.process.pid = 0;\n      return cb(null, God.getFormatedProcess(id));\n    });\n  };\n\n  God.resetMetaProcessId = function(id, cb) {\n    if (!(id in God.clusters_db))\n      return cb(God.logAndGenerateError(id + ' id unknown'), {});\n\n    if (!God.clusters_db[id] || !God.clusters_db[id].pm2_env)\n      return cb(God.logAndGenerateError('Error when getting proc || proc.pm2_env'), {});\n\n    God.clusters_db[id].pm2_env.created_at = Utility.getDate();\n    God.clusters_db[id].pm2_env.unstable_restarts = 0;\n    God.clusters_db[id].pm2_env.restart_time = 0;\n\n    return cb(null, God.getFormatedProcesses());\n  };\n\n  /**\n   * Delete a process by id\n   * It will stop it and remove it from the database\n   * @method deleteProcessId\n   * @param {} id\n   * @param {} cb\n   * @return Literal\n   */\n  God.deleteProcessId = function(id, cb) {\n    God.stopProcessId(id, function(err, proc) {\n      if (err) return cb(God.logAndGenerateError(err), {});\n      // ! transform to slow object\n      delete God.clusters_db[id];\n\n      if (Object.keys(God.clusters_db).length == 0)\n        God.next_id = 0;\n      return cb(null, proc);\n    });\n    return false;\n  };\n\n  /**\n   * Restart a process ID\n   * If the process is online it will not put it on state stopped\n   * but directly kill it and let God restart it\n   * @method restartProcessId\n   * @param {} id\n   * @param {} cb\n   * @return Literal\n   */\n  God.restartProcessId = function(opts, cb) {\n    var id = opts.id;\n    var env = opts.env || {};\n\n    if (typeof(id) === 'undefined')\n      return cb(God.logAndGenerateError('opts.id not passed to restartProcessId', opts));\n    if (!(id in God.clusters_db))\n      return cb(God.logAndGenerateError('God db process id unknown'), {});\n\n    var proc = God.clusters_db[id];\n\n    God.resetState(proc.pm2_env);\n\n    /**\n     * Merge new application configuration on restart\n     * Same system in reloadProcessId and softReloadProcessId\n     */\n    Utility.extendExtraConfig(proc, opts);\n    Utility.extend(proc.pm2_env.env, opts.env);\n\n    if (God.pm2_being_killed) {\n      return cb(God.logAndGenerateError('[RestartProcessId] PM2 is being killed, stopping restart procedure...'));\n    }\n    if (proc.pm2_env.status === cst.ONLINE_STATUS || proc.pm2_env.status === cst.LAUNCHING_STATUS) {\n      God.stopProcessId(id, function(err) {\n        if (God.pm2_being_killed)\n          return cb(God.logAndGenerateError('[RestartProcessId] PM2 is being killed, stopping restart procedure...'));\n        proc.pm2_env.restart_time += 1;\n        return God.startProcessId(id, cb);\n      });\n\n      return false;\n    }\n    else {\n      debug('[restart] process not online, starting it');\n      return God.startProcessId(id, cb);\n    }\n  };\n\n\n  /**\n   * Restart all process by name\n   * @method restartProcessName\n   * @param {} name\n   * @param {} cb\n   * @return Literal\n   */\n  God.restartProcessName = function(name, cb) {\n    var processes = God.findByName(name);\n\n    if (processes && processes.length === 0)\n      return cb(God.logAndGenerateError('Unknown process'), {});\n\n    async.eachLimit(processes, cst.CONCURRENT_ACTIONS, function(proc, next) {\n      if (God.pm2_being_killed)\n        return next('[Watch] PM2 is being killed, stopping restart procedure...');\n      if (proc.pm2_env.status === cst.ONLINE_STATUS)\n        return God.restartProcessId({id:proc.pm2_env.pm_id}, next);\n      else if (proc.pm2_env.status !== cst.STOPPING_STATUS\n               && proc.pm2_env.status !== cst.LAUNCHING_STATUS)\n        return God.startProcessId(proc.pm2_env.pm_id, next);\n      else\n        return next(\"[Watch] Process name %s is being stopped so I won't restart it\", name);\n    }, function(err) {\n      if (err) return cb(God.logAndGenerateError(err));\n      return cb(null, God.getFormatedProcesses());\n    });\n\n    return false;\n  };\n\n  /**\n   * Send system signal to process id\n   * @method sendSignalToProcessId\n   * @param {} opts\n   * @param {} cb\n   * @return CallExpression\n   */\n  God.sendSignalToProcessId = function(opts, cb) {\n    var id = opts.process_id;\n    var signal = opts.signal;\n\n    if (!(id in God.clusters_db))\n      return cb(God.logAndGenerateError(id + ' id unknown'), {});\n\n    var proc = God.clusters_db[id];\n\n    //God.notify('send signal ' + signal, proc, true);\n\n    try {\n      process.kill(God.clusters_db[id].process.pid, signal);\n    } catch(e) {\n      return cb(God.logAndGenerateError('Error when sending signal (signal unknown)'), {});\n    }\n    return cb(null, God.getFormatedProcesses());\n  };\n\n  /**\n   * Send system signal to all processes by name\n   * @method sendSignalToProcessName\n   * @param {} opts\n   * @param {} cb\n   * @return\n   */\n  God.sendSignalToProcessName = function(opts, cb) {\n    var processes = God.findByName(opts.process_name);\n    var signal    = opts.signal;\n\n    if (processes && processes.length === 0)\n      return cb(God.logAndGenerateError('Unknown process name'), {});\n\n    async.eachLimit(processes, cst.CONCURRENT_ACTIONS, function(proc, next) {\n      if (proc.pm2_env.status == cst.ONLINE_STATUS || proc.pm2_env.status == cst.LAUNCHING_STATUS) {\n        try {\n          process.kill(proc.process.pid, signal);\n        } catch(e) {\n          return next(e);\n        }\n      }\n      return setTimeout(next, 200);\n    }, function(err) {\n      if (err) return cb(God.logAndGenerateError(err), {});\n      return cb(null, God.getFormatedProcesses());\n    });\n\n  };\n\n  /**\n   * Stop watching daemon\n   * @method stopWatch\n   * @param {} method\n   * @param {} value\n   * @param {} fn\n   * @return\n   */\n  God.stopWatch = function(method, value, fn) {\n    var env = null;\n\n    if (method == 'stopAll' || method == 'deleteAll') {\n      var processes = God.getFormatedProcesses();\n\n      processes.forEach(function(proc) {\n        God.clusters_db[proc.pm_id].pm2_env.watch = false;\n        God.watch.disable(proc.pm2_env);\n      });\n\n    } else {\n\n      if (method.indexOf('ProcessId') !== -1) {\n        env = God.clusters_db[value];\n      } else if (method.indexOf('ProcessName') !== -1) {\n        env = God.clusters_db[God.findByName(value)];\n      }\n\n      if (env) {\n        God.watch.disable(env.pm2_env);\n        env.pm2_env.watch = false;\n      }\n    }\n    return fn(null, {success:true});\n  };\n\n\n  /**\n   * Toggle watching daemon\n   * @method toggleWatch\n   * @param {String} method\n   * @param {Object} application environment, should include id\n   * @param {Function} callback\n   */\n  God.toggleWatch = function(method, value, fn) {\n    var env = null;\n\n    if (method == 'restartProcessId') {\n      env = God.clusters_db[value.id];\n    } else if(method == 'restartProcessName') {\n      env = God.clusters_db[God.findByName(value)];\n    }\n\n    if (env) {\n      //env.pm2_env.env.watch = !env.pm2_env.env.watch;\n      env.pm2_env.watch = !env.pm2_env.watch;\n      if (env.pm2_env.watch)\n        God.watch.enable(env.pm2_env);\n      else\n        God.watch.disable(env.pm2_env);\n    }\n\n    return fn(null, {success:true});\n  };\n\n  /**\n   * Start Watch\n   * @method startWatch\n   * @param {String} method\n   * @param {Object} application environment, should include id\n   * @param {Function} callback\n   */\n  God.startWatch = function(method, value, fn) {\n    var env = null;\n\n    if (method == 'restartProcessId') {\n      env = God.clusters_db[value.id];\n    } else if(method == 'restartProcessName') {\n      env = God.clusters_db[God.findByName(value)];\n    }\n\n    if (env) {\n      if (env.pm2_env.watch)\n        return fn(null, {success:true, notrestarted:true});\n\n      God.watch.enable(env.pm2_env);\n      //env.pm2_env.env.watch = true;\n      env.pm2_env.watch = true;\n    }\n\n    return fn(null, {success:true});\n  };\n\n  /**\n   * Description\n   * @method reloadLogs\n   * @param {} opts\n   * @param {} cb\n   * @return CallExpression\n   */\n  God.reloadLogs = function(opts, cb) {\n    console.log('Reloading logs...');\n    var processIds = Object.keys(God.clusters_db);\n\n    processIds.forEach(function (id) {\n      var cluster = God.clusters_db[id];\n\n      console.log('Reloading logs for process id %d', id);\n\n      if (cluster &&\n          cluster.pm2_env) {\n        if (cluster.send &&\n            cluster.pm2_env.exec_mode == 'cluster_mode') {\n          cluster.send({\n            type:'log:reload'\n          });\n        }\n        else if (cluster._reloadLogs) {\n          cluster._reloadLogs(function(err) {\n            if (err) God.logAndGenerateError(err);\n          });\n        }\n      }\n    });\n\n    return cb(null, {});\n  };\n\n  God.sendDataToProcessId = function(packet, cb) {\n    if (typeof(packet.id) == undefined ||\n        !packet.data ||\n        !packet.topic)\n      return cb(God.logAndGenerateError('ID, DATA or TOPIC field is missing'), {});\n\n    var pm_id = packet.id;\n    var data  = packet.data;\n\n    var proc = God.clusters_db[pm_id];\n\n    if (!proc)\n      return cb(God.logAndGenerateError('Process with ID ', pm_id, ' unknown!'), {});\n\n    if (proc.pm2_env.status != cst.ONLINE_STATUS && proc.pm2_env.status != cst.LAUNCHING_STATUS)\n      return cb(God.logAndGenerateError('Process with ID ', pm_id, ' unknown!'), {});\n\n    try {\n      proc.send(packet);\n    }\n    catch(e) {\n      return cb(God.logAndGenerateError(e), {});\n    }\n\n    return cb(null, {\n      success: true,\n      data   : packet\n    });\n  };\n\n  /**\n   * Send Message to Process by id or name\n   * @method msgProcess\n   * @param {} cmd\n   * @param {} cb\n   * @return Literal\n   */\n  God.msgProcess = function(cmd, cb) {\n    if ('id' in cmd) {\n      var id = cmd.id;\n      if (!(id in God.clusters_db))\n        return cb(God.logAndGenerateError(id + ' id unknown'), {});\n      var proc = God.clusters_db[id];\n\n      var action_exist = false;\n\n      proc.pm2_env.axm_actions.forEach(function(action) {\n        if (action.action_name == cmd.msg) {\n          action_exist = true;\n          // Reset output buffer\n          action.output = [];\n        }\n      });\n      if (action_exist == false) {\n        return cb(God.logAndGenerateError('Action doesn\\'t exist ' + cmd.msg + ' for ' + proc.pm2_env.name), {});\n      }\n\n      if (proc.pm2_env.status == cst.ONLINE_STATUS || proc.pm2_env.status == cst.LAUNCHING_STATUS) {\n        /*\n         * Send message\n         */\n        if (cmd.opts == null)\n          proc.send(cmd.msg);\n        else\n          proc.send(cmd);\n\n        return cb(null, { process_count : 1, success : true });\n      }\n      else\n        return cb(God.logAndGenerateError(id + ' : id offline'), {});\n    }\n\n    else if ('name' in cmd) {\n      /*\n       * As names are not unique in case of cluster, this\n       * will send msg to all process matching  'name'\n       */\n      var name = cmd.name;\n      var arr = Object.keys(God.clusters_db);\n      var sent = 0;\n\n      (function ex(arr) {\n        if (arr[0] == null) return cb(null, { process_count : sent, success : true });\n\n        var id      = arr[0];\n\n        if (!God.clusters_db[id] || !God.clusters_db[id].pm2_env) {\n          arr.shift();\n          return ex(arr);\n        }\n\n        var proc_env = God.clusters_db[id].pm2_env;\n\n        if (p.basename(proc_env.pm_exec_path) == name || proc_env.name == name) {\n          if (proc_env.status == cst.ONLINE_STATUS || proc.pm2_env.status == cst.LAUNCHING_STATUS) {\n\n            if (cmd.opts == null)\n              God.clusters_db[id].send(cmd.msg);\n            else\n              God.clusters_db[id].send(cmd);\n\n            sent++;\n            arr.shift();\n            return ex(arr);\n\n          }\n        }\n        else {\n          arr.shift();\n          return ex(arr);\n        }\n        return false;\n      })(arr);\n    }\n\n    else return cb(God.logAndGenerateError('method requires name or id field'), {});\n    return false;\n  };\n\n  /**\n   * Description\n   * @method getVersion\n   * @param {} env\n   * @param {} cb\n   * @return CallExpression\n   */\n  God.getVersion = function(env, cb) {\n    process.nextTick(function() {\n      return cb(null, pkg.version);\n    });\n  };\n\n};\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/Watcher.js":"/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\nvar chokidar = require('chokidar');\nvar p        = require('path');\nvar util     = require('util');\nvar log      = require('debug')('pm2:watch');\n\nmodule.exports = function ClusterMode(God) {\n  /**\n   * Watch folder for changes and restart\n   * @method watch\n   * @param {Object} pm2_env pm2 app environnement\n   * @return MemberExpression\n   */\n  God.watch = {};\n\n  God.watch._watchers = [];\n\n  God.watch.enable = function(pm2_env) {\n\n    if (God.watch._watchers[pm2_env.name]) {\n      God.watch._watchers[pm2_env.name].close();\n      God.watch._watchers[pm2_env.name] = null;\n      delete God.watch._watchers[pm2_env.name];\n    }\n\n    log('Initial watch ', pm2_env.watch)\n\n    var watch = pm2_env.watch\n\n    if(typeof watch == 'boolean' || util.isArray(watch) && watch.length === 0)\n      watch = pm2_env.pm_cwd;\n\n    log('Watching %s', watch);\n\n    var watch_options = {\n      ignored       : pm2_env.ignore_watch || /[\\/\\\\]\\.|node_modules/,\n      persistent    : true,\n      ignoreInitial : true,\n      cwd: pm2_env.pm_cwd\n    };\n\n    if (pm2_env.watch_options) {\n      watch_options = util._extend(watch_options, pm2_env.watch_options);\n    }\n\n    log('Watch opts', watch_options);\n\n    var watcher = chokidar.watch(watch, watch_options);\n\n    console.log('[Watch] Start watching', pm2_env.pm_id);\n\n    watcher.on('all', function(event, path) {\n      var self = this;\n\n      if (self.restarting === true) {\n        log('Already restarting, skipping');\n        return false;\n      }\n\n      self.restarting = true;\n\n      console.error('Change detected on path %s for app %s - restarting', path, pm2_env.name);\n\n      God.restartProcessName(pm2_env.name, function(err, list) {\n        self.restarting = false;\n\n        if (err) {\n          log('Error while restarting', err);\n          return false;\n        }\n\n        return log('Process restarted');\n      });\n\n      return false;\n    });\n\n    watcher.on('error', function(e) {\n      console.error(e.stack || e);\n    });\n\n    God.watch._watchers[pm2_env.name] = watcher;\n\n    //return God.watch._watchers[pm2_env.name];\n  },\n  /**\n   * Description\n   * @method close\n   * @param {} id\n   * @return\n   */\n  God.watch.disableAll = function() {\n    var watchers = God.watch._watchers;\n\n    console.log('[Watch] PM2 is being killed. Watch is disabled to avoid conflicts');\n    for (var i = 0; i < watchers.length; ++i) {\n      watchers[i].close && watchers[i].close();\n      watchers.splice(i, 1);\n    }\n  },\n\n  God.watch.disable = function(pm2_env) {\n    if (God.watch._watchers[pm2_env.name]) {\n      console.log('[Watch] Stop watching', pm2_env.pm_id);\n      God.watch._watchers[pm2_env.name].close();\n      delete God.watch._watchers[pm2_env.name];\n      return true;\n    } else {\n      return false;\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/Worker.js":"/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\nvar vizion = require('vizion');\nvar cst    = require('../constants.js');\nvar async  = require('async');\nvar debug  = require('debug')('pm2:worker');\nvar domain = require('domain');\n\nmodule.exports = function(God) {\n  var timer = null;\n\n  God.Worker = {};\n  God.Worker.is_running = false;\n\n  var _getProcessById = function(pm_id) {\n    var proc = God.clusters_db[pm_id];\n    return proc ? proc : null;\n  };\n\n  var maxMemoryRestart = function(proc_key, cb) {\n    var proc = _getProcessById(proc_key.pm2_env.pm_id);\n\n    if (!(proc &&\n          proc.pm2_env &&\n          proc_key.monit))\n      return cb();\n\n    if (proc_key.monit.memory !== undefined &&\n        proc.pm2_env.max_memory_restart !== undefined &&\n        proc.pm2_env.max_memory_restart < proc_key.monit.memory &&\n        proc.pm2_env.axm_options &&\n        proc.pm2_env.axm_options.pid === undefined) {\n      console.log('[PM2][WORKER] Process %s restarted because it exceeds --max-memory-restart value (current_memory=%s max_memory_limit=%s [octets])', proc.pm2_env.pm_id, proc_key.monit.memory, proc.pm2_env.max_memory_restart);\n      God.softReloadProcessId({\n        id : proc.pm2_env.pm_id\n      }, function(err, data) {\n        if (err)\n          console.error(err.stack || err);\n        return cb();\n      });\n    }\n    else {\n      return cb();\n    }\n  };\n\n  var versioningRefresh = function(proc_key, cb) {\n    var proc = _getProcessById(proc_key.pm2_env.pm_id);\n    if (!(proc &&\n          proc.pm2_env &&\n          (proc.pm2_env.vizion !== false && proc.pm2_env.vizion != \"false\") &&\n          proc.pm2_env.versioning &&\n          proc.pm2_env.versioning.repo_path)) {\n      return cb();\n    }\n\n    if (proc.pm2_env.vizion_running === true)\n    {\n      debug('Vizion is already running for proc id: %d, skipping this round', proc.pm2_env.pm_id);\n      return cb();\n    }\n\n    proc.pm2_env.vizion_running = true;\n    var repo_path = proc.pm2_env.versioning.repo_path;\n\n    vizion.analyze({\n      folder: proc.pm2_env.versioning.repo_path\n    },\n    function(err, meta) {\n      if (err != null)\n        return cb();\n\n      proc = _getProcessById(proc_key.pm2_env.pm_id);\n\n      if (!(proc &&\n            proc.pm2_env &&\n            proc.pm2_env.versioning &&\n            proc.pm2_env.versioning.repo_path)) {\n        console.error('Proc not defined anymore or versioning unknown');\n        return cb();\n      }\n\n      proc.pm2_env.vizion_running = false;\n      meta.repo_path = repo_path;\n      proc.pm2_env.versioning = meta;\n      debug('[PM2][WORKER] %s parsed for versioning', proc.pm2_env.name);\n      return cb();\n    });\n  };\n\n  var tasks = function() {\n    if (God.Worker.is_running === true) {\n      debug('[PM2][WORKER] Worker is already running, skipping this round');\n      return false;\n    }\n    God.Worker.is_running = true;\n\n    God.getMonitorData(null, function(err, data) {\n      if (err || !data || typeof(data) !== 'object') {\n        God.Worker.is_running = false;\n        return console.error(err);\n      }\n\n      async.eachLimit(data, 1, function(proc_key, next) {\n        if (!proc_key ||\n            !proc_key.pm2_env ||\n            proc_key.pm2_env.pm_id === undefined)\n          return next();\n\n        debug('[PM2][WORKER] Processing proc id:', proc_key.pm2_env.pm_id);\n\n        versioningRefresh(proc_key, function() {\n          maxMemoryRestart(proc_key, function() {\n            return next();\n          });\n        });\n      }, function(err) {\n        God.Worker.is_running = false;\n        debug('[PM2][WORKER] My job here is done, next job in %d seconds', parseInt(cst.WORKER_INTERVAL / 1000));\n      });\n    });\n  };\n\n  var wrappedTasks = function() {\n    var d = domain.create();\n\n    d.once('error', function(err) {\n      console.error('[PM2][WORKER] Error caught by domain:\\n' + (err.stack || err));\n      God.Worker.is_running = false;\n    });\n\n    d.run(function() {\n      tasks();\n    });\n  };\n\n\n  God.Worker.start = function() {\n    timer = setInterval(wrappedTasks, cst.WORKER_INTERVAL);\n  };\n\n  God.Worker.stop = function() {\n    if (timer !== null)\n      clearInterval(timer);\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/DevCli.js":"\n'use strict';\n\nprocess.env.PM2_NO_INTERACTION = 'true';\n\nvar commander = require('commander');\n\nvar debug     = require('debug')('pm2:cli');\nvar PM2       = require('..');\nvar Log       = require('./API/Log');\nvar cst       = require('../constants.js');\nvar pkg       = require('../package.json');\nvar platform  = require('os').platform();\nvar moment    = require('moment');\nvar Common    = require('./Common');\nvar chalk     = require('chalk');\nvar path      = require('path');\nvar fmt       = require('./tools/fmt.js');\nvar exec      = require('child_process').exec;\nvar os        = require('os');\n\ncommander.version(pkg.version)\n  .usage('[cmd] app');\n\nvar pm2 = new PM2.custom({\n  pm2_home : path.join(os.homedir ? os.homedir() : (process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE), '.pm2-dev')\n});\n\npm2.connect(function() {\n  commander.parse(process.argv);\n});\n\nfunction postExecCmd(command, cb) {\n  var exec_cmd = exec(command);\n\n  if (commander.silentExec !== true) {\n    exec_cmd.stdout.on('data', function(data) {\n      process.stdout.write(data);\n    });\n\n    exec_cmd.stderr.on('data', function(data) {\n      process.stderr.write(data);\n    });\n  }\n\n  exec_cmd.on('close', function done() {\n    if (cb) cb(null);\n  });\n\n  exec_cmd.on('error', function (err) {\n    console.error(err.stack || err);\n  });\n};\n\nfunction run(cmd, opts) {\n  var timestamp = opts.timestamp;\n\n  opts.watch = true;\n  opts.autorestart = true;\n\n  if (opts.autoExit)\n    autoExit();\n\n  if (opts.ignore) {\n    opts.ignore_watch = opts.ignore.split(',')\n    opts.ignore_watch.push('node_modules');\n  }\n\n  if (timestamp === true)\n    timestamp = 'YYYY-MM-DD-HH:mm:ss';\n\n  pm2.start(cmd, opts, function(err, procs) {\n\n    if (err) {\n      console.error(err);\n      pm2.destroy(function() {\n        process.exit(0);\n      });\n      return false;\n    }\n\n    if (opts.testMode) {\n      return pm2.disconnect(function() {\n      });\n    }\n\n    fmt.sep();\n    fmt.title('PM2 development mode');\n    fmt.field('Apps started', procs.map(function(p) { return p.pm2_env.name } ));\n    fmt.field('Processes started', chalk.bold(procs.length));\n    fmt.field('Watch and Restart', chalk.green('Enabled'));\n    fmt.field('Ignored folder', opts.ignore_watch || 'node_modules');\n    if (opts.postExec)\n      fmt.field('Post restart cmd', opts.postExec);\n    fmt.sep();\n\n    setTimeout(function() {\n      pm2.Client.launchBus(function(err, bus) {\n        bus.on('process:event', function(packet) {\n          if (packet.event == 'online') {\n            if (opts.postExec)\n              postExecCmd(opts.postExec);\n          }\n        });\n      });\n    }, 1000);\n\n    Log.devStream(pm2.Client, 'all', opts.raw, timestamp, false);\n\n    process.on('SIGINT', function() {\n      console.log('>>>>> [PM2 DEV] Stopping current development session');\n      pm2.delete('all', function() {\n        pm2.destroy(function() {\n          process.exit(0);\n        });\n      });\n    });\n\n  });\n}\n\n\ncommander.command('*')\n  .action(function(cmd, opts){\n    run(cmd, opts);\n  });\n\ncommander.command('start <file|json_file>')\n  .option('--raw', 'raw log output')\n  .option('--timestamp', 'print timestamp')\n  .option('--ignore [files]', 'files to ignore while watching')\n  .option('--post-exec [cmd]', 'execute extra command after change detected')\n  .option('--silent-exec', 'do not output result of post command', false)\n  .option('--test-mode', 'debug mode for test suit')\n  .option('--env [name]', 'select env_[name] env variables in process config file')\n  .option('--auto-exit', 'exit if all processes are errored/stopped or 0 apps launched')\n  .description('start target config file/script in development mode')\n  .action(function(cmd, opts) {\n    run(cmd, opts);\n  });\n\nfunction exitPM2() {\n  if (pm2 && pm2.connected == true) {\n    console.log(chalk.green.bold('>>> Exiting PM2'));\n    pm2.kill(function() {\n      process.exit(0);\n    });\n  }\n  else\n    process.exit(0);\n}\n\nfunction autoExit(final) {\n  setTimeout(function() {\n    pm2.list(function(err, apps) {\n      if (err) console.error(err.stack || err);\n\n      var online_count = 0;\n\n      apps.forEach(function(app) {\n        if (app.pm2_env.status == cst.ONLINE_STATUS ||\n            app.pm2_env.status == cst.LAUNCHING_STATUS)\n          online_count++;\n      });\n\n      if (online_count == 0) {\n        console.log('0 application online, exiting');\n        if (final == true)\n          process.exit(1);\n        else\n          autoExit(true);\n        return false;\n      }\n      autoExit(false);\n    });\n  }, 3000);\n}\n\nif (process.argv.length == 2) {\n  commander.outputHelp();\n  exitPM2();\n}\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/HttpInterface.js":"/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\nvar http   = require('http');\nvar os     = require('os');\nvar pm2    = require('../index.js');\nvar urlT   = require('url');\nvar cst    = require('../constants.js');\n\n// Default, attach to default local PM2\n\npm2.connect(function() {\n  startWebServer(pm2);\n});\n\nfunction startWebServer(pm2) {\n  http.createServer(function (req, res) {\n    // Add CORS headers to allow browsers to fetch data directly\n    res.setHeader('Access-Control-Allow-Origin', '*');\n    res.setHeader('Access-Control-Allow-Headers', 'Cache-Control, Pragma, Origin, Authorization, Content-Type, X-Requested-With');\n    res.setHeader('Access-Control-Allow-Methods', 'GET');\n\n    // We always send json\n    res.setHeader('Content-Type','application/json');\n\n    var path = urlT.parse(req.url).pathname;\n\n    if (path == '/') {\n      // Main monit route\n      pm2.list(function(err, list) {\n        if (err) {\n          return res.send(err);\n        }\n        var data = {\n          system_info: { hostname: os.hostname(),\n                         uptime: os.uptime()\n                       },\n          monit: { loadavg: os.loadavg(),\n                   total_mem: os.totalmem(),\n                   free_mem: os.freemem(),\n                   cpu: os.cpus(),\n                   interfaces: os.networkInterfaces()\n                 },\n          processes: list\n        };\n\n        res.statusCode = 200;\n        res.write(JSON.stringify(data));\n        return res.end();\n\n      })\n    }\n    else {\n      // 404\n      res.statusCode = 404;\n      res.write(JSON.stringify({err : '404'}));\n      return res.end();\n    }\n  }).listen(process.env.PM2_WEB_PORT || cst.WEB_PORT, cst.WEB_IPADDR, function() {\n    console.log('Web interface listening on  %s:%s', cst.WEB_IPADDR, cst.WEB_PORT);\n  });\n\n}\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/ProcessContainer.js":"/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\n// ProcessContainer.js\n// Child wrapper. Redirect output to files, assign pid & co.\n// by Strzelewicz Alexandre\n\n\nvar p       = require('path');\nvar cst     = require('../constants');\nvar Utility = require('./Utility.js');\n\n// Load all env-vars from master.\nvar pm2_env = JSON.parse(process.env.pm2_env);\nfor(var k in pm2_env){\n  process.env[k] = pm2_env[k];\n}\n\n// Rename process\nprocess.title = process.env.PROCESS_TITLE || 'node ' + pm2_env.pm_exec_path;\n\ndelete process.env.pm2_env;\n\n/**\n * Main entrance to wrap the desired code\n */\n(function ProcessContainer() {\n  var fs          = require('fs');\n\n  if (process.env.pmx !== \"false\")\n    require('pmx').init({\n      transactions: process.env.km_link == 'true' && process.env.trace == 'true' || false,\n      http: process.env.km_link == 'true' || false\n    });\n\n  var stdFile     = pm2_env.pm_log_path;\n  var outFile     = pm2_env.pm_out_log_path;\n  var errFile     = pm2_env.pm_err_log_path;\n  var pmId        = pm2_env.pm_id;\n  var pidFile     = pm2_env.pm_pid_path;\n  var script      = pm2_env.pm_exec_path;\n  var cronRestart = pm2_env.cron_restart;\n\n  var original_send = process.send;\n\n  if (typeof(process.env.source_map_support) != \"undefined\" &&\n      process.env.source_map_support !== \"false\") {\n    require('source-map-support').install();\n  }\n\n  process.send = function() {\n    if (process.connected) original_send.apply(this, arguments);\n  };\n\n  //send node version\n  if (process.versions && process.versions.node) {\n    process.send({\n      'node_version': process.versions.node\n    });\n  }\n\n  if (cst.MODIFY_REQUIRE)\n    require.main.filename = pm2_env.pm_exec_path;\n\n  // Resets global paths for require()\n  require('module')._initPaths();\n\n  try {\n    fs.writeFileSync(pidFile, process.pid);\n  } catch (e) {\n    console.error(e.stack || e);\n  }\n\n  // Add args to process if args specified on start\n  if (process.env.args != null)\n    process.argv = process.argv.concat(pm2_env.args);\n\n  // stdio, including: out, err and entire (both out and err if necessary).\n  var stds = {\n    out: outFile,\n    err: errFile\n  };\n  stdFile && (stds.std = stdFile);\n  exec(script, stds);\n\n  if (cronRestart)\n    cronize(cronRestart);\n})();\n\n/**\n * Cron restart\n */\nfunction cronize(cron_pattern) {\n  var cronJob = require('cron').CronJob;\n  var job = new cronJob({\n    cronTime: cron_pattern,\n    onTick: function() {\n      if (process.connected && process.send){\n        process.send({\n          'cron_restart': 1\n        });\n      } else {\n        process.emit('disconnect');\n        process.nextTick(function() {\n          process.exit(0);\n        });\n      }\n    },\n    start: false\n  });\n  job.start();\n}\n\n/**\n * Description\n * @method exec\n * @param {} script\n * @param {} stds\n * @return\n */\nfunction exec(script, stds) {\n  if (p.extname(script) == '.coffee') {\n    try {\n      require('coffee-script/register');\n    } catch (e) {\n      console.error('Failed to load CoffeeScript interpreter:', e.stack || e);\n    }\n  }\n\n  if (p.extname(script) == '.ls') {\n    try {\n      require('livescript');\n    } catch (e) {\n      console.error('Failed to load LiveScript interpreter:', e.stack || e);\n    }\n  }\n\n  if (p.extname(script) == '.ts') {\n    try {\n      require('ts-node/register');\n    } catch (e) {\n      console.error('Failed to load Typescript interpreter:', e.stack || e);\n    }\n  }\n\n  process.on('message', function (msg) {\n    if (msg.type === 'log:reload') {\n      for(var k in stds){\n        if(typeof stds[k] == 'object' && !isNaN(stds[k].fd)){\n          if (stds[k].destroy) stds[k].destroy();\n          else if (stds[k].end) stds[k].end();\n          else if (stds[k].close) stds[k].close();\n          stds[k] = stds[k]._file;\n        }\n      }\n      Utility.startLogging(stds, function (err) {\n        if(err){\n          console.error('Failed to reload logs:', err.stack);\n        }else {\n          console.log('Reloading log...');\n        }\n      });\n    }\n  });\n\n  var moment = null;\n\n  if (pm2_env.log_date_format)\n    moment = require('moment');\n\n  Utility.startLogging(stds, function (err) {\n    if (err) {\n      process.send({\n        type    : 'process:exception',\n        data    : {\n          message: err.message,\n          syscall: 'ProcessContainer.startLogging'\n        }\n      });\n      throw err;\n      return;\n    }\n    process.stderr.write = (function(write) {\n      return function(string, encoding, cb) {\n        var log_data = null;\n\n        if (pm2_env.log_type && pm2_env.log_type === 'json') {\n          log_data = JSON.stringify({\n            message : string.toString(),\n            timestamp : pm2_env.log_date_format && moment ?\n                          moment().format(pm2_env.log_date_format) : new Date().toISOString(),\n            type : 'err',\n            process_id : pm2_env.pm_id,\n            app_name : pm2_env.name\n          }) + '\\n';\n        }\n        else if (pm2_env.log_date_format && moment)\n          log_data = moment().format(pm2_env.log_date_format) + ': ' + string.toString();\n        else\n          log_data = string.toString();\n\n        stds.std && stds.std.write && stds.std.write(log_data);\n\n        // hardcoded values of special log path to not write on disk\n        if (pm2_env.pm_err_log_path !== 'NULL' && pm2_env.pm_err_log_path !== '/dev/null') {\n          stds.err.write && stds.err.write(log_data, encoding, cb);\n        };\n\n        process.send({\n          type : 'log:err',\n          data : log_data\n        });\n      };\n    }\n    )(process.stderr.write);\n\n    process.stdout.write = (function(write) {\n      return function(string, encoding, cb) {\n        var log_data = null;\n\n        if (pm2_env.log_type && pm2_env.log_type === 'json') {\n          log_data = JSON.stringify({\n            message : string.toString(),\n            timestamp : pm2_env.log_date_format && moment ?\n                          moment().format(pm2_env.log_date_format) : new Date().toISOString(),\n            type : 'out',\n            process_id : pm2_env.pm_id,\n            app_name : pm2_env.name\n          }) + '\\n';\n        }\n        else if (pm2_env.log_date_format && moment)\n          log_data = moment().format(pm2_env.log_date_format) + ': ' + string.toString();\n        else\n          log_data = string.toString();\n\n        stds.std && stds.std.write && stds.std.write(log_data);\n\n        // hardcoded values of special log path to not write on disk\n        if (pm2_env.pm_out_log_path !== 'NULL' && pm2_env.pm_out_log_path !== '/dev/null') {\n          stds.out.write && stds.out.write(log_data);\n        }\n\n        process.send({\n          type : 'log:out',\n          data : log_data\n        });\n      };\n    })(process.stdout.write);\n\n    function getUncaughtExceptionListener(listener) {\n      return function uncaughtListener(err) {\n        var error = err && err.stack ? err.stack : err;\n\n        if (listener === 'unhandledRejection') {\n          error = 'You have triggered an unhandledRejection, you may have forgotten to catch a Promise rejection:\\n' + error;\n        }\n\n        logError(['std', 'err'], error);\n\n        // Notify master that an uncaughtException has been catched\n        try {\n          if (err) {\n            var errObj = {};\n\n            Object.getOwnPropertyNames(err).forEach(function(key) {\n              errObj[key] = err[key];\n            });\n          }\n\n          process.send({\n            type : 'log:err',\n            data : '\\n' + error + '\\n'\n          });\n          process.send({\n            type    : 'process:exception',\n            data    : errObj !== undefined ? errObj : {message: 'No error but ' + listener + ' was caught!'}\n          });\n        } catch(e) {\n          logError(['std', 'err'], 'Channel is already closed can\\'t broadcast error:\\n' + e.stack);\n        }\n\n        if (!process.listeners(listener).filter(function (listener) {\n            return listener !== uncaughtListener;\n        }).length) {\n          if (listener == 'uncaughtException') {\n            process.emit('disconnect');\n            process.exit(cst.CODE_UNCAUGHTEXCEPTION);\n          }\n        }\n      }\n    }\n\n    process.on('uncaughtException', getUncaughtExceptionListener('uncaughtException'));\n    process.on('unhandledRejection', getUncaughtExceptionListener('unhandledRejection'));\n\n    // Change dir to fix process.cwd\n    process.chdir(pm2_env.pm_cwd || process.env.PWD || p.dirname(script));\n\n    require('module')._load(script, null, true);\n\n    function logError(types, error){\n      try {\n        types.forEach(function(type){\n          stds[type] && typeof stds[type].write == 'function' && stds[type].write(error + '\\n');\n        });\n      } catch(e) { }\n    }\n  });\n\n}\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/ProcessContainerFork.js":"/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\n// Inject custom modules\nif (process.env.pmx !== \"false\") {\n  require('pmx').init({\n    transactions: process.env.km_link == 'true' && process.env.trace == 'true' || false,\n    http: process.env.km_link == 'true' || false\n  });\n}\n\nif (typeof(process.env.source_map_support) != \"undefined\" &&\n    process.env.source_map_support !== \"false\") {\n  require('source-map-support').install();\n}\n\n// Cron restart feature\nif (process.env.cron_restart) {\n  var cron_pattern = process.env.cron_restart;\n  var cronJob = require('cron').CronJob;\n  var job = new cronJob({\n    cronTime: cron_pattern,\n    onTick: function () {\n      if (process.connected && process.send) {\n        process.send({\n          'cron_restart': 1\n        });\n      } else {\n        process.exit(0);\n      }\n    },\n    start: false\n  });\n  job.start();\n}\n\n\n// Rename the process\nprocess.title = process.env.PROCESS_TITLE || 'node ' + process.env.pm_exec_path;\n\nif (process.connected &&\n    process.send &&\n    process.versions &&\n    process.versions.node)\n  process.send({\n    'node_version': process.versions.node\n  });\n\n// Require the real application\nif (process.env.pm_exec_path)\n  require('module')._load(process.env.pm_exec_path, null, true);\nelse\n  throw new Error('Could not _load() the script');\n\n// Change some values to make node think that the user's application\n// was started directly such as `node app.js`\nprocess.mainModule.loaded = false;\nrequire.main = process.mainModule;\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/Satan.js":"\n////////////////////////////////////////////////////////////////////////\n// /!\\                                                                //\n// THIS FILE IS NOT USED ANYMORE IT IS ONLY HERE FOR BACKWARD SUPPORT //\n// WHILE UPGRADING OLDER PM2 (< 2.0)                                  //\n//                                                                    //\n// THIS FILE HAS BEEN NOW SPLITTED INTO TWO DISTINCT FILES            //\n//                                                                    //\n// NAMED                                                              //\n//                                                                    //\n// CLIENT.JS FOR THE CLIENT SIDE                                      //\n// AND                                                                //\n// DAEMON.JS FOR THE DAEMON (SERVER SIDE)                             //\n// /!\\                                                                //\n////////////////////////////////////////////////////////////////////////\n\nvar cst         = require('../constants.js');\nvar rpc         = require('pm2-axon-rpc');\nvar axon        = require('pm2-axon');\nvar debug       = require('debug')('pm2:satan');\nvar util        = require('util');\nvar fs          = require('fs');\nvar p           = require('path');\nvar Utility     = require('./Utility.js');\nvar domain      = require('domain');\nvar async       = require('async');\n\n/**\n * Export\n */\nvar Satan = module.exports = {};\n\n/**\n * This function ensures that daemon is running and start it if it doesn't\n * Then connect to PM2 via RPC\n * @api public\n * @method start\n * @param {Boolean} noDaemonMode option to not fork PM2 and run it in the same process\n * @callback cb\n */\nSatan.start = function(noDaemonMode, cb) {\n  if (typeof(noDaemonMode)  == \"function\") {\n    cb = noDaemonMode;\n    noDaemonMode = false;\n  }\n\n  Satan._noDaemonMode = noDaemonMode;\n\n  Satan.pingDaemon(function(ab) {\n    // If Daemon not alive\n    if (ab == false) {\n      if (noDaemonMode) {\n        debug('Launching in no daemon mode');\n        Satan.remoteWrapper();\n        return Satan.launchRPC(function() {\n          require('./Modularizer.js').launchAll(cb);\n        });\n      }\n\n      Satan.printOut(cst.PREFIX_MSG + 'Spawning PM2 daemon');\n\n      // Daemonize PM2\n      return Satan.launchDaemon(function(err, child) {\n        if (err) {\n          console.error(err);\n          return cb ? cb(err) : process.exit(cst.ERROR_EXIT);\n        }\n        Satan.printOut(cst.PREFIX_MSG + 'PM2 Successfully daemonized');\n        // Launch RPC\n        return Satan.launchRPC(function() {\n          require('./Modularizer.js').launchAll(cb);\n        });\n      });\n    }\n    // Else just start the PM2 client side (RPC)\n    return Satan.launchRPC(cb);\n  });\n};\n\n/**\n * Daemon part\n * @method processStateHandler\n * @param {} God\n * @return\n */\nSatan.processStateHandler = function(God) {\n  /**\n   * Description\n   * @method gracefullExit\n   * @return\n   */\n  function gracefullExit() {\n    Satan.printOut('pm2 has been killed by signal, dumping process list before exit...');\n\n    God.dumpProcessList(function() {\n\n      var processes = God.getFormatedProcesses();\n\n      async.eachLimit(processes, cst.CONCURRENT_ACTIONS, function(proc, next) {\n        console.log('Deleting process %s', proc.pm2_env.pm_id);\n        God.deleteProcessId(proc.pm2_env.pm_id, function() {\n          return next();\n        });\n        return false;\n      }, function(err) {\n        try {\n          fs.unlinkSync(cst.PM2_PID_FILE_PATH);\n        } catch(e) {}\n        Satan.printOut('[PM2] Exited peacefully');\n        process.exit(cst.SUCCESS_EXIT);\n      });\n    });\n  }\n\n  try {\n    fs.writeFileSync(cst.PM2_PID_FILE_PATH, process.pid);\n  } catch (e) {\n    console.error(e.stack || e);\n  }\n\n  process.on('SIGILL', function() {\n    global.gc();\n    Satan.printOut('Running garbage collector');\n  });\n\n  process.on('SIGTERM', gracefullExit);\n  process.on('SIGINT', gracefullExit);\n  process.on('SIGQUIT', gracefullExit);\n  process.on('SIGUSR2', function() {\n    God.reloadLogs({}, function() {});\n  });\n};\n\n/**\n * This function wrap God.js\n * @method remoteWrapper\n * @return\n */\nSatan.remoteWrapper = function() {\n  // Only require here because God init himself\n  var God = require('./God');\n  var self = this;\n\n  var pkg    = require('../package.json');\n  var rpc_socket_ready = false;\n  var pub_socket_ready = false;\n\n  Satan.processStateHandler(God);\n\n  function sendReady() {\n    // Send ready message to Satan Client\n    if (rpc_socket_ready == true && pub_socket_ready == true) {\n      if (typeof(process.send) === 'function') {\n        process.send({\n          online      : true,\n          success     : true,\n          pid         : process.pid,\n          pm2_version : pkg.version\n        });\n      }\n    };\n  }\n\n  /**\n   * External interaction part\n   */\n\n  /**\n   * Pub system for real time notifications\n   */\n  var pub    = axon.socket('pub-emitter');\n\n  this.pub_socket = pub.bind(cst.DAEMON_PUB_PORT);\n\n  this.pub_socket.once('bind', function() {\n    Satan.printOut('BUS system [READY] on port %s', cst.DAEMON_PUB_PORT);\n    pub_socket_ready = true;\n    sendReady();\n  });\n\n  /**\n   * Rep/Req - RPC system to interact with God\n   */\n  var rep    = axon.socket('rep');\n\n  var server = new rpc.Server(rep);\n\n  Satan.printOut('[[[[ PM2/God daemon launched ]]]]');\n\n  this.rpc_socket = rep.bind(cst.DAEMON_RPC_PORT);\n\n  this.rpc_socket.once('bind', function() {\n    Satan.printOut('RPC interface [READY] on port %s', cst.DAEMON_RPC_PORT);\n    rpc_socket_ready = true;\n    sendReady();\n  });\n\n  server.expose({\n    prepare                 : God.prepare,\n    getMonitorData          : God.getMonitorData,\n    getSystemData           : God.getSystemData,\n\n    startProcessId          : God.startProcessId,\n    stopProcessId           : God.stopProcessId,\n    restartProcessId        : God.restartProcessId,\n    deleteProcessId         : God.deleteProcessId,\n\n    softReloadProcessId     : God.softReloadProcessId,\n    reloadProcessId         : God.reloadProcessId,\n    duplicateProcessId      : God.duplicateProcessId,\n    resetMetaProcessId      : God.resetMetaProcessId,\n    stopWatch               : God.stopWatch,\n    restartWatch            : God.restartWatch,\n    notifyByProcessId       : God.notifyByProcessId,\n\n    killMe                  : God.killMe,\n    notifyKillPM2           : God.notifyKillPM2,\n    forceGc                 : God.forceGc,\n\n    findByFullPath          : God.findByFullPath,\n\n    msgProcess              : God.msgProcess,\n    sendDataToProcessId     : God.sendDataToProcessId,\n    sendSignalToProcessId   : God.sendSignalToProcessId,\n    sendSignalToProcessName : God.sendSignalToProcessName,\n\n    ping                    : God.ping,\n    getVersion              : God.getVersion,\n    reloadLogs              : God.reloadLogs\n  });\n\n  /**\n   * Action treatment specifics\n   * Attach actions to pm2_env.axm_actions variables (name + options)\n   */\n  God.bus.on('axm:action', function axmActions(msg) {\n    var pm2_env = msg.process;\n    var exists  = false;\n    var axm_action = msg.data;\n\n    if (!pm2_env || !God.clusters_db[pm2_env.pm_id])\n      return console.error('Unknown id %s', pm2_env.pm_id);\n\n    if (!God.clusters_db[pm2_env.pm_id].pm2_env.axm_actions)\n      God.clusters_db[pm2_env.pm_id].pm2_env.axm_actions = [];\n\n    God.clusters_db[pm2_env.pm_id].pm2_env.axm_actions.forEach(function(actions) {\n      if (actions.action_name == axm_action.action_name)\n        exists = true;\n    });\n\n    if (exists === false) {\n      debug('Adding action', axm_action);\n      God.clusters_db[pm2_env.pm_id].pm2_env.axm_actions.push(axm_action);\n    }\n\n    return God;\n  });\n\n  /**\n   * Configure module\n   */\n  God.bus.on('axm:option:configuration', function axmMonitor(msg) {\n    if (!msg.process)\n      return console.error('[axm:option:configuration] no process defined');\n\n    if (!God.clusters_db[msg.process.pm_id])\n      return console.error('[axm:option:configuration] Unknown id %s', msg.process.pm_id);\n\n    try {\n      // Application Name nverride\n      if (msg.data.name)\n        God.clusters_db[msg.process.pm_id].pm2_env.name = msg.data.name;\n\n      Object.keys(msg.data).forEach(function(conf_key) {\n        God.clusters_db[msg.process.pm_id].pm2_env.axm_options[conf_key] = Utility.clone(msg.data[conf_key]);\n      });\n    } catch(e) {\n      console.error(e.stack || e);\n    }\n    msg = null;\n  });\n\n  /**\n   * Process monitoring data (probes)\n   */\n  God.bus.on('axm:monitor', function axmMonitor(msg) {\n    if (!msg.process)\n      return console.error('[axm:monitor] no process defined');\n\n    if (!msg.process || !God.clusters_db[msg.process.pm_id])\n      return console.error('Unknown id %s', msg.process.pm_id);\n\n    util._extend(God.clusters_db[msg.process.pm_id].pm2_env.axm_monitor, Utility.clone(msg.data));\n    msg = null;\n  });\n\n  /**\n   * Broadcast messages\n   */\n  God.bus.onAny(function(data_v) {\n    if (['axm:action',\n         'axm:monitor',\n         'axm:option:setPID',\n         'axm:option:configuration'].indexOf(this.event) > -1) {\n      data_v = null;\n      return false;\n    }\n    pub.emit(this.event, Utility.clone(data_v));\n    data_v = null;\n  });\n};\n\n/**\n *\n * Client part\n *\n */\n\n/**\n * Launch the Daemon by forking this same file\n * The method Satan.remoteWrapper will be called\n * @api public\n * @method launchDaemon\n * @param {} cb\n * @return\n */\nSatan.launchDaemon = function launchDaemon(cb) {\n  debug('Launching daemon');\n\n  var SatanJS = p.resolve(p.dirname(module.filename), 'Satan.js');\n  var InteractorDaemonizer = require('./Interactor/InteractorDaemonizer.js');\n\n  var node_args = [];\n\n  var out, err;\n\n  if (process.env.TRAVIS) {\n    // Redirect PM2 internal err and out to STDERR STDOUT when running with Travis\n    out = 1;\n    err = 2;\n  }\n  else {\n    out = fs.openSync(cst.PM2_LOG_FILE_PATH, 'a'),\n    err = fs.openSync(cst.PM2_LOG_FILE_PATH, 'a');\n  }\n\n  // Node.js tuning for better performance\n  //node_args.push('--expose-gc'); // Allows manual GC in the code\n  //node_args.push('--gc-global'); // Does full GC (smaller memory footprint)\n\n  /**\n   * Add node [arguments] depending on PM2_NODE_OPTIONS env variable\n   */\n  if (process.env.PM2_NODE_OPTIONS)\n    node_args = node_args.concat(process.env.PM2_NODE_OPTIONS.split(' '));\n  node_args.push(SatanJS);\n\n  var resolved_home = process.env.PM2_HOME || process.env.HOME || process.env.HOMEPATH;\n\n  debug(\"PM2 home path: %s\", resolved_home);\n  debug(\"Node.js engine full path: %s\", process.execPath);\n  debug(\"Node.js with V8 arguments: %s\", node_args);\n\n  var child = require('child_process').spawn(process.execPath || 'node', node_args, {\n    detached   : true,\n    cwd        : process.cwd(),\n    env        : util._extend({\n      'SILENT' : cst.DEBUG ? !cst.DEBUG : true,\n      'HOME'   : resolved_home\n    }, process.env),\n    stdio      : ['ipc', out, err]\n  });\n\n  function onError(e) {\n    console.error(e.stack || e);\n    return cb ? cb(e.stack || e) : false;\n  }\n\n  child.once('error', onError);\n\n  child.unref();\n\n  child.once('message', function(msg) {\n    debug('PM2 daemon launched with return message: ', msg);\n    child.removeListener('error', onError);\n    child.disconnect();\n    InteractorDaemonizer.launchAndInteract({}, function(err, data) {\n      if (data)\n        debug('Interactor launched');\n      return cb ? cb(null, child) : false;\n    });\n  });\n};\n\n/**\n * Ping the daemon to know if it alive or not\n * @api public\n * @method pingDaemon\n * @param {} cb\n * @return\n */\nSatan.pingDaemon = function pingDaemon(cb) {\n  var req    = axon.socket('req');\n  var client = new rpc.Client(req);\n\n  debug('[PING PM2] Trying to connect to server');\n\n  client.sock.once('reconnect attempt', function() {\n    client.sock.close();\n    debug('Daemon not launched');\n    process.nextTick(function() {\n      return cb(false);\n    });\n  });\n\n  client.sock.once('connect', function() {\n    client.sock.once('close', function() {\n      return cb(true);\n    });\n    client.sock.close();\n    debug('Daemon alive');\n  });\n\n  req.connect(cst.DAEMON_RPC_PORT);\n};\n\n/**\n * Methods to interact with the Daemon via RPC\n * This method wait to be connected to the Daemon\n * Once he's connected it trigger the command parsing (on ./bin/pm2 file, at the end)\n * @method launchRPC\n * @return\n */\nSatan.launchRPC = function launchRPC(cb) {\n  debug('Launching RPC client on socket file %s', cst.DAEMON_RPC_PORT);\n  var req      = axon.socket('req');\n  Satan.client = new rpc.Client(req);\n\n  Satan.client.sock.once('connect', function() {\n    debug('Connected to Daemon');\n    process.emit('satan:client:ready');\n    setTimeout(function() {\n      return cb ? cb(null) : false;\n    }, 4);\n  });\n\n  this.client_sock = req.connect(cst.DAEMON_RPC_PORT);\n};\n\nSatan.launchBus = function launchEventSystem(cb) {\n  var self = this;\n  this.sub = axon.socket('sub-emitter');\n  this.sub_sock = this.sub.connect(cst.DAEMON_PUB_PORT);\n\n  this.sub_sock.once('connect', function() {\n    return cb(null, self.sub);\n  });\n};\n\nSatan.disconnectBus = function disconnectBus(cb) {\n  this.sub_sock.once('close', function() {\n    return cb ? cb() : false;\n  });\n  this.sub_sock.close();\n};\n\n/**\n * Methods to close the RPC connection\n * @callback cb\n */\nSatan.disconnectRPC = function disconnectRPC(cb) {\n  debug('Disconnecting PM2 RPC');\n\n  if (!Satan.client_sock || !Satan.client_sock.close) {\n    return cb({\n      success : false,\n      msg : 'RPC connection to PM2 is not launched'\n    });\n  }\n\n  if (Satan.client_sock.connected == false ||\n      Satan.client_sock.closing == true) {\n    return cb({\n      success : false,\n      msg : 'RPC closed'\n    });\n  }\n\n  try {\n    var timer;\n\n    Satan.client_sock.once('close', function() {\n      clearTimeout(timer);\n      debug('PM2 RPC cleanly closed');\n      return cb ? cb(null, {success:true}) : false;\n    });\n\n    timer = setTimeout(function() {\n      if (Satan.client_sock.destroy)\n        Satan.client_sock.destroy();\n      return cb ? cb(null, {success:true}) : false;\n    }, 200);\n\n    Satan.client_sock.close();\n  } catch(e) {\n    debug('Error while disconnecting RPC PM2', e.stack || e);\n    return cb ? cb(e.stack || e) : false;\n  };\n  return false;\n};\n\n/**\n * Description\n * @method getExposedMethods\n * @param {} cb\n * @return\n */\nSatan.getExposedMethods = function getExposedMethods(cb) {\n  Satan.client.methods(cb);\n};\n\nSatan.printOut = function() {\n  if (process.env.PM2_SILENT || process.env.PM2_PROGRAMMATIC === 'true') return false;\n  return console.log.apply(console, arguments);\n};\n\n/**\n * Description\n * @method executeRemote\n * @param {} method\n * @param {} env\n * @param {} fn\n * @return\n */\nSatan.executeRemote = function executeRemote(method, env, fn) {\n  var env_watch = false;\n\n  if (env.env && env.env.watch)\n    env_watch = env.env.watch;\n\n  env_watch = util.isArray(env_watch) && env_watch.length === 0 ? !!~process.argv.indexOf('--watch') : env_watch;\n\n  //stop watching when process is deleted\n  if (method.indexOf('delete') !== -1) {\n    Satan.stopWatch(method, env);\n  //stop everything on kill\n  } else if(method.indexOf('kill') !== -1) {\n    Satan.stopWatch('deleteAll', env);\n  //stop watch on stop (stop doesn't accept env, yet)\n  } else if (~process.argv.indexOf('--watch') && method.indexOf('stop') !== -1) {\n    Satan.stopWatch(method, env);\n  //restart watch\n  } else if (env_watch && method.indexOf('restart') !== -1) {\n    Satan.restartWatch(method, env);\n  }\n\n  if (!Satan.client || !Satan.client.call) {\n    if (fn) return fn(new Error('Could not connect to local pm2, have you called pm2.connect(function()})'));\n    console.error('Did you forgot to call pm2.connect(function() { }) before interacting with PM2 ?');\n    return process.exit(0);\n  }\n\n  debug('Calling daemon method pm2:%s', method);\n  return Satan.client.call(method, env, fn);\n};\n\nSatan.notifyGod = function(action_name, id, cb) {\n  Satan.executeRemote('notifyByProcessId', {\n    id : id,\n    action_name : action_name,\n    manually : true\n  }, function() {\n    debug('God notified');\n    return cb ? cb() : false;\n  });\n};\n/**\n * Description\n * @method killDaemon\n * @param {} fn\n * @return\n */\nSatan.killDaemon = function killDaemon(fn) {\n  var timeout;\n\n  function quit() {\n    Satan.disconnectRPC(function() {\n      debug('RPC disconnected');\n      return fn ? fn(null, {success:true}) : false;\n    });\n  }\n\n  process.once('SIGQUIT', function() {\n    debug('Received SIGQUIT');\n    clearTimeout(timeout);\n    quit();\n  });\n\n  timeout = setTimeout(function() {\n    quit();\n  }, 3000);\n\n  // Kill daemon\n  Satan.executeRemote('killMe', {pid : process.pid}, function() {});\n};\n\n/**\n * Description\n * @method restartWatch\n * @param {} method\n * @param {} env\n * @param {} fn\n * @return\n */\nSatan.restartWatch = function restartWatch(method, env, fn) {\n  debug('Calling restartWatch');\n  Satan.client.call('restartWatch', method, env, function() {\n    debug('Restart watching');\n    return fn ? fn() : false;\n  });\n};\n\n/**\n * Description\n * @method stopWatch\n * @param {} method\n * @param {} env\n * @param {} fn\n * @return\n */\nSatan.stopWatch = function stopWatch(method, env, fn) {\n  debug('Calling stopWatch');\n  Satan.client.call('stopWatch', method, env, function() {\n    debug('Stop watching');\n    return fn ? fn() : false;\n  });\n};\n\n/**\n * If this file is a main process, it means that\n * this process is being forked by pm2 itself\n */\nif (require.main === module) {\n\n  var pkg = require('../package.json');\n\n  process.title = 'PM2 v' + pkg.version + ': God Daemon';\n\n  if (process.env.NODE_ENV == 'test') {\n    Satan.remoteWrapper();\n  }\n  else {\n    var d = domain.create();\n\n    d.once('error', function(err) {\n      console.error('[PM2] Error caught by domain:\\n' + (err.stack || err));\n      console.error('[PM2] Trying to update PM2...');\n\n      require('child_process').spawn('node', [process.env['_'], 'update'], {\n        detached: true,\n        stdio: 'inherit'\n      });\n\n    });\n\n    d.run(function() {\n      Satan.remoteWrapper();\n    });\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-pm2/node_modules/pm2/lib/completion.js":"/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\nvar fs = require('fs'),\n  pth = require('path'),\n  exec = require('child_process').exec;\n\n//  hacked from node-tabtab 0.0.4 https://github.com/mklabs/node-tabtab.git\n//  Itself based on npm completion by @isaac\n\nexports.complete = function complete(name, completer, cb) {\n\n  // cb not there, assume callback is completer and\n  // the completer is the executable itself\n  if(!cb) {\n    cb = completer;\n    completer = name;\n  }\n\n  var env = parseEnv();\n\n  // if not a complete command, return here.\n  if(!env.complete) return cb();\n\n  // if install cmd, add complete script to either ~/.bashrc or ~/.zshrc\n  if(env.install) return install(name, completer, function(err, state) {\n    console.log(state || err.message);\n    if(err) return cb(err);\n    cb(null, null, state);\n  });\n\n  // if install cmd, add complete script to either ~/.bashrc or ~/.zshrc\n  if(env.uninstall) return uninstall(name, completer, function(err, state) {\n    console.log(state || err.message);\n    if(err) return cb(err);\n    cb(null, null, state);\n  });\n\n  // if the COMP_* are not in the env, then dump the install script.\n  if(!env.words || !env.point || !env.line) return script(name, completer, function(err, content) {\n    if(err) return cb(err);\n    process.stdout.write(content, function (n) { cb(null, null, content); });\n    process.stdout.on(\"error\", function (er) {\n      // Darwin is a real dick sometimes.\n      //\n      // This is necessary because the \"source\" or \".\" program in\n      // bash on OS X closes its file argument before reading\n      // from it, meaning that you get exactly 1 write, which will\n      // work most of the time, and will always raise an EPIPE.\n      //\n      // Really, one should not be tossing away EPIPE errors, or any\n      // errors, so casually.  But, without this, `. <(npm completion)`\n      // can never ever work on OS X.\n      //      -- isaacs \n      // https://github.com/isaacs/npm/blob/master/lib/completion.js#L162\n      if (er.errno === \"EPIPE\") er = null\n      cb(er, null, content);\n    });\n    cb(null, null, content);\n  });\n\n  var partial = env.line.substr(0, env.point),\n  last = env.line.split(' ').slice(-1).join(''),\n  lastPartial = partial.split(' ').slice(-1).join(''),\n  prev = env.line.split(' ').slice(0, -1).slice(-1)[0];\n\n  cb(null, {\n    line: env.line,\n    words: env.words,\n    point: env.point,\n    partial: partial,\n    last: last,\n    prev: prev,\n    lastPartial: lastPartial\n  });\n};\n\n// simple helper function to know if the script is run\n// in the context of a completion command. Also mapping the\n// special `<pkgname> completion` cmd.\nexports.isComplete = function isComplete() {\n  var env = parseEnv();\n  return env.complete || (env.words && env.point && env.line);\n};\n\nexports.parseOut = function parseOut(str) {\n  var shorts = str.match(/\\s-\\w+/g);\n  var longs = str.match(/\\s--\\w+/g);\n\n  return {\n    shorts: shorts.map(trim).map(cleanPrefix),\n    longs: longs.map(trim).map(cleanPrefix)\n  };\n};\n\n// specific to cake case\nexports.parseTasks = function(str, prefix, reg) {\n  var tasks = str.match(reg || new RegExp('^' + prefix + '\\\\s[^#]+', 'gm')) || [];\n  return tasks.map(trim).map(function(s) {\n    return s.replace(prefix + ' ', '');\n  });\n};\n\nexports.log = function log(arr, o, prefix) {\n  prefix = prefix || '';\n  arr = Array.isArray(arr) ? arr : [arr];\n  arr.filter(abbrev(o)).forEach(function(v) {\n    console.log(prefix + v);\n  });\n}\n\nfunction trim (s) {\n  return s.trim();\n}\n\nfunction cleanPrefix(s) {\n  return s.replace(/-/g, '');\n}\n\nfunction abbrev(o) { return function(it) {\n  return new RegExp('^' + o.last.replace(/^--?/g, '')).test(it);\n}}\n\n// output the completion.sh script to the console for install instructions.\n// This is actually a 'template' where the package name is used to setup\n// the completion on the right command, and properly name the bash/zsh functions.\nfunction script(name, completer, cb) {\n  var p = pth.join(__dirname, 'completion.sh');\n\n  fs.readFile(p, 'utf8', function (er, d) {\n    if (er) return cb(er);\n    cb(null, d);\n  });\n}\n\nfunction install(name, completer, cb) {\n  var markerIn = '###-begin-' + name + '-completion-###',\n    markerOut = '###-end-' + name + '-completion-###';\n\n  var rc, scriptOutput;\n\n  readRc(completer, function(err, file) {\n    if(err) return cb(err);\n\n    var part = file.split(markerIn)[1];\n    if(part) {\n      return cb(null, ' ✗ ' + completer + ' tab-completion has been already installed. Do nothing.');\n    }\n\n    rc = file;\n    next();\n  });\n\n  script(name, completer, function(err, file) {\n    scriptOutput = file;\n    next();\n  });\n\n  function next() {\n    if(!rc || !scriptOutput) return;\n\n    writeRc(rc + scriptOutput, function(err) {\n      if(err) return cb(err);\n      return cb(null, ' ✓ ' + completer + ' tab-completion installed.');\n    });\n  }\n}\n\nfunction uninstall(name, completer, cb) {\n  var markerIn = '\\n\\n###-begin-' + name + '-completion-###',\n    markerOut = '###-end-' + name + '-completion-###\\n';\n\n  readRc(completer, function(err, file) {\n    if(err) return cb(err);\n\n    var part = file.split(markerIn)[1];\n    if(!part) {\n      return cb(null, ' ✗ ' + completer + ' tab-completion has been already uninstalled. Do nothing.');\n    }\n\n    part = markerIn + part.split(markerOut)[0] + markerOut;\n    writeRc(file.replace(part, ''), function(err) {\n      if(err) return cb(err);\n      return cb(null, ' ✓ ' + completer + ' tab-completion uninstalled.');\n    });\n  });\n}\n\nfunction readRc(completer, cb) {\n  var file = '.' + process.env.SHELL.match(/\\/bin\\/(\\w+)/)[1] + 'rc',\n  filepath = pth.join(process.env.HOME, file);\n  fs.lstat(filepath, function (err, stats) {\n    if(err) return cb(new Error(\"No \" + file + \" file. You'll have to run instead: \" + completer + \" completion >> ~/\" + file));\n    fs.readFile(filepath, 'utf8', cb);\n  });\n}\n\nfunction writeRc(content, cb) {\n  var file = '.' + process.env.SHELL.match(/\\/bin\\/(\\w+)/)[1] + 'rc',\n  filepath = pth.join(process.env.HOME, file);\n  fs.lstat(filepath, function (err, stats) {\n    if(err) return cb(new Error(\"No \" + file + \" file. You'll have to run instead: \" + completer + \" completion >> ~/\" + file));\n    fs.writeFile(filepath, content, cb);\n  });\n}\n\nfunction installed (marker, completer, cb) {\n  readRc(completer, function(err, file) {\n    if(err) return cb(err);\n    var installed = file.match(marker);\n    return cb(!!installed);\n  });\n}\n\nfunction parseEnv() {\n  var args = process.argv.slice(2),\n  complete = args[0] === 'completion';\n\n  return {\n    args: args,\n    complete: complete,\n    install: complete && args[1] === 'install',\n    uninstall: complete && args[1] === 'uninstall',\n    words: +process.env.COMP_CWORD,\n    point: +process.env.COMP_POINT,\n    line: process.env.COMP_LINE\n  }\n};\n"}